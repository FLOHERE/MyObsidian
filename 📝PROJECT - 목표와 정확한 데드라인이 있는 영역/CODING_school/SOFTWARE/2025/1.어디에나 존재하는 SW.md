- 소프트웨어란?
	- 프로그램+프로그램의 개발, 운용, 보수에 필요한 정보 일체
	- 프로그램 소스코드, 데이터, 문서 등
	- 개념적이고 무형적(생산물의 구조가 코드 안에 숨어있음)
- 프로그램 만드는 방법
	1. 요구사항 분석
	2. 플로우 차트 작성
- 소프트웨어 공학의 정의(참조)
	- 소프트웨어에 관련된 분야를 서술적이며 정량적으로 다루는 학문
	- 체계적(일회성 X, 반복 사용 O, 똑같은 방법을 다른 사람이 사용하더라도 유사한 소프트웨어를 만들수 있다.)
	- 원리 적용
- 소웨공의 목표 : 품질 좋은 소프트웨어를 만드는것.(최소 비용, 계획된 일정에 맞춰 개발)

## 0. 소프트웨어 - 특징
- 의존성(dependability) : 사회의 여러 측면 자동화, 두개 이상의 모듈이나 컴포넌트간의 관계.
	- 한 모듈이 다른 모듈에 의해 영향 받음.
	- [[모듈]] : 특정 기능들을 수행하는 코드의 묶음
		- 모듈을 [[캡슐화]] 함.
- 과제(어려움)
	- 일정하지 않은 생산성
	- 결함
- 소프트웨어 개발
	- 여러가지 능력과 지식 요구

>[!note] 엔지니어 != 개발자
>엔지니어와 개발자는 다르다. 엔지니어는 프로젝트를 총괄하고 다른 개발자를 통솔함. 그러나 개발자는 단순히 시키는 코딩만 한다.
>
>- 보고서 기획 정말 중요!!@@
>- 사용자 편의성 고려!!

- 소프트웨어 분류
	- 메모리 관리 무조건 해라
	- 유지보수 계속 해야하는 이유
		1. 버그, 문의 생김
		2. 프로그램이 점점 커짐
	- 플로우 차트 = 알고리즘

## 1. 소프트웨어 공학의 기능
### 1. 명세화(Specification)
- 제품에 대한 작동 방식, 성능 요구 등 협의
	- 소프트웨어가 작동해야 할 기능, 성능, 제품의 원가
	- 위험 및 일정 등의 제약
	- 소프트웨어 제작 단계 이전 요구사항을 정확하게 파악하여 개발의 실패를 방지
#### 명세서 순서
1. 제목
2. 요약
3. 실현 가능성
4. 플로우 차트 설계
5. 테스트 만족성(사용자 만족도)
6. 배포
### 2. 구현(Coding)
- 주어진 여건에 맞게 설계, 프로그래밍 언어로 변환
- 명세에 주어진 요구사항에 따라 설계 -> 프로그래밍 언어로 변환
### 3. 검증(verification)
- 고객의 의도와 일치하는지 확인하는 방법
	- 테스팅 단계
### 4. 유지 보수(maintenance)
- 사용 단계에서 발견된 결함 수정

>[!note] 공학 VS 과학
>- 공학 : 정답이 없다(0에서 부터 시작, 창조)
>- 과학 : 정답이 있다.

## 2. 소프트웨어 공학의 어려움 - 특징

### 1. 복잡성(complexity)
- 소프트웨어의 본질
- 자동화 하려는 대상, 내부 요소들간의 다양하고 복잡한 상호 관계

### 2. 순응성(conformity)
- 소프트웨어 요구 사항
- 요구, 환경, 데이터의 변화에 따라 적절히 변형
### 3. 변경성(changeability)
- 소프트웨어는 끊임 없이 변화한다.
- 프로그램 코드의 변경, 개발과정이 빈번히 변경
- ex_) 새로운 기술 도입, 보안 취약점
	- 하드웨어는 노후화되지 않지만 시스템은 새로운 요구 사항을 반영하기 위해 계속 변경되어야 한다.
- 환경, 법규, 정책
	- 요구사항이 변하면 소프트웨어도 변경된다.

### 4. 비가시성(invisibility)
- 소프트웨어 물리적으로 보이지 않기 때문에 이해가 어렵다
- 프로그램의 구조가 코드 안에 숨어있어 드러나지 않음
	- 건축물 or 기계 설계도 처럼 직관적이지 않다. -> 이해 어려움
	- 형태 X
	- 코드 + 논리적 구조
	- 소프트웨어 설계, 디버깅, 유지보수 복잡, 개발자의 경험과 직감에 의존

### 5. 소프트웨어 개발의 어려움
#### 1. 명세화의 어려움
- 고객의 의도파악(설명, 이해) 어려움

#### 2. 유지 보수의 어려움
- 다른 사람이 제작한 소프트웨어를 이해하기 어려움.
- 고쳐도 다른 관련 부분에서 오류 발생할 가능성.

#### 3. 재사용의 어려움
- 미리 재사용할 부품 제작의 어려움
- 다루는 문제가 모두 다르다

#### 4. 고품질의 어려움
- 한줄의 코드를 작성해도 테스트할 내용이 많다.

#### 5. 예측의 어려움
- 여러 외부 요소 영향을 받아 사전 견적, 프로젝트 규모 측정의 어려움
	- ex_) 업무 절차, 법규, 하드웨어, 데이터, 형식, 성능 조건 등

### 6. 소프트웨어 위기
- 소프트웨어 수요가 급증 -> 복잡성 증가 -> 기존 방법이 충분하지 않아 발생한 문제
- 소프트웨어 수요 증가에 대비하여 개발, 공급의 어려움을 나타내는 말
1. 요구 증가
2. 복잡도 증가
3. 난이도 증가
4. 같은 인력
5. 같은 방법
6. 같은 도구

>[!note] 교수님의 코멘트
>흔히 기업과 기업의 거래 정도로 생각하고 외주를 받는데 사실 아님. 우리 기업에 뭐좀 만들어 달라고 하면 그게 기업이든 어떤 형태든 그건 손님임. 

## 3. 프로그래머 VS 소프트웨어 엔지니어

### 1. 프로그래머(개인)
- 개발의 관점 : 전체 중 하나의 컴포넌트
- 갖춰야 할 스킬 : 프로그래밍 언어와 알고리즘, 자료 구조
- 이르이 접근 방법 : 해보고 부딪혀보기
- 작업 방법 : 독립적
- 훈련방법 : 프로그래밍 연습
- 소프트웨어 개발 중 일부분 코드 작성
- 코딩은 프로그램 자체 실행에 맞춰져 있음.

### 2. 소프트웨어 엔지니어(협업)
- 개발 관련 : 소프트웨어 개발 전체 작업
- 갖춰야 할 스킬 : 프로그래밍과 컴퓨터 공학 지식을 바탕으로 한 개발 전체 단계 작업 능력
- 일의 접근 방법 : 엔지니어링 원리 공부, 최적의 방법으로 제공
- 작업 방법 : 다른 동료와 팀으로 협업
- 훈련 방법 : 프로그래밍을 기초한 소프트웨어 개발 프로젝트
- 전체 작업 포함
- 소프트웨어 엔지니어링 문제에 대한 소프트웨어적 해결책, 타당성, 미래의 사용까지 생각

## 4. 소프트웨어 분류(종류)
- 주문형 소프트웨어
- 패키지 소프트웨어
- 임베디드 소프트웨어 : 전자기기 안에 있는 소프트웨어, 하드웨어 + 소프트웨어로 구성

### 1. 주문형 소프트웨어
- 특정 고객의 수요를 만족하기 위해 개발된 소프트웨어
- 사용할 내부에서 직접 개발 or 외주에 발주하여 개발 의뢰
- ex_) 웹사이트, 항공기-교통제어 시스템, 대기업 재정관리 시스템 등
- 특징
	- 특정 고객 or 기업의 요구를 만족시키기 위해 제작한 소프트웨어
- 사용되는 카피의 수 : 적음
- 요구되는 하드웨어의 성능 : 낮음
- 개발 인력 : 많음
### 2. 패키지형 소프트웨어
- 공개된 시장(앱스토어 등)에서 판매하기 위한것. 범용 컴퓨터에서 실행 되는 S/W
- S/W 요구사항은 시장의 요구에 의해 결정
- ex_) 워드 프로세스, 컴파일러, 웹 브라우저, 컴퓨터 게임, 유통 업체, POS 시스템, 재정 분석, 주문관리, 회계 관리 시스템 등등
- 특징
	- 패키지화 하여 상업적으로 판매하는 소프트웨어
- 사용되는 카피의 수 : 중간
- 요구되는 하드웨어 성능 : 높음
- 개발 인력 : 중간

### 3. 임베디드 소프트웨어
- 시장에서 판매되는 하드웨어 장치에서 수행되는 S/W
	- ex_)세탁기, 자동차 등
- 범용 S/W와 달리 하드웨어를 교체 하지 않는 한, S/W 업그레이드 어려움
- 하드웨어 장치가 범용으로 판매된다는 의미에서 범용 패키지 소프트웨어와 유사
  but 개발 방법과 프로세스가 달라 별도의 분야로 취급
- 특징
	- 다른 시스템에 내장된 소프트웨어
- 사용되는 카피의 수 : 많음
- 요구되는 하드웨어 성능 : 중간
- 개발 인력 : 적음

>[!note] 시스템
>- 정의 : 필요한 기능을 실현시키기 위해 관련 요소를 어떤 법칙에 따라 조합한 집합체
>- 컴퓨터 시스템, 운영 시스템, 조직 관리 시스템...
>- 소프트웨어는 독립적으로 존재 X, 컴퓨터 기반으로 하는 여러 시스템과 관계 맺고 있음.(서로 밀접한 상호 작용)

## 5. 단계적 프로세스
### 1. 요구분석
- 사용자의 요구를 추출하고 정리
- 시스템이 제공해야 할 기능, 성능, 제약사항 등 파악

### 2. 설계
- 요구 명세에 기술된 문제의 솔루션 기술하는 작업
- 건출 설계 도면과 같이 소프트웨어를 구성하는 요소, 구조, 인터페이스 정의
- 모듈, 데이터, 유저 인터페이스 설계

### 3. 코딩(구현)
- 설계 기초, 프로그래밍 작업

### 4. 테스팅
- 개발된 소프트웨어에 결함 있는지 검토, 확인
- 설계, 우너시코드, 분석을 통한 테스팅
- 테스트 데이터를 준비하여 테스팅

### 5. 유지 보수
| 단계  | 초점                   | 주요 작업과 기술                                                             | 결과물                     |
| --- | -------------------- | --------------------------------------------------------------------- | ----------------------- |
| 분석  | - 고객의 요구 사항 파악       | - 분석 전략과 수립<br>- 요구 결정<br>- 유스케이스 분석<br>- 구조적 모델링<br>- 동적 모델링         | 요구분석 명세서                |
| 설계  | - 시스템을 어떻게 구축할 것인가   | - 설계 전략 수립<br>- 아키텍쳐 설계<br>- 인터페이스 설계<br>- 프로그램 설계<br>- 데이터베이스, 파일 설계 | 설계 명세서                  |
| 구현  | - 시스템의 코딩과 단위 시험     | - 프로그래밍<br>- 단위 테스팅<br>- 시스템 안정화 및 유지보수                               | - 새 시스템, <br>- 유지 보수 계획 |
| 테스팅 | - 시스템이 요구에 맞게 실행 되나? | - 통합 테스팅<br>- 시스템 테스팅<br>- 인수 테스팅<br>- 시스템의 설치<br>- 프로젝트 관리 계획        | 테스팅 결과 보고서              |
