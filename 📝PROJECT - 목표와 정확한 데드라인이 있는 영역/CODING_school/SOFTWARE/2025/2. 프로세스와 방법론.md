## 0. 프로세스와 프로세스 모델
- 프로세스 명세
	- 프로젝트에서 수행하여야 하는 작업과 이들의 수행 순서 정의
	- 실행 프로세스는 다를 수 있음
- 프로세스 모델
	- 일반적인 프로세스 기술
	- 작업의 단계와 순서
	- 각 단계 작업 수행의 제약사항이나 조건 등을 모아놓은것.

![[Pasted image 20250423010311.png]]

좋은 프로세스의 특징 및 각 프로세스의 정의는 "2023년" 폴더의 "Ch_02 프로세스와 방법론" 파일 참조

### 프로세스 정의
- 목적
	- 프로세스를 수행하기 위한 목적
	- 프로세스를 효과적으로 구현했을때의 기대되는 성과
- 작업 방법
	- 프로세스에서 해야 할 작업
- 성과
	- 프로세스 작업의 결과물
	- 문서의 내용이나 코드, 프로토타입 등 구체적인 작업 결과

#### 설계 프로세스의 정의
- 아케텍쳐 모델과 뷰에 정의된 아키텍쳐 요소와 일치하는 구현 가능하도록
  시스템과각 요소들에 대한 상세한 데이터와 정보 제공
1. 소프트웨어 시스템 설계 준비
2. 소프트웨어 시스템 각 요소와 관련된 설계 확립
3. 여러가지 설계 대안을 평가
4. 설계 관리
- 시스템 요소의디자인적 특징 정의
- 소프트웨어 요구가 할당된 시스템요소 설계
- 시스템 요소들 사이의 인터페이스 정의
- 시스템 요소를 위한 설게 대안의평가

## 2. 전통적 모델
- 모델
	- 특정 관점에서 나타낸 일반적인 프로세스의 유형
### 1. 폭포수 모델
- 가장 오래되고 널리 사용된 프로세스 모델
- 선형적
	- 각 단계가 다음 단계 시작 전에 끝나야 함
	- 각 단계 사이에 중복이나 상호 작용이 없음
	- 각 단게의 결과는 다음 단게가 시작 되기 전에 점검
- 직능 중심의 프로젝트 조직 가능
- 적용 분야
	- 크고 복잡한 오래 지속되는 프로젝트에 적합
	- ex_) 공정 제어, 하드웨어 연결 등

![[폭포수 모델.canvas]]


#### 장점
- 프로세스가 단순 -> 초보자도 쉽게 적용 가능
- 중간 산출물 명확, 관리 하기 좋음
- 코드 생성 전 충분한 연구자와 분석 관계
#### 단점
- 소용없는 다종의 문서를 생산할 가능성 있음
- 애매한 부분이 남아 있거나 프로세스 진행 과정에 변경될수 있는데 이를 수용 할수 없다.
- 테스트 작업이 프로젝트 후반, 즉 시스템이 완성된 후에 시작됨.

### 2. V 모델
- 검증을 강화하는 관점에서 폭포수 모델을 확장한 모델
- 단위 테스트 : 단위가 되는 모듈의 검증
- 통합 테스트 : 모듈 들의 인터페이스 작동 검증
- 시스템 테스트 : 전체 시스템 빌드 후 검증
- 인수 테스트 - 사용자가 요구를 제대로 반영하였는지 확인

![[Pasted image 20231025220028.png]]


### 3. 프로토타이핑 모델
- 프로토 타이핑
	- 요구 사항에 대한 피드백을 받기 위해 시스템을 실험적으로 만들어 사용자에게 보여주고 평가하게 하는 방법
- 프로토타이핑 도구
	- 화면 생성기
	- 시스템의 작동을 시뮬레이션 하여 사용자가 볼수있는 반응을 보여줌
- 공동의 참조 모델
	- 사용자와 개발자의 의사소통을 도와주는 매개체
- 프로토타입의 목적
	- 단순한 요구 추출 - 만들고 버림
	- 제작 가능성 타진 - 개발 단계에서 유지 보수

![[프로토 타이핑 모델.canvas]]

#### 장점
- 사용자의 의견 반영 잘됨
- 사용자가 더 관심을  가지고 참여 가능. 개발자는 요구를 더 정확히 도출 가능

#### 단점
- 오해, 기대 심리 유발
- 관리가 어려움(중간 산출물의 정의가 난해)

#### 적용
- 개발 착수 시점에 요구가 불투명 할때
- 실험적으로 실형 가능성을 타진해 보고 싶을때
- 혁신적인 기술을 사용해 보고 싶을때

### 4. 점증적 모델
- 한번에 개발하기 보다는 적은 단위로 나누어 점증적으로 개발
- 빠른 배포가 필요 할때 -> 각 단위가 완료될때 마다 시스템을 추가 할수 있다.
	- ex_) 건축 - 큰 틀만 만들어 놓고 그 안에 작은 방 건축

>[!note] 폭포수 모델
>폭포수 모델은 사이즈가 자꾸 커지고 무거워 진다.
>=> 최종적으로 성능 저하

#### 특징
1. 점진적 : 점차 앞으로 나가면서 개발
2. 전체 시스템
3. 작은 단위 부분으로 나뉘어 개발

#### 장점
1. 개발 단계의 수정 쉬움
2. 배포 빠름
3. 필요한 부분만 만들고 이후 기능 추가

### 5. 진화적 모델
- 위험 분석과 반복적 개발을 통해 소프트웨어를 점진적으로 개발하는 모델
- 절대 한번에 완성 X
- 위험 요소를 분석하면서 반복적으로 발전
	- ex_) 자동차 같은 경우 하나라도 잘못되면 큰일남 
		=> 기본 프레임(바퀴/ 첫번쨰 반복)
		  엔진 내부 구조(두번째 반복)
		  디자인, 편의 기능 제공(세번쨰 반복)
		  자동차 충돌 테스트 후 제공

>[!note] 점진적이란?
>각 반복 주기마다 기능을 추가하면서 소프트웨어 발전

#### 장점
- 몇가지 기능 부족 -> 초기에 사용 교육 가능
- 사요자의 요구를 빠르게 반영
- 새로운 기능을 가진 소프트웨어에 대해 시장 형성 빠름
- 가동중이 ㄴ시스템에서 일어나는 에상치 못했던 문제 -> 신속하고 꾸준히 개선

#### 단점
- 프로젝트 관리 복잡 -> 큰 프로젝트 부적합
- 끝이 안보임 -> 실패의 위험 커짐
- 프로젝트의 진행이 위험 분석에 크게 의존

![[Pasted image 20250423034627.png]]

### 6. 나선형 모델
- 점진적 개발과 반복적인 프롵토타이핑을 결합한 모델
- 한번에 모든 기능 개발 X => 여러번 반복 거치면서 점점 발전
- 위험 분석 : 반복 추가마다 위험 요소 분석
	- ex_) 기술적 한계, 비용, 일정(예측)
- 실패 위험 줄임, 테스트 용이, 피드백, 여러번의점증적인 릴리스
- Boehm이 제안
- 반복 순환 단계
	1. 목표, 방법, 제약조건 결정
	2. 위험 요소 분석 및 해결
	3. 개발과 평가
	4. 다음 단계의 계획

#### 계획
1. 프로젝트 목표(고객 요구사항)
	1. 예산과 일정 수립
2. 위험 분석
	1. 프로젝트에서 발생 할수 있는 문제 예측
	2. 해결방법 논의, 프로토타입 제작
3. 개발 및 실행
	1. 소프트웨어 설계 개발
	2. 테스트 단계 수행
4. 고객 평가
	1. 사용자의 피드백(수정 할 부분 확인 후 다음 개발 주기에 반영)

#### 장점
- 프로토타입의 설계의 경우
	- 제약 조건 요청 가능
	- 빠른 피드백
- 대규모 시스템 개발에 적합
- 반복적인 개발 및 테스트 - 강인성 향상
- 한 사이클에 추가 못한 기능은 다음 단게에 추가 가능

#### 단점
- 시간 소요
- 문서화 필요
- 관리 복잡
- 위험 분석을 잘못하여 지나친 경우 -> 피해가 크다

#### 적용
- 재정적 또는 기술적으로 위험 부담이 큰 경우
- 요구 사항이나 아키텍쳐 이해에 어려운 경우

### 7. 컴포넌트 기반 모델
- 이미 개발된 소프트웨어 컴포넌트(모듈)을 조합하여 새로운 시스템을 만드는 방법
	- ex_) 레고처럼
- 기보느이 기능을 재사용하면서 빠르게 개발하는 방식

#### 상용 소프트웨어
- 그대로 사용 or 일부 수정
	- ex_) Adobe Photoshop, Office...

#### 장점
1. 빠른 개발
2. 비용 절감
	- 새로 개발하는것 보다 비용과 리스크가 적다 
3. 유지보수 용이
	-  유지보수 및 지원 제공을 받을 수 있다.
4. 확장성 높음
	- 필요할때만 기능 가져와서 사용함
	- ex_) Google Map API + 결제 시스템(배달 앱)
5. 높은 신뢰성이
	- 검증된 소프트웨어를 사용

### 9. 통합 프로세스(Unified 프로세스)
#### 1. 도입 : 프로젝트가 타당한지 검토
- 비용과 일정 초기 수정
- 프로젝트 기초 확립
- 필요성 : 프로젝트의 방향성 설정 -> 사업적 가치 평가 -> 개발 계속 할지 결정
#### 2. 정련 : 아키텍쳐 및 리스크 해결
- 시스템 아키텍쳐를 구체화
- 주요 기술적 위험 요소 분석
- 프로토 타입 개발
- 필요성 : 리스크 최소화
#### 3. 구축 : 실제 시스템 개발
- 소프트웨어 개발
- 코드 작성, 테스트 통합 수행
- 아키텍쳐와 요구사항을 기반으로 기능 실제로 구현
#### 4. 전환 : 실제 운영 환경으로 전환
- 필요성 : 개발이 끝난 후에도 사용자가 실제 환경에서 문제 없이 사용할수 있도록 보장

![[Pasted image 20231025221929.png]]



### 10. 에자일 모델
- 빠르게 개발 => 계속 수정하면서 발전
- 반복적이고 점진적인 개발

>[!note] 방법론이란?
>소프트웨어가 각 작업을 수행하는 방법
>=> 프로세스와 방법론 모두 필요

#### 적용 사례
- 카카오톡
	1. 초기에는 단순한 메세지 앱
	2. 사용자 피드백
	3. 반영(이모티콘, 선물하기, 페이 기능)
- 쿠팡
	1. 쇼핑몰 사용자 요구사항 반영
		- 로켓배송, 새벽배송, 정기 배송
- 테슬라
	1. 소프트웨어 업데이트

##### 크리스탈
- 애자일 방법론중 하나, 경량 개발 프로세스를 기반으로 함
	- 유연성, 인간 중심 개발(유연 + 협업)

1. 유연 + 사람 중심적 개발
	- 절차 < 프로젝트 상황 + 팀원들의 요구사항에 맞게 프로세스 조정
	- 문서화 < 실제 동작 소프트웨어 중심
2. 프로젝트 규모에 따라 차별화
	- Crystal clear : 팀원이 6명 이하일때 사용
	- Crystal Yellow : 7~20
	- Crystal Orange : 21~40
	- Crystal Red Blue Violet : 50 이상
- 유연성, 협업
-  개발팀 자율성, 효율성 극대화
- 적응형 프로세스 : 프로젝트 상황에 맞춰 개발 방식을 유연하게 변경

# \[참조] 소프트웨어 프로세스 VS 방법론

- 각 방법론 그림 꼭 봐라

|     | 프로세스                                                                                                  | 방법론                                                                                                    |
| --- | ----------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ |
| 특징  | - 단계적인 작업의 틀을 정의한것<br>- 무엇을 하는가에 중점<br>- 결과물의 표현에 대하여 언급 없음<br>- 패러다임에 독립적<br>- 각 단계가 다른 방법론으로도 실현 가능 | - 프로세스의 구체적인 구현에 이름<br>- 어떻게 하는가에 중점<br>- 결과물을 어떻게 표현하는지 표시<br>- 패러다임에 종속적<br>- 각 단계의 절차, 기술, 가이드라인 제시 |
| 사례  | - 폭포수 프로세스<br>- 나선형 프로세스<br>- 프로토타이핑 프로세스<br>- Unified 프로세스<br>- 에자일 프로세스                             | - 구조적 분석, 설계 방법론<br>- 객체지향 방법론<br>- 컴포넌트<br>- 애자일 방법론                                                  |
