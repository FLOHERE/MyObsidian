- 클래스 타입
- 인터페이스 타입
- 내포타입
- 어노테이션 타입
- 제너릭 코드
- 기본 클래스

# 3.객체형 부품
- 절차지향 프로그래밍
- 객체 지향 프로그래밍

- 프로그램 드리븐 프로그램(Program Driven Program) : 프로그램 자체에서 코드 수행 흐름을 갖는 프로그램
	- 프로그램을 구성하는 코드 or 코드들의 순서가 수행 흐름을 결정
		- UI를 가지지 않은 프로그램 -> 프로그램 자신이 수행 흐름 주도 필요
		  (프로그램의 다음 어느 부분을 수행할것인지, 사용자로부터 입력을 받을건지..)
		- UI(User Interface, 사용자 인터페이스)
	- 코드들의 수행 순서 등이 의미가 크다 =  절차를 지향해야 한다.
	  (+ 코드 흐름도 사용 필요(Flow Chart))

## 3.0 절차 지향형 프로그래밍(Procedural Oriented Programming)과 객체 지향 프로그래밍(Object Oriented Programming)

### 절차 지향 프로그래밍
- 현실 세계의 도메인에 어떤 일들이 존재하는가를 찾고 그 일들이 어떤 절차로 진행되는가를 분석
  -> 그 절차대로 프로그램 코드를 구성하는 프로그램 제작 기술
-  주로 목적으로 하는 값을 계산, 연산
- 순차적인 처리가 중요
- 개발 하려는 것을 기능별로 묶어 "모듈화" 함.
- 하드웨어가 같은 기능을 중복으로 연산 X. 모듈 재활용
- 하드웨어의 처리량을 획기적으로 줄여줌
	- 단점
		- UI가 존재하지 않아 사용하기에 불편 
		- 프로그램을 구성하는 코드들 사이의 코드 연결 강도가 높아, 프로그램의 수정과 변경이 어렵다.
	- 그래도 쓰는 이유
		- 프로그래밍 언어만 이해하면 프로그램 제작 가능
		- 언어 학습 과정에서 예제 코듣 등을 다룰때 주로 사용하는 프로그램 형태이기 때문

- UI를 사용하는 프로그램은 UI가 프로그램의 수행 흐름을 주도
- UI를 통해 전달되는 사용자의 요청이 프로그램의 다음 어느 부분을 수행 할건지 결정
- 이벤트 드리븐 프로그램(Event Driven Program)
	- UI를 통해 전달되는 사용자 요청(이벤트가 프로그램의 수행 흐름 주도)을 말함.
	- 객체에 전달되는 메세지의 의해 객체가 동작(=객체형 프로그램 수행 동작 방식)
	- 객체 지향적으로 제작

###  객체지향 프로그래밍
- 현실 세계 실 객체 -> 프로그램 세계의 객체들로 묘사
- 현실 세계에서 발생하는 사건들은 프로그램 세계의 메세지들로 구현
  -> 프로그램의 동작이 현실 세계의 움직임과 동일하게 수행 되도록 함
- *한마디로!* *"현실세계의 것을 프로그램에 그대로 구현하여 수행되는 프로그램 제작 기술"*
- 자바 언어
	- 컴파일러 언어
		- 컴파일러 : 객체형 프로그램을 제작할때 필요한 여러가지 기능을 제공하는것.
	- 객체 생성 + 객체 사이의 관계 설정 및 동작 -> 표현 가능

## 3.0 객체 구현 주요 기술
- 현실세계의  실객체를 그대로 표현 -> 현실세계의 복잡함을 좀 더 효율적으로 표현 하려한다
	- 클래스화
		- 동적 속성(객체의 동작)이 동일하거나 유사한 객체들은 하나의 그룹인 클래스로 집단화
		  -> 한번만  표현 가능
		- 객체형 컴파일러 언어(ex_JAVA) -> 집단화되지 않은 객체(=집단에 소속되는 객체가 1개뿐)에 대해 클래스 사용
		- => 실세계의 모든 객체들을 클래스로 표현
		  프로그램 세계에서 동작하는 모든SW 객체 들은 이러한 클래스로 부터 객체를 생성하여 동작
		- 객체 지향 분석의 개념
			1. 시스템
			2. 객체 추출
			3. 그룹화(클래스 생성)
			4. 관계
	- 상속
		- 클래스를 구현 할때 공통되는 부분이 있다면.......
			- 각 클래스에서 반복적으로 중복 코딩 하지 않는다.
			- 부모 클래스를 이용하여 한번만 묘사한다.
			- 자식 클래스는 상속을 이용한 코드 재사용 -> 클래스의 중복을 줄임
		- 자바에서 클래스를 정의 할때 특정 클래스를 상속하지 않으면 컴파일러가 Object 클래스를 강제 상속 시킴
		- => 자바 Object 클래스는 최상위 조상 클래스가 됨.
		  자바의 모든 클래스는 Object 클래스를 직간접 상속받음
		- *한마디로! "부모 클래스 = 틀 잡아주는거 -> 자식 클래스 = 틀에서 나온것(but 내용물은 다름)"*
	- 추상화
		- 현실 세계의 실 객체들이 가지는 특징, 기능 중 답을 구하는데 관련되지 않거나 관련이 적은 부분은 생략 or 축소 표현
		- 관련 있으면, 요약하여 클래스에 기술
		- => 추상화를 위해 자바 언어가 제공하는 문법적인 요소 존재 X
		  개발자가 에플리케이션을 설계할때 이를 고려, 클래스에 반영 해야함.
	- 캡슐화
		- 객체 표현시 객체 자신의 내용은 보호 + 다른 객체와의 불필요한 관게를 줄이기 위함.
		- 다른 객체와 관계되지 않는 부분들은 캡슐 내부에 숨김
		- 데이터 + 메서드 -> 얘네는 세트임
		- 다른 객체와 관련될 경우
			- 그래도 캡슐 사용. 게테, 세터 메서드를 캡슐 외부에 들어냄
			- 접근 제한자 : 객체와 맴버의 캡슐 두께를 조절.
	- 다형성 
		- 객체 사이의 관계가 의존 관계일때 -> 사용 객체가 대상 객체의 메서드를 접근 할때 객체를 생성한 클래스 타입으로 직접 접근 X
		- 인터페이스 타입 혹은 조상 클래스 타입 등 사용 -> 간접적으로 접근
		- 동일 문장으로 기능을 수행 할수 있는 코드 제작 가능
		- -> 자바의 경우 : 인터페이스 타입이라는 개발자 정의 타입 제공.
			- 상속 받았거나 반영될 타입의 메서드를 재정의  할수 있는 기능 등 제공
			- 컨테이너가 제공하는 의존 주입기능등을 복합적으로 사용 -> 애플리케이션을 변경 -> 개발코드 변경 X, 컨테이너의 변경만으로 애플리케이션 변경 수행 가능
	- 관점 분리
		- 핵심 기능과 보조 기능을 서로 다른 객체에 분리 후 제작.
		- 핵심 기능 객체 수행시 프록시 등을 동원 -> 객체를 통합, 수행
		- 핵심 관점 사항과 관련 -> 응집력 높은 객체 개발을 가능하게 함.
		- 보조 기능이 여러 핵심 기능 객체에서 공통으로 사용될때 보조 기능의 중복 코딩 방지.
		- -> 자바 언어가 제공하는 기능은 없음. 관련 사항들은 스프링 컨테이너 등을 사용하여 구현
		  
		- AOP 관점 지향 프로그래밍(Aspect-Oriented Programming)
			- 프로그래밍 영역이 수행 프로그램 컴파일러 방법을 결정하는 프로그래밍 방법

## 3.0 객체 관계
- 객체형 프로그램 : 클래스로부터 객체 생성 -> 생성되는 객체는 다른 객체들과 관계 형성
  -> 관계된 각 객체들의 동작 과정으로 애플리케이션 수행 진행
- 컨테이너를 사용하는 스프링 애플리케이션, 표준 프레임 워크 애플리케이션 등은 이러한 객체 생성, 객체 사이의 관계 설정, 관계된 객체들의 작동 등 컨테이너가 이를 수행하도록 함.
- 쓰레기 객체 : 애플리케이션이 실행되는 과정에서 다른 객체와 관계를 맺지 못하는 객체들 
	- 쓰레기 수집기(Garbage Collector) : 쓰레기 객체 회수함.
- 상속 관계
	- 클래스 상속에 의해 맺어지는 객체 사이의 관계
	- 클래스로부터 객체를 생성 
	  -> 현재 클래스로부터의 해당 객체 생성 + 상속 받는 모든 조상 클래스들 ~ 조상 객체들 까지 함께 생성
	- 객체 사이의 상속 관계 맺음
- 포함 관계
	- 애플리 케이션을 구성하는 큰 부품 객체 + 작은 부품 객체들 사이의 관계
	- 큰 부품 객체 : 필드에 작은 부품 객체들의 참조값을 저장하는 형태
	- 부품 객체들과의 관계 구현
- 의존 관계
	- 애플리케이션이 실행되는 과정에서 객체의 기능을 다른 객체에 의존하는 관계(지가 수행 안함)
	- 상속 관계와 포함 관계는 객체가 생성되는 과정에서 객체 사이에 맺어지는 관계
	- 객체 관계
		- 객체를 구성할때 하나의 객체를 여러 개의 클래스로 분리 후 구현
		  -> 이를 연결
	- but 의존 관계!
		- 애플리케이션 진행 과정에서 생성된 객체가 동작 할때 사용 객체가 대상 객체의 메서드를 호출
		- 사용 객체 자신이 수행햐야 할 일들을 대상 객체에게 이를 위임.
		- 사용 객체가 대상 객체의 메서드를 호출 하려면 사용 객체가 자신의 필드에 대상 객체의 참조 값을 가지고 있으면서 이를 사용 -> 객체에 먼저 접근 후 그 객체의 메서드를 호출

## 3.0 개발자 정의 타입
- 자바 애플리 케이션에서 객체를 생성 할때 클래스타입이라는 개발자 정의 타입을 사용 -> 객체 생성
- 생성된 객체를 사용 -> 객체를 생성할때 사용된 클래스 타입에 반영된 인터페이스 타입이라는 개발자 정의 타입 사용하여 객체에 접근
- 애플리케이션의 다른 곳에서 제공되는 서비스를 사용하려 할때
	- 어노테이션 타입(개발자 정의 타입)을 사용
- 개발자 정의타입은 기본적으로 적절한 패키지 + 별도의 .java 파일 사용 -> 타입 정의 
	- 이를 컴파일러로 번역 -> 각 타입별로 별도의 .class 파일이 생성

- 클래스 타입
	- 객체를 생성할때 쓰는 개발자 정의 타입
	- 객체를 생성 -> new 연산자 사용
	- 그 클래스 타입의 적절한 생성자 메서드를 호출 -> 객체 생성
	- 클래스 별로 생성자 메서드는 반드시 존재
	- 클래스 타입에 생성자 메서드가 존재 X : 컴파일러가 번역 과정에서 기본 생성자를 만들어 넣음.
		- 기본 생성자 : 형식 매개변수도 없고 내용이 없는 몸통으로 구성되는 생성자
- 인터페이스 타입
	- 객체 사용법을 정의하는 개발자 정의 타입
	- 인터페이스 타입을 반영하는 클래스로 부터 객체를 생성 -> 클래스 타입으로도 그 객체를 접근 가능
	  but 클래스 타입에 반영된 인터페이스 타입으로도 객체에 접근 가능
	- 인터페이스 접근시 객체지향의 다형성 구현 가능
	- 실체를 생성하는 타입이 아님. -> 생성자 메서드 존재 X.
		- 일반 메서드들도 실행을 목적으로 하지 않음
		- 메서드의 몸통이 없는 추상 메서드들로 전체 타입이 구성
- 어노테이션 타입
	- 프로젝트 다른 곳으로 서비스 제공 
	  -> 서비스 사용법을 정의하는 어노테이션 타입도 함께 정의해서 제공 해야함
	- 서비스를 제공 받는 프로젝트는 제공되는 어노테이션을 사용하여 제공 서비스 사용

# 3.1 클래스 타입
- 타입 정의 : 적절한 패키지 + 별도의 .java 파일 사용하여 수행
- but! 중첩 클래스(멤버 클래스와 로컬 클래스), 익명 클래스(익명 자식 클래스와 익명 구현 클래스), 람다 클래스 등의 내포 타입의 클래스 타입에 대한 정의는 별도의 .java 파일을 사용 하지 않고 타입 정의
- 하나의 .java 파일에 내포 타입이 아닌 여러개의 타입 정의시
	- .java 파일의 이름값과 타입의 접근 제한이 public 타입인 이름값은 동일한 이름값을 사용
	- 하나의 .java. 파일에는 public 타입이 1개만 존재함.
- 한편 .java 파일 컴파일 -> 각 타입별로 별도의 .class 파일 생성
- 기본 클래스, 중첩 클래스 등의 클래스 타입 정의시 class 예약어 사용과 클래스 이름값을 지정하면서 클래스를 정의
	- but , 익명 클래스와 람다 클래스 등은 class 예약어 사용과 클래스 이름값을 지정하지 않고 클래스타입을 정의

## 3.1 클래스 타입 정의
- 기본 형식 : 머리 + 몸통
	- 머리 : 타입의 전체적인 내용 
	- 몸통 : 타입의 구체적인 세부 내용
- 클래스 멤버들에 대한 정의 : 클래스의 멤버 + 클래스에서 생성되는 객체의 멤버를 해당 클래스 내부에 동시에 기술

### 머리
- class 예약어 사용 
- 클래스 이름값 지정
- 접근 제한자(public, default...)
- 예약어(abstract, final)들을 class 예약어 이전 위치에서 사용하면서 클래스를 정의
  
- 클래스 접근 제한자
	- public : 현재 정의 되는 클래스는 접근 제한 없이 사용하는 것이 가능
	- default : 현재 정의 되는 클래스는 동일 패키지에서만 사용하는 것이 가능.
	  접근 제한자 사용 안할시, default로 동작
- abstract : 객체를 생성할수 없는 추상 클래스를 정의
- final : 상속을 수행 할수 없는 최종 클래스 정의

- 또한 머리 부분의 클래스 이름값 이후 위치 -> extends 예약어를 사용 -> 상속 받을 클래스 지정 or implements 등의 예약어 들을 사용
	- extends : 상속 받을 클래스 지정, 다중 클래스 상속 불가능
	- implements : 객체 접근에 사용될 인터페이스 지정, 다중 인터페이스 지정 가능

### 몸통
- 클래스와 객체를 구성하는 각 요소들은 클래스 블록({}) 내부에서 다음과 같은 멤버 사용
	- 정적 요소(속성) : 필드 멤버로 기술
	- 동적 요소(동작) : 메서드 멤버로 기술
- 멤버가 클래스에 소속 or 객체에 소속 여부
	- 클래스 소속 멤버 : static 멤버로 기술
	- 객체 소속 멤버 : 비 static 멤버로 기술
- 메서드 멤버의 종류
	- 생성자 메서드 : 객체를 생성할때 호출되는 메서드
	- 게터 메서드 + 세터 메서드 : 캡슐화를 구현 할때 사용되는 메서드
	- 일반 메서드 : 객체나 클래스의 동작을 기술하는 메서드

## 3.1 멤버 정의
- 일반적인 속성 이외에 클래스에 소속되는 각 멤버들에 대한 속성에 대한 예약어 사용(각 멤버의 세부적인 속성들을 기술하는것이 가능)
	- 접근 제한
	- abstract 여부
		- abstract 속성(=abstract 예약어 사용시) : 메서드에 대해 사용하는 속성, 몸통이 없는 추상 메서드
	- final 여부
		- final 속성(=final 예약어 사용시)
		- final 필드 : 값을 한번 할당하면 그 값을 수정할수 없는 필드
		- final 메서드 : 후손 클래스에서 재정의를 할수 없는 메서드
- 멤버 접근 제한
	1. public : 모든 위치에서 접근 가능한 멤버
	2. protected : 동일 패키지에 소속되지 않더라도 후손에서는 접근 가능한 멤버
	3. (default) : 동일 패키지에서만 접근 가능, 멤버에 대해 접근 제한을 기술하지 않으면 default 접근 제한 적용
	4. private : 클래스 혹은 객체 자신만이 접근 가능한 멤버
- 클래스나 객체 외부에서 멤버를 접근 할때..
	- static 멤버 -> 클래스 이름값 사용
	- 비 static 멤버 -> 객체 참조 변수 사용
- 해당 클래스나 객체에 먼저 접근 -> 점(.) 연산자 사용 -> 해당 멤버 접근
	`thread.start(); // 점 연산자`

### 필드
- 클래스나 객체에 소속되는 변수(2.1.1절 확인)
- 필드 정의시의 타입 지정
- 필드 사용에서의 l-value, r-value 변수 정의시 타입 지정, 변수 사용과 동일

>[!note] 필드 변수와 로컬 변수
>클래스나 객체에서 멤버들이 공동으로 사용할 데이터는 필드 변수.
>메서드 자신만이 사용할 변수는 로컬 변수로 정의

- 필드 변수는 로컬 변수와 달리, 초기화 하지 않으면 자동으로 '0'으로 초기화
	- 정수 : 0
	- 부동 소숫점수 : 0.0
	- boolean : false
	- 참조변수 : null
- 다른 클래스나 객체가 사용하는 데이터의 경우 프로퍼티 화 함
	- 데이터를 저장하는 필드 = private 영역에 배치
	- 값을 읽고 저장하는 게터메서드와 세터 메서드 = public 영역에 배치
	- -> 객체 캡슐화를 달성

### 메서드
- 생성자 메서드 
- 게터메서드
- 세터 메서드
- 일반 메서드

- 생성자 메서드
	- Constructor(생성자)
	- 객체가 생성될 때 객체 초기화에 필요한 일들을 수행하는 특별한 목적을 가진,
	  특별한 문법으로 정의되는 메서드
	- new 연산자로 객체 생성
		- 생성되는 객체의 초기화를 수행 할 생성자 메서드를 지정하면서 객체를 생성
		- 생성자 메서드의 이름 값은 클래스 이름값과 동일한 이름 사용
		- 생성자 메서드는 "객체 초기화" 라는 특별한 작업을 수행 -> 메서드의 리턴 타입 표기 X
	- 기본 생성자 : 매개변수가 없고 몸통은 비어있는 생성자
	- 클래스 타입 : 객체 생성을 위한 개발자 정의 타입
		- 모든 클래스 타입은 생성자 메서드를 1개 이상 가져야 하는데, 개발자가 정의하는 클래스 정의 코드에서 생성자 메서드가 정의되지 않으면 컴파일러가 번역 과정에서 기본 생성자를 그 클래스 타입에 추가하여 줌

- 게터 세터 메서드
	- 어떤 객체가 가진 데이터를 다른 객체가 사용하고자 할때에는 이를 캡슐화 하기 위해 그 데이터를 프로퍼티화 하는것이 좋다.
	- 프로퍼티
		- 필드 = 캡슐 내부에 숨김
		- 게터 / 세터 = 캡슐 바깥에 위치
		- 다른 객체들이 그 데이터를 사용하고 자 할 경우, 게터와 세터를 통해 그 객체의 데이터를 사용
		- 프로퍼티와 게터,세터 이름값은 특별한 관계를 가짐.
			- 게터메서드의 이름값은 프로퍼티의 이름값의 첫 글자를 대문자로 변경,
			  그 앞에 get을 붙여 메서드의 이름값으로 사용
			- 세터 메서드의 이름값은 프로퍼티의 이름값의 첫 글자를 대문자로 변경,
			  그 앞에 set붙음
	- 객체가 가진 데이터를 프로퍼티화 -> 데이터의 타입, 자료구조 등 변경에 대해 애플리케이션 변경이 그 객체로 한정
	- 프로퍼티 안할시 : 데이터를 객체 바깥에 직접 노출함 -> 이 객체를 사용하는 다른 모든 객체들도 함께 변경됨.
		- but 프로퍼티 사용시, 데이터 속성 변경에 따른 애플리케이션의 변경은 그 데이터를 다루고 있는 게터 메서드와 세터 메서드로만 제한됨.
	- *게터와 세터란? : 객체가 가진 데이터를 다른 객체가 사용하고자 할때 이러한 캡슐화를 수행하는 특별한 목적을 가진 , 특별한 형태로 정의되는 메서드*
	- 게터 : 매개변수 X, 필드 타입의 리턴 타입을 가지는 메서드.
		- 메서드 몸통은 해당 필드 값을 리턴
	- 세터 : 리턴 타입은 void, 매개변수는 필드 타입의 1개의 매개변수를 가지는 메서드
	- 메서드 몸통은 매개변수의 값을 객체의 해당 필드에 배정
		- 필드 생성 -> 게터 메서드와 세터 메서드의 생성은 이클립스의 해당 위저드를 사용하여 자동 생성 가능
	- 대부분의 데이터 객체(Value Object)들은 이러한 프로퍼티를 다루는 프로퍼티 컨테이너로 객체를 구현

- 일반 메서드 : 2.4절 봐라

### 오버로딩(Overloading)
- 자바는 이름값 관리에 대한 개발자의 부담을 줄여주기 위해 오버로딩 허용
	- 오버로딩 :  생성자 메서드와 일반 메서드 등은 동일 이름값을 가지는 여러 메서드들이 존재한는 것을 허용
	- 메서드 식별은 메서드 이름값과 메서드의 매개변수를 함께 사용 -> 메서드 식별

## 3.1 상속과 구현
- 클래스 정의시 상속받을 멤버들을 가진 클래스 타입과 생성되는 객체를 접근 
  -> 사용할 인터페이스 타입을 타입 정의의 머리 부분에서 지정, 정의

### 상속
- 예약어 extends를 사용 -> 상속 받을 1개의 클래스 지정
	- 상속 지정 : 상속받은 클래스의 멤버들에 대한 코드 재사용을 위해 수행

- 코드 재사용의 5단계
	1. 복사 & 붙이기 : 문장 혹은 문장 집단
	2. 메서드 호출 : 메서드
	3. 상속 : 클래스
	4. 디자인 패턴 : 문제 해결책
	5. 프레임 워크 : 애플리케이션 골격

- 클래스를 상속 받으면 상속 해준 클래스가 상속 받은 멤버까지 모두 포함
	- 그 클래스의 모든 멤버들을 현재의 클래스가 상속받게 됨.
- 클래스로 객체를 생성시...
	- 클래스가 정의되는 현재 위치애서만 그 클래스로 부터 객체를 생성하는 경우에는 별도의 .java 파일 사용
	- class 예약어 사용
	- extends 예약어 사용
	- 정의되는 클래스  이름값 지정 등
	- 같은 문법은 생략하면서 클래스 정의
	-  = 익명 자식 클래스 : 반드시 "new 연산자" 사용. 그 위치에서 객체 생성도 동시에 수행
	- 현재 클래스로 객체 생성 -> 모든 조상 클래스로 부터의 각 조상 객체들까지 함께 생성
		- 이때 조상 객체 들이 먼저 생성, 후손객체 이후에 생성
- this 예약어 : 현재 객체의 참조를 가리킴
	- () 문자 사용 -> 메서드 호출 수행 -> 현재 클래스의 생성자가 호출
- super 예약어 : 부모 객체의 참조를 가리킴
	- () 문자 사용 -> 메서드 호출을 수행 -> 부모 클래스의 생성자가 호출
	- new 연산자에 의한 호출이 아닌 생성자 호출시 내부에서만 호출 가능.
	- 생성자 메서드 몸통에서 첫번째 문장으로 사용하는것만 가능

### 구현
-  클래스 타입 : 객체 생성을 위한 개발자 정의 타입
	- but 생성된 객체에 접근할때도 사용 가능
	- 타입으로 부터 객체 생성 -> 클래스 타입으로도 객체 접근이 가능 
	  - but! 클래스가 정의 될때 특정 인터페이스가 반영되면서 정의되었다면 인터페이스 타입으로도 객체 접근 가능

- implements 예약어 : 클래스에 반영될 인터페이스를 지정하는것이 가능
	- 복수개의 인터페이스 지정이 가능
- 클래스 정의시 인터페이스를 지정했을때
	- 지정된 인터페이스의 모든 메서드(추상 메서드)들은 현재 클래스에서 반드시 재정의 해야함.
	- 1개의 메서드라도 재정의 안하면 그 클래스는 객체를 생성하지 못하는 추상 클래스가 됨
- 인터페이스가 반영된 클래스로 객체 생성시 new 연산자 사용 -> 그 위치에서 객체도 동시에 생성해야함(3.3 참조)

### 오버라이딩(Overriding)
- 조상 클래스의 메서드 or 인터페이스의 메서드를 현재 클래스에서 다시 정의하는 행위
- @Override 어노테이션을 사용 -> 재정의되는 메서드의 시그니처 검사를 통해 오버라이딩 확인을 컴파일러에게 요청하는 것을 권고

- 상속은 코드 재사용 목적.
	- 대부분 메서드 재정의 X
	- 굳이 함? : 상속받은 코드를 재사용 할 코드로 수정하는것이 주된 목적
- 그러나 구현은 객체 사용에 대해 다형성을 구현하는것이 목적 -> 인터페이스의 모든 메서드들을 무조건 재정의 해야 하고 객체 접근시의 참조 값에 대한 현재 객체 메서드가 동적 바인딩으로 수행되는 것이 주된 목적

## 3.1 패키지
- 물리적 : 폴더 사용
- 개념적 : 정의되는 개발 정의 타입의 이름값 공간을 확대하기 위해 사용하는 도구
- 클래스, 인터페이스 등의 타입 정의 할때 
	- class, interface 예약어 이후에 사용하는 타입의 이름값은 완전한 이름값 X.
	- 타입이 정의되는 패키지의 이름값이 더해진 이름값이 타입의 완전한 이름값.
- 타입 정의 -> 첫번째 문장 = package 예약어 사용하여 정의.
  => 소속되는 패키지 기술
- 타입 블록 내부에서 다른 타입의 이름값을 사용 -> 항상 패키지 이름값을 포함한 완전한 타입 이름값을 사용하는 것은 불편함 -> 패키지 이름 생략
	- .java 파일 머리 부분에 import 예약어로 처리하는것이 효율적
- 패키지 이름값이 생략된 클래스 이름값으로만 클래스를 사용하는것이 가능
- 

## 3.1 객체 생성과 객체 사용
- 객체형 프로그램의 진행 : new 연산자 사용 -> 객체 먼저 생성
- 생성된 객체에 접근 -> 멤버들을 사용 -> 생성된 객체에 접근 -> 멤버들을 사용
	- 메서드 멤버 호출 -> 객체를 동작
	- 객체는 자신에게 전달되는 메세지에 의해 해당 메서드가 수행
	- 생성된 객체 사이의 관계 설정 및 객체 동작도 자바 코드로 이를 수행
- 객체는 자신에게 전달되는 메세지에 의해 동작

# 3.2 인터페이스 타입
- 실체를 생성하는 타입은 아님(생성자 없음). 
- 사용 객체가 인터페이스가 반영된 클래스로 부터 생성된 대상 객체를 접근 -> 다향성 구현을  위해 대상 객체의 클래스 타입 대신 사용하는 개발자 정의 타입.
- 블록({})에서 기술

- 타입 정의 : 기본적으로 적절한 패키지와 별도의 .java 파일 사용
	- 그러나 내포 인터페이스 타입을 정의 -> 별도의 .java 파일 사용 X
	- -> 컴파일시 모든 인터페이스 들은 번역된 별도의 .class 파일 생성
- 자바에서 함수형 프로그램 구현 -> 함수적 인터페이스(Fucntional Interface)에 람다 사용

## 3.2 타입 정의
- 인터페이스 타입의 정의는 머리와 몸통으로 나뉨

### 머리
- 접근 제한자를 예약어 이전 위치에 사용, 타입 정의
	- public : 현재 정의되는 인터페이스 접근 제한 없이 사용 가능
	- (default) : 현재 정의되는 인터페이스는 동일 패키지에서만 사용하는 것이 가능
- extends 예약어를 인터페이스 이름값 이후 위치에서 사용 -> 타입 정의
	- extends : 상속 인터페이스를 지정, 다중 상속이 가능

### 몸통 
- 인터페이스 블록({})을 사용하여 다음과 같은 멤버를 정의
	- 멤버 접근 제한 역시 기본적으로 public 접근 제한자 사용하는것이 원칙

- 상수 필드
	- 인터페이스는 데이터를 저장할수 없기 때문에 인스턴스나 필드나 정적 필드 등은 가지지 못함.
	- public static final로 정의되는 상수 필드는 가질수 있음
	- -> public static final특성 = 생략 가능
	  +but! 컴파일러에 의해 자동 부여 ㅋㅋ
	- 상수명은 관례적으로 대문자로 표기
	- 반드시 배정(=) 연산자 사용 -> 초기값 부여
```java
public int MAX_VOLUME = 10;
public int MIN_VOILUME = 0;
```

- 추상 메서드
	- 메서드 몸통에 해당하는 메서드 블록({})이 없는 메서드
	- -> 인터페이스는 기본적으로 추상 메서드들의 집합으로 구성

>[!note] 함수적 인터페이스
> 추상 메서드 1개만을 갖는 인터페이스
> 람다 사용 -> 인터페이스 반영하는 클래스 생성과 객체 생성을 시스템이 자동으로 처리할수 있음

- 디폴트 메서드
	- 인터페이스에서 정의하지만 객체가 소유하는 메서드
	- 몸통에 있음
	- 인터페이스 확장을 위해 사용

>[!warning] 디폴트 메서드 정의시!!!!!!!!!!
> 디폴트 메서드를 정의할때 사용하는 예약어 default는 생략 할수 없는 예약어.
> 동일 패키지로 접근 제한을 수행할 떄 사용되는 default가 아님...

- 정적 메서드 
	- 인터페이스에서 정의하지만 클래스가 소유하는 메서드
	- 몸통에 있음
	- 인터페이스 확장을 위해 사용

## 3.2 다형성 구현
- 다형성(Polymorphism)
- 하나의 문장으로 그떄그때 서로 다른 기능을 처리할수 있는 능력
- 다형성 구현하는 방법
	- 객체 사이의 관계 중 의존 관계에서 사용 객체가 대상 객체의 메서드를 접근 할때 동적 바인딩을 사용
	- 메서드 호출과 수햄 메서드가 동적으로 연결되어야 하기 때문에
	  -> 사용 객체가 대상 객체의 클래스 타입으로 대상 객체를 직접 접근 하면 이를 실현 X.
	- 대상 객체의 조상 클래스 타입이나 대상 객체 클래스에 반영된 인터페이스 타입으로 대상 객체를 간접 접근해야 할 뿐만 아니라.
	  대상 객체도 공통 인터페이스나 공통 조상 클래스를 사용하지 않는 단순 클래스로 부터 생성되는 객체는 대상 객체가 될수 없음
	- 공통 인터페이스를 반영하는 클래스로 부터 or 공통 조상을 상속받는 클래스로 부터 생성되는 객체만이 대상 객체가 될수 있음

- 대상 객체의 조상 클래스 타입이나 인터페이스 타입으로 대상 객체의 메서드를 간접 호출
  ->  그 호출에 따른 수행되는 메서드는 이를 재정의하는 현재 객체의 메서드로 동적 바인딩
  ->  현재 객체의 메서드가 수행

- 정적 바인딩(static Binding)
	- 컴파일 시간(compile time)에 결정
	- 프로그램이 실행되도 변하지 않음
	- 오버로딩(Overloading)
	- private, final, static이 붙은 메서드
- 동적 바인딩(Dynamic Binding)
	- 실행 시간(Runtime)에 결정
	- 늦은 바인딩(Late Binding)이라고도 부름
	- 오버라이딩(Overriding)
	- java에서의 다형성, 상속이 가능한 이유

- 공통 조상 클래스를 상속받는 다른 클래스 타입의 객체 (혹은 공통 인터페이스를) 구현하는
	다른 클래스 타입의 객체 메서드를 호출 할때 사용 객체에서의 대상 객체 메서드를 호출하는 문장은 
	공통 조상 클래스 (혹은 공통 인터페이스의) 메서드 호출인 동일 문장을 사용하여 이를 호출 가능.

- 사용 객체에 다형성 구현
	- 조상 클래스 타입으로 대상 객체를 접근 or 인터페이스 타입으로 대상 객체를 접근 하는지의 문제
	  => 상속 구현의 서로 다른 목적을 살펴봐야함.
- 인터페이스는 다형성 구현을 위한 객체 사용법을 정의하는 타입으로 제안된 개발자 정의 타입
	- 조상 클래스 : 코드 재사용을 위해 상속을 위한 개발자 정의타입
- 인터페이스를 반영하는 객체의 현재 클래스는 인터페이스의 모든 추상 메서드를 의무적으로 모두 다 재정의하고 있지만, 조상 클래스를 상속받고 있는 객체의 현재 클래스는 대부분의 경우,
  조상 클래스의 모든 메서드를 모두 재정의하고 있지는 않음
- 사용 객체에서 대상 객체 메서드를 간접적으로 호출 할때에는 모든 메서드가 재정의되어 동적 바인딩 되는 인터페이스 타입을 사용하는것이 당연한 선택.

- 다형성 구현시 객체가 대상 객체의 메서드를 호출하려면 대상 객체의 참조값을 사용 객체가 가지고 있어야 함
	- 대상 객체를 갖는 방법 : 
		- 사용 객체에서 대상 객체를 직접 생성하여 그 참조값을 갖기
		- 사용 객체에게 누군가가 대상 객체의 참조값을 전달하기.
>[!warning] 주의해야할 사항
>사용 객체에게 대상 객체의 클래스 타입 참조값을 전달 -> 다형성을 구현할수 없음 -> 캐스팅된 인터페이스 타입의 참조 값을 전달

- 사용 객체 내부에서 대상 객체를 직접 생성 후 참조값 갖는 방법
	- 대상 객체 메서드를 간접적으로 호출하는 장점인 사용 객체에서의 다형성의 장점을 모두 없앤다
	- 대상 객체가 다른 타입의 객체로 바뀌면 사용 객체의 코드가 변경 되어야함
	- -> 다른 곳에서 대상 객체를 생성, 사용 객체에 참조값 전달
		- 개발자 코드로 처리시 코드 객체가 다른 타입으로 바뀔떄 마다 해당 개발자 코드가 변경
		  => 의미 반감
	- 개발자 코드로 처리하는 방법 대신 스프링을 사용(스프링 컨테이너의 도움을 받아야 달성 가능)
		- 컨테이너가 처리
	- 컨테이너에서 대상 객체를 생성-> 참조값을 사용 객체에 전달 주입(의존 검색 혹은 의존 주입 사용)
	- 사용 객체가 대상 객체의 참조값을 가지게 함


## 3.2 인터페이스 확장
- 인터페이스 정의에서 사용하는 default 예약어는 접근 제한자로서의 예약어가 아님.
	- 접근 제한자 default : 동일 패키지에서만 접근 가능을 표현하는 예약어
- *정의되는 메서드의 메서드 소속과 관련한 특별한 예약어*
- _그 메서드가 객체 소속임을 나타낼 때 사용하는 예약어로 생략할수 없음_

>원래 인터페이스는 기능에 대한 선언만 가능한데 Default Method로 가능해짐(자바 8이후)
>메서드 신언시 default를 명시하게 되면 인터페이스 내부에도 로직이 포함된 메서드 선언 가능

```java
Interface MyInterface{
	default void printHello(){
		System.out.println("Hello World");
	}
}
```

- 인터페이스
	- 객체 사용법을 위한 개발자 정의타입
	- 추상 메서드들의 집합으로 구성
	- 인터페이스의 모든 추상 메서드들에 대해 몸통이 있는 실체 메서드로 이를 재정의
	- 이때, 재정의되지 않는 메서드가 존재하면 그 클래스는 객체를 생성하는 실체 클래스가 될 수 없음
	- 기존의 인터페이스를 확장하기 위해 인터페이스에 추상 메서드를 추가
		- 기존의 이터페이스를 반영하고 있는 기존의 모든 클래스들이 실체 클래스로서의 오류 발생
		  -> 자바에서 디폴트 메서드와 정적 메서드를 이넡페이스 타입에 추가하여 해결

- 인터페이스의 추상 메서드에 대해서는 인터페이스를 반영하는 클래스는 
  반드시 그 추상 메서드를 재정의해야 하지만, 
  추상 메서드가 아닌 메서드들에 대해서는 그 클래스가 그 메서드들을 재정의할 의무가 없기 때문에 
  디폴트 메서드 혹은 정적 메서드를 사용
  -> 인터페이스에 메서드 추가를 가능하게 해줌

## 3.2 람다
- 자바는 함수형 프로그램이 아니어서 개발자가 메서드를 별도의 단위로 다루고 싶을 때에도 이를 클래스로 포장 -> 클래스로부터 객체 생성 -> 그 객체 참조를 사용 -> 해당 메서드 다룸

- 객체형 프로그램이 함수형 프로그램보다 모든 응용 부분에서 무조건 효율적일순 없음
	- 이벤트 헨들러를 UI 객체에 등록 or 보안 알고리즘을 구현 -> 효율
	  (어떤 메서드를 매개변수로 넘겨주면서 피호출 메서드를 호출하는 경우 함수 포인트가 아주 유용하게 사용됨)
- 람다는 객체형 언어지만 함수형 언어의 기능을 제공하는 도구임
	- 개발자는 람다를 사용 -> 메서드의 몸통만을 정의 -> 매개변수로 넘겨줌 -> 피호출 메서드를 호출
	- (메서드 몸통을 사용 -> 클래스 정의 -> 객체 생성 => JVM이 자동처리)

### 함수적 인터페이스와 타겟 타입
- 람다는 함수적 인터페이스가 정의 -> 함수적 인터페이스가 타겟 타입이 되었을때 람다로 다루면 클래스 정의와 객체의 생성을 자동으로 수행하는 프로그램 구성요소

- 함수적 인터페이스란?
	- 1개의 추상 메서드만을 가지는 인터페이스
	- 함수형 프로그램을 제작할때 필요한 인터페이스
- 타겟 타입이란?
	- 함수적 인터페이스를 구현한 클래스로 부터 생성된 객체의 참조값을 배정받거나
	  전달 받는 변수의 타입을 말함
	- 배정 연산자 왼쪽의 피연산자의 변수 타입
	- 실 매개변수가 함수적 인터페이스를 구현한 클래스로 부터 생성된 객체의 
	  참조값을 나타내는 표현식 일때의 
	  형식 매개변수의 타입 등
- 피연산자나 실 매개변수는 그 타겟 타입을 반영하는 클래스로 부터 생성된 객체의 참조값을 나타내는 객체이거나 객체의 참조 변수 이어야 함.

>[!note] 따라서...
>배정 연산자의 오른쪽 피연산자 or 실 매개변수를 구성하는 객체 생성에 참여한 클래스는 그 클래스의 골격이이미 결정되어 있음. 클래스 정의에 필요한 인터페이스가 타겟 타입에 의해 이미 결정되어 있기 때문에 그 인터페이스를 구현하는 클래스는 인터페이스에서 정의한 1개뿐인 추상 메서드의 몸통에 해당 하는 코드만 있으면 클래스를 완성 할수 있고 클래스로 부터 객체도 생성 할수 있을것.
- 람다란 이때 그 몸통의 코드를 표현하는 도구

### 람다 표현식
- 함수적 인터페이스 타입에 대해 인터페이스를 반영하는 클래스 타입을 정의할때 사용하는 표현식
- 함수적 인터페이스의 1개뿐인 추상 메서드를 실체 메서드(람다 메서드)로 만들면서 클래스 타입을 정의하는데 
	- 이때 사용될 형식 매개변수의 이름값과 함수 몸통에 사용될 문장들의 집합으로 구성되는 표현식
- 람다 표현식의 기본 문법
	- `(->)` 
	- 이 화살표의 중심으로, 왼쪽에는 형식 매개변수의 이름값들을 기술(형식 매개변수가 여러개인 경우 소괄호를 사용 -> 나열후 묶음)
	- 오른쪽은 실체 메서드의 몸통을 기술
	- 오른쪽에 기술하는 메서드의 몸통이 1개의 문장으로 이루어질 경우 중괄호 필요 X
```java
//화살표 왼쪽에는 람다 메서드를 호출하는 실 매개변수가 전달하는 정보를 받아들이는 메서드 몸통에서 사용할 형식 매개변수의 이름값을 정의

(a,b)->{
	if(a>=b) return a;
	else return b;
}
```

- 시스템이 실체 메서드를 완성할 떄에는 메서드의 머리는 이미 타겟 타입에서 정의하고 있으므로 이를 사용하고 메서드의 몸통은 람다 표현식에서 개발자가 기술 -> 실체 메서드 완성
- 람다란,,,,
	- 함수적 인터페이스 타겍 타입에 대해 실체 메서드 이면서 실체 클래스.
	- 객체 => 이로부터 생성되는 실체
	- 표현식이면서 그 식의 값은 생성된 객체의 참조값이 됨.
- 람다 실행 순서
	1. 람다 표현식 사용
	2. 람다 메서드
	3. 람다 클래스
	4. 람다 객체
	5. 식의 값이 배정 연산자 왼쪽 피연산자에 배정
	   or 형식 매개변수 방에 전달
- 메서드의 몸통이 다른 메서드를 호출하는 1개의 문장으로 구성될 경우 람다를 기본 사용X
	- : : 기호 사용

### 기본 API 함수적 인터페이스
- 람다를 사용하기 위해서는 사용하려는 함수적 인터페이스 타입이 사전에 정의되어 있어야 함.
- 자바의 기본 클래스 라이브러리(기본 API)
	- java.util
	- function
	- => 얘네를 통해서 디폴트 메서드, 정적 메서드가 포함된 5개의 그룹으로 분류되는 함수적 인터페이스들을 제공함
		- Consumer 그룹 : 매개값O 리턴값 X
		- Supplier그룹 : 매개값 X, 리턴 O
		- Function 그룹 : 매개값 O, 리턴값 O(주로 매개값을 리턴으로 매핑)
		- Operator 그룹 : 매개값 O, 리턴값 O(주로 매개값을 연산하여 결과 리턴)
		- Predicate 그룹 : 매개값 O, 리턴값 boolean, (매개값 조사 -> ture/false)리턴

- Consumer그룹 함수적 인터페이스
	- 관련 인터페이스와 추상 메서드

| 인터페이스 명              | 추상 메서드                         |
| -------------------- | ------------------------------ |
| Consumer<T>          | void accept(T t)               |
| BiConsumer<T, U>     | void accept(T t, U u)          |
| DoubleConsumer       | void accept(double value)      |
| IntConsumer          | void accept(int value)         |
| LongConsumer         | void accept(long value)        |
| ObjDoubleConsumer‹T› | void accept(T t, double value) |
| ObjIntConsumer<T>    | void accept(T t, int value)    |
| ObjLongConsumer<T>   | void accept(T t, long value)   |
- Supplier 그룹 함수적 인터페이스
	- 관련 인터페이스와 추상 메서드

| 인터페이스 명         | 추상 메서드               |
| --------------- | -------------------- |
| Supplier<1>     | T get()              |
| BooleanSupplier | boolean getAsBoolean |
| DoubleSupplier  | double getAsDouble() |
| IntSupplier     | int getAsint(        |
| LongSupplier    | long getAsLong()     |

- Fucntion 그룹 함수적 인터페이스
	- 관련 인터페이스와 추상 메서드

| 인터페이스 명                  | 추상 메서드                           |
| ------------------------ | -------------------------------- |
| Function<T, R>           | R apply(T t)                     |
| BiFunction<T, U, R>      | R apply(T t, U u)                |
| DoubleFunction< R>       | R apply(double value)            |
| IntFunction< R>          | R apply(int value)               |
| IntToDoubleFunction      | double applyAsDouble(int value)  |
| IntloLongFunction        | long applyAsLong(int value)      |
| LongToDoubleFunction     | double applyAsDouble(long value) |
| LongTolntFunction        | int applyAsint(long value)       |
| ToDoubleBiFunction<T, U> | double applyAsDouble(T t, U u)   |
| ToDoubleFunction<T >     | double applyAsDouble(T t)        |
| TolntBiFunction<T, U>    | int applyAsint(T t, U u)         |
| TolntFunction< T>        | int applyAsInt(T t)              |
| ToLongBiFunction<T, U>   | long applyAslong(T t, U u)       |
| ToLongFunction<T >       | long applyAslong(T t)            |

- Operator 그룹 함수적 인터페이스
	- 관련 인터페이스와 추상 메서드

|   |   |
|---|---|
|인터페이스 명|추상 메서드|
|BinaryOperator< T>|T apply(T t, T t)|
|UnaryOperator<T>|T apply(T t)|
|DoubleBinaryOperator|double applyAsDouble(double, double)|
|DoubleUnaryOperator|double applyAsDouble(double)|
|IntBinaryOperator|Int applyAsint(int, int)|
|IntUnaryOperator|Int applyAsInt(int)|
|LongBinayOperator|long applyAsLong(long, long)|
|LongUnaryOperator|long applyAsLong(long)|

- Predicate 그룹 함수적 인터페이스
	- 관련 인터페이스와 추상 메서드

| 인터페이스 명            | 추상 메서드                 |
| ------------------ | ---------------------- |
| Predicate < T>     | boolean test(T t)      |
| BiPredicate ‹T, U> | boolean test(T t, U u) |
| DoublePredicate    | boolean test(double)   |
| IntPredicate       | boolean test(int)      |
| LongPredicate      | boolean test(long)     |

### 메서드 참조
- 람다식을 사용할때 메서드 몸통 부분의 문장들이 다른 메서드를 참조하는 1개의 문장으로 구성될 경우, 화살표 왼쪽에서 메서드 몸통에서 사용할 형식 매개변수의 이름값을 정의할 필요 없음
	- 형식 매개변수의 타입 지정은 이미 타겟 타입에서 기술
	  -> 매개변수의 이름값은 람다 메서드를 호출하는 그 값을 메서드 몸통에서 기술하는 메서드 호출이 그 값을 그대로 사용 
	  -> 메서드 호출 수행만 하면 됨.
	- 형식 매개변수의 이름값 정의 생략 -> 람다 메서드의 몸통에서는 형식 매개변수 이름값을 사용 X
	  -> : : 문법 사용
```java
//기본 문법
(a, b) -> Math.max(a,b);

// 메서드 참조 문법
Math : : max
```

- 정적 메서드 참조
	- 람다 메서드 몸통이 정적 메서드 1개만을 호출하는 경우, 기본 문법으로 람다 표현식을 사용해도 좋지만, 메서드 참조 문법으로 람다 표현식 기술 가능.
`클래스 이름 : : 정적 메서드 이름`

- 객체 메서드 참조
	- 람다 메서드 몸통이 객체 메서드 1개만을 호출하는 경우 기본 문법으로 람다 표현식을 사용해도 좋지만, 메서드 참조 문법으로 람다 표현식을 기술해도 됨.
`객체 참조 변수 : : 객체 메서드 이름`

- 매개변수 객체 메서드 참조
	- 람다 메서드의 1번째 형식 매개변수 -> 람다 메서드 몸통에서 호출할 객체 메서드의 참조 변수
	- 두번째 형식 매개변수가 1번째 매개변수가 가리키는 객체 메서드를 호출 할 때 사용할 실 매개변수면,
	  같은 메서드 참조 문법으 람다 표현식 기술 가능
`클래스 이름 : : 객체 메서드 이름`

- 생성자 메서드 참조
	- 람다 메서드의 몸통이 아래와 같이 형식 매개변수를 사용한 해당 생성자메서드를 호출하여 객체를 생성하고 그 객체의 참조값을 리턴하는 람다 메서드에 대해서는 
```java
(a,b) -> {return new 생성자(a,b); }

//혹은
클래스 이름 : : new
```

# 3.3 내포타입
- 배열 타입을 제외한 모든 개발자 정의 타입들은 기본적으로 별도의 독립된 .java파일을 사용
- 타입의 세부 내용을 정의
- 타입의 이름값과 .java 파일의 파일 이름 값은 동일한 이름 사용
- 때로는 별도의 .java 사용 X
  => 다른 타입을 정의하는 타입 블록 내부에서 새로운 타입을 정의
  
- 내포타입(Nested Type)이란?
	- 타입 정의 내부에서 정의되는 타입
	- 내포타입의 종류
		- 익명 클래스(익명 자식 클래스와 익명 구현 클래스)
		- 람다 클래스
		- 중첩타입(중첩 클래스와 중첩 인터페이스)

## 3.3 익명 클래스와 람다 클래스
- 익명 클래스 : 클래스 이름값이 없는 클래스
	- class 예약어 사용과 클래스 이름값 지정을 수행하지 않으면서 클래스 정의
	- 람다 클래스는 익명 클래스이면서 람다 표현식에 의해 시스템이 자동으로 생성하는 클래스
- 그 자리에서만 사용되는 객체를 생성(그때그떄 사용되는 클래스)
	- 메서드 매개변수로 메서드를 전달 할때, 그 메서드를 소유하는 객체를 생성, 사용되는 클래스를 정의할때 주로 많이 사용하는 클래스 타입

### 익명 클래스
- 익명 클래스(Anonymous Class)
	- 익명 자식 클래스
	- 익명 구현 클래스
- 클래스를 정의하면서 동시에 그 클래스로 부터 객체 생성도 동시 진행
- 클래스 정의와 동시에 수행할 new 연산자를 함께 사용하면서 클래스를 정의

- 익명 자식 클래스의 경우 아래와 같이 
	- class 예약어 
	- extends 예약어
	- 자식 클래스 이름값 등 
	- 모두 생략한 채, new 연사자와 '부모 클래스 이름값()' 이후 위치에서 클래스 블록({ })을 사용
  -> 새롭게 정의 자식 클래스의 내용을 그 블록 내부에 기술 + 자식 클래스 정의 + 객체 생성

- 익명 구현 클래스의 경우 class, implements, 클래스 이름값 생략
- new 연산자와 인터페이스 이름값() 이후 위치에서 클래스 블록({ })을 사용하여 새롭게 정의하는 구현 클래스의 내용을 그 블록 내부에 기술 -> 구현 클래스를 정의하고 동시에 객체 생성

### 람다 클래스
- 타겟 타입인 함수적 인터페이스 타입에 대해 람다 표현식을 사용하면 시스템에 의해 자동으로 정의되는 타입
- 람다 표현식 -> 람다 메서드 완성
- 람다 메서드를 포함하는 람다 클래스 정의
	- 람다 클래스 : new 연산자 사용 없이 클래스로 부터 객체 생성도 자동으로 수행됨.
- 추상 메서드가 1개뿐인 함수적 인터페이스 -> 람다 표현식을 사용 -> 람다 메서드, 람다 클래스, 람다 겍채를 동시에 생성하는 람다 표현식을 사용한 람다 객체를 사용하는 것이 훨씬 효율적

### 중첩 타입
- 