- 클래스 타입
- 인터페이스 타입
- 내포타입
- 어노테이션 타입
- 제너릭 코드
- 기본 클래스

# 3.객체형 부품
- 절차지향 프로그래밍
- 객체 지향 프로그래밍

- 프로그램 드리븐 프로그램(Program Driven Program) : 프로그램 자체에서 코드 수행 흐름을 갖는 프로그램
	- 프로그램을 구성하는 코드 or 코드들의 순서가 수행 흐름을 결정
		- UI를 가지지 않은 프로그램 -> 프로그램 자신이 수행 흐름 주도 필요
		  (프로그램의 다음 어느 부분을 수행할것인지, 사용자로부터 입력을 받을건지..)
		- UI(User Interface, 사용자 인터페이스)
	- 코드들의 수행 순서 등이 의미가 크다 =  절차를 지향해야 한다.
	  (+ 코드 흐름도 사용 필요(Flow Chart))

## 3.0 절차 지향형 프로그래밍(Procedural Oriented Programming)과 객체 지향 프로그래밍(Object Oriented Programming)

### 절차 지향 프로그래밍
- 현실 세계의 도메인에 어떤 일들이 존재하는가를 찾고 그 일들이 어떤 절차로 진행되는가를 분석
  -> 그 절차대로 프로그램 코드를 구성하는 프로그램 제작 기술
-  주로 목적으로 하는 값을 계산, 연산
- 순차적인 처리가 중요
- 개발 하려는 것을 기능별로 묶어 "모듈화" 함.
- 하드웨어가 같은 기능을 중복으로 연산 X. 모듈 재활용
- 하드웨어의 처리량을 획기적으로 줄여줌
	- 단점
		- UI가 존재하지 않아 사용하기에 불편 
		- 프로그램을 구성하는 코드들 사이의 코드 연결 강도가 높아, 프로그램의 수정과 변경이 어렵다.
	- 그래도 쓰는 이유
		- 프로그래밍 언어만 이해하면 프로그램 제작 가능
		- 언어 학습 과정에서 예제 코듣 등을 다룰때 주로 사용하는 프로그램 형태이기 때문

- UI를 사용하는 프로그램은 UI가 프로그램의 수행 흐름을 주도
- UI를 통해 전달되는 사용자의 요청이 프로그램의 다음 어느 부분을 수행 할건지 결정
- 이벤트 드리븐 프로그램(Event Driven Program)
	- UI를 통해 전달되는 사용자 요청(이벤트가 프로그램의 수행 흐름 주도)을 말함.
	- 객체에 전달되는 메세지의 의해 객체가 동작(=객체형 프로그램 수행 동작 방식)
	- 객체 지향적으로 제작

###  객체지향 프로그래밍
- 현실 세계 실 객체 -> 프로그램 세계의 객체들로 묘사
- 현실 세계에서 발생하는 사건들은 프로그램 세계의 메세지들로 구현
  -> 프로그램의 동작이 현실 세계의 움직임과 동일하게 수행 되도록 함
- *한마디로!* *"현실세계의 것을 프로그램에 그대로 구현하여 수행되는 프로그램 제작 기술"*
- 자바 언어
	- 컴파일러 언어
		- 컴파일러 : 객체형 프로그램을 제작할때 필요한 여러가지 기능을 제공하는것.
	- 객체 생성 + 객체 사이의 관계 설정 및 동작 -> 표현 가능

## 3.0 객체 구현 주요 기술
- 현실세계의  실객체를 그대로 표현 -> 현실세계의 복잡함을 좀 더 효율적으로 표현 하려한다
	- 클래스화
		- 동적 속성(객체의 동작)이 동일하거나 유사한 객체들은 하나의 그룹인 클래스로 집단화
		  -> 한번만  표현 가능
		- 객체형 컴파일러 언어(ex_JAVA) -> 집단화되지 않은 객체(=집단에 소속되는 객체가 1개뿐)에 대해 클래스 사용
		- => 실세계의 모든 객체들을 클래스로 표현
		  프로그램 세계에서 동작하는 모든SW 객체 들은 이러한 클래스로 부터 객체를 생성하여 동작
		- 객체 지향 분석의 개념
			1. 시스템
			2. 객체 추출
			3. 그룹화(클래스 생성)
			4. 관계
	- 상속
		- 클래스를 구현 할때 공통되는 부분이 있다면.......
			- 각 클래스에서 반복적으로 중복 코딩 하지 않는다.
			- 부모 클래스를 이용하여 한번만 묘사한다.
			- 자식 클래스는 상속을 이용한 코드 재사용 -> 클래스의 중복을 줄임
		- 자바에서 클래스를 정의 할때 특정 클래스를 상속하지 않으면 컴파일러가 Object 클래스를 강제 상속 시킴
		- => 자바 Object 클래스는 최상위 조상 클래스가 됨.
		  자바의 모든 클래스는 Object 클래스를 직간접 상속받음
		- *한마디로! "부모 클래스 = 틀 잡아주는거 -> 자식 클래스 = 틀에서 나온것(but 내용물은 다름)"*
	- 추상화
		- 현실 세계의 실 객체들이 가지는 특징, 기능 중 답을 구하는데 관련되지 않거나 관련이 적은 부분은 생략 or 축소 표현
		- 관련 있으면, 요약하여 클래스에 기술
		- => 추상화를 위해 자바 언어가 제공하는 문법적인 요소 존재 X
		  개발자가 에플리케이션을 설계할때 이를 고려, 클래스에 반영 해야함.
	- 캡슐화
		- 객체 표현시 객체 자신의 내용은 보호 + 다른 객체와의 불필요한 관게를 줄이기 위함.
		- 다른 객체와 관계되지 않는 부분들은 캡슐 내부에 숨김
		- 데이터 + 메서드 -> 얘네는 세트임
		- 다른 객체와 관련될 경우
			- 그래도 캡슐 사용. 게테, 세터 메서드를 캡슐 외부에 들어냄
			- 접근 제한자 : 객체와 맴버의 캡슐 두께를 조절.
	- 다형성 
		- 객체 사이의 관계가 의존 관계일때 -> 사용 객체가 대상 객체의 메서드를 접근 할때 객체를 생성한 클래스 타입으로 직접 접근 X
		- 인터페이스 타입 혹은 조상 클래스 타입 등 사용 -> 간접적으로 접근
		- 동일 문장으로 기능을 수행 할수 있는 코드 제작 가능
		- -> 자바의 경우 : 인터페이스 타입이라는 개발자 정의 타입 제공.
			- 상속 받았거나 반영될 타입의 메서드를 재정의  할수 있는 기능 등 제공
			- 컨테이너가 제공하는 의존 주입기능등을 복합적으로 사용 -> 애플리케이션을 변경 -> 개발코드 변경 X, 컨테이너의 변경만으로 애플리케이션 변경 수행 가능
	- 관점 분리
		- 핵심 기능과 보조 기능을 서로 다른 객체에 분리 후 제작.
		- 핵심 기능 객체 수행시 프록시 등을 동원 -> 객체를 통합, 수행
		- 핵심 관점 사항과 관련 -> 응집력 높은 객체 개발을 가능하게 함.
		- 보조 기능이 여러 핵심 기능 객체에서 공통으로 사용될때 보조 기능의 중복 코딩 방지.
		- -> 자바 언어가 제공하는 기능은 없음. 관련 사항들은 스프링 컨테이너 등을 사용하여 구현
		  
		- AOP 관점 지향 프로그래밍(Aspect-Oriented Programming)
			- 프로그래밍 영역이 수행 프로그램 컴파일러 방법을 결정하는 프로그래밍 방법

## 3.0 객체 관계
- 객체형 프로그램 : 클래스로부터 객체 생성 -> 생성되는 객체는 다른 객체들과 관계 형성
  -> 관계된 각 객체들의 동작 과정으로 애플리케이션 수행 진행
- 컨테이너를 사용하는 스프링 애플리케이션, 표준 프레임 워크 애플리케이션 등은 이러한 객체 생성, 객체 사이의 관계 설정, 관계된 객체들의 작동 등 컨테이너가 이를 수행하도록 함.
- 쓰레기 객체 : 애플리케이션이 실행되는 과정에서 다른 객체와 관계를 맺지 못하는 객체들 
	- 쓰레기 수집기(Garbage Collector) : 쓰레기 객체 회수함.
- 상속 관계
	- 클래스 상속에 의해 맺어지는 객체 사이의 관계
	- 클래스로부터 객체를 생성 
	  -> 현재 클래스로부터의 해당 객체 생성 + 상속 받는 모든 조상 클래스들 ~ 조상 객체들 까지 함께 생성
	- 객체 사이의 상속 관계 맺음
- 포함 관계
	- 애플리 케이션을 구성하는 큰 부품 객체 + 작은 부품 객체들 사이의 관계
	- 큰 부품 객체 : 필드에 작은 부품 객체들의 참조값을 저장하는 형태
	- 부품 객체들과의 관계 구현
- 의존 관계
	- 애플리케이션이 실행되는 과정에서 객체의 기능을 다른 객체에 의존하는 관계(지가 수행 안함)
	- 상속 관계와 포함 관계는 객체가 생성되는 과정에서 객체 사이에 맺어지는 관계
	- 객체 관계
		- 객체를 구성할때 하나의 객체를 여러 개의 클래스로 분리 후 구현
		  -> 이를 연결
	- but 의존 관계!
		- 애플리케이션 진행 과정에서 생성된 객체가 동작 할때 사용 객체가 대상 객체의 메서드를 호출
		- 사용 객체 자신이 수행햐야 할 일들을 대상 객체에게 이를 위임.
		- 사용 객체가 대상 객체의 메서드를 호출 하려면 사용 객체가 자신의 필드에 대상 객체의 참조 값을 가지고 있으면서 이를 사용 -> 객체에 먼저 접근 후 그 객체의 메서드를 호출

## 3.0 개발자 정의 타입
- 자바 애플리 케이션에서 객체를 생성 할때 클래스타입이라는 개발자 정의 타입을 사용 -> 객체 생성
- 생성된 객체를 사용 -> 객체를 생성할때 사용된 클래스 타입에 반영된 인터페이스 타입이라는 개발자 정의 타입 사용하여 객체에 접근
- 애플리케이션의 다른 곳에서 제공되는 서비스를 사용하려 할때
	- 어노테이션 타입(개발자 정의 타입)을 사용
- 개발자 정의타입은 기본적으로 적절한 패키지 + 별도의 .java 파일 사용 -> 타입 정의 
	- 이를 컴파일러로 번역 -> 각 타입별로 별도의 .class 파일이 생성

- 클래스 타입
	- 객체를 생성할때 쓰는 개발자 정의 타입
	- 객체를 생성 -> new 연산자 사용
	- 그 클래스 타입의 적절한 생성자 메서드를 호출 -> 객체 생성
	- 클래스 별로 생성자 메서드는 반드시 존재
	- 클래스 타입에 생성자 메서드가 존재 X : 컴파일러가 번역 과정에서 기본 생성자를 만들어 넣음.
		- 기본 생성자 : 형식 매개변수도 없고 내용이 없는 몸통으로 구성되는 생성자
- 인터페이스 타입
	- 객체 사용법을 정의하는 개발자 정의 타입
	- 인터페이스 타입을 반영하는 클래스로 부터 객체를 생성 -> 클래스 타입으로도 그 객체를 접근 가능
	  but 클래스 타입에 반영된 인터페이스 타입으로도 객체에 접근 가능
	- 인터페이스 접근시 객체지향의 다형성 구현 가능
	- 실체를 생성하는 타입이 아님. -> 생성자 메서드 존재 X.
		- 일반 메서드들도 실행을 목적으로 하지 않음
		- 메서드의 몸통이 없는 추상 메서드들로 전체 타입이 구성
- 어노테이션 타입
	- 프로젝트 다른 곳으로 서비스 제공 
	  -> 서비스 사용법을 정의하는 어노테이션 타입도 함께 정의해서 제공 해야함
	- 서비스를 제공 받는 프로젝트는 제공되는 어노테이션을 사용하여 제공 서비스 사용

# 3.1 클래스 타입
- 타입 정의 : 적절한 패키지 + 별도의 .java 파일 사용하여 수행
- but! 중첩 클래스(멤버 클래스와 로컬 클래스), 익명 클래스(익명 자식 클래스와 익명 구현 클래스), 람다 클래스 등의 내포 타입의 클래스 타입에 대한 정의는 별도의 .java 파일을 사용 하지 않고 타입 정의
- 하나의 .java 파일에 내포 타입이 아닌 여러개의 타입 정의시
	- .java 파일의 이름값과 타입의 접근 제한이 public 타입인 이름값은 동일한 이름값을 사용
	- 하나의 .java. 파일에는 public 타입이 1개만 존재함.
- 한편 .java 파일 컴파일 -> 각 타입별로 별도의 .class 파일 생성
- 기본 클래스, 중첩 클래스 등의 클래스 타입 정의시 class 예약어 사용과 클래스 이름값을 지정하면서 클래스를 정의
	- but , 익명 클래스와 람다 클래스 등은 class 예약어 사용과 클래스 이름값을 지정하지 않고 클래스타입을 정의

## 3.1 클래스 타입 정의
- 기본 형식 : 머리 + 몸통
	- 머리 : 타입의 전체적인 내용 
	- 몸통 : 타입의 구체적인 세부 내용
- 클래스 멤버들에 대한 정의 : 클래스의 멤버 + 클래스에서 생성되는 객체의 멤버를 해당 클래스 내부에 동시에 기술

### 머리
- class 예약어 사용 
- 클래스 이름값 지정
- 접근 제한자(public, default...)
- 예약어(abstract, final)들을 class 예약어 이전 위치에서 사용하면서 클래스를 정의
  
- 클래스 접근 제한자
	- public : 현재 정의 되는 클래스는 접근 제한 없이 사용하는 것이 가능
	- default : 현재 정의 되는 클래스는 동일 패키지에서만 사용하는 것이 가능.
	  접근 제한자 사용 안할시, default로 동작
- abstract : 객체를 생성할수 없는 추상 클래스를 정의
- final : 상속을 수행 할수 없는 최종 클래스 정의

- 또한 머리 부분의 클래스 이름값 이후 위치 -> extends 예약어를 사용 -> 상속 받을 클래스 지정 or implements 등의 예약어 들을 사용
	- extends : 상속 받을 클래스 지정, 다중 클래스 상속 불가능
	- implements : 객체 접근에 사용될 인터페이스 지정, 다중 인터페이스 지정 가능

### 몸통
- 클래스와 객체를 구성하는 각 요소들은 클래스 블록({}) 내부에서 다음과 같은 멤버 사용
	- 정적 요소(속성) : 필드 멤버로 기술
	- 동적 요소(동작) : 메서드 멤버로 기술
- 멤버가 클래스에 소속 or 객체에 소속 여부
	- 클래스 소속 멤버 : static 멤버로 기술
	- 객체 소속 멤버 : 비 static 멤버로 기술
- 메서드 멤버의 종류
	- 생성자 메서드 : 객체를 생성할때 호출되는 메서드
	- 게터 메서드 + 세터 메서드 : 캡슐화를 구현 할때 사용되는 메서드
	- 일반 메서드 : 객체나 클래스의 동작을 기술하는 메서드

## 3.1 멤버 정의
- 일반적인 속성 이외에 클래스에 소속되는 각 멤버들에 대한 속성에 대한 예약어 사용(각 멤버의 세부적인 속성들을 기술하는것이 가능)
	- 접근 제한
	- abstract 여부
		- abstract 속성(=abstract 예약어 사용시) : 메서드에 대해 사용하는 속성, 몸통이 없는 추상 메서드
	- final 여부
		- final 속성(=final 예약어 사용시)
		- final 필드 : 값을 한번 할당하면 그 값을 수정할수 없는 필드
		- final 메서드 : 후손 클래스에서 재정의를 할수 없는 메서드
- 멤버 접근 제한
	1. public : 모든 위치에서 접근 가능한 멤버
	2. protected : 동일 패키지에 소속되지 않더라도 후손에서는 접근 가능한 멤버
	3. (default) : 동일 패키지에서만 접근 가능, 멤버에 대해 접근 제한을 기술하지 않으면 default 접근 제한 적용
	4. private : 클래스 혹은 객체 자신만이 접근 가능한 멤버
- 클래스나 객체 외부에서 멤버를 접근 할때..
	- static 멤버 -> 클래스 이름값 사용
	- 비 static 멤버 -> 객체 참조 변수 사용
- 해당 클래스나 객체에 먼저 접근 -> 점(.) 연산자 사용 -> 해당 멤버 접근
	`thread.start(); // 점 연산자`

### 필드
- 클래스나 객체에 소속되는 변수(2.1.1절 확인)
- 필드 정의시의 타입 지정
- 필드 사용에서의 l-value, r-value 변수 정의시 타입 지정, 변수 사용과 동일

>[!note] 필드 변수와 로컬 변수
>클래스나 객체에서 멤버들이 공동으로 사용할 데이터는 필드 변수.
>메서드 자신만이 사용할 변수는 로컬 변수로 정의

- 필드 변수는 로컬 변수와 달리, 초기화 하지 않으면 자동으로 '0'으로 초기화
	- 정수 : 0
	- 부동 소숫점수 : 0.0
	- boolean : false
	- 참조변수 : null
- 다른 클래스나 객체가 사용하는 데이터의 경우 프로퍼티 화 함
	- 데이터를 저장하는 필드 = private 영역에 배치
	- 값을 읽고 저장하는 게터메서드와 세터 메서드 = public 영역에 배치
	- -> 객체 캡슐화를 달성

### 메서드
- 생성자 메서드 
- 게터메서드
- 세터 메서드
- 일반 메서드

- 생성자 메서드
	- Constructor(생성자)
	- 객체가 생성될 때 객체 초기화에 필요한 일들을 수행하는 특별한 목적을 가진,
	  특별한 문법으로 정의되는 메서드
	- new 연산자로 객체 생성
		- 생성되는 객체의 초기화를 수행 할 생성자 메서드를 지정하면서 객체를 생성
		- 생성자 메서드의 이름 값은 클래스 이름값과 동일한 이름 사용
		- 생성자 메서드는 "객체 초기화" 라는 특별한 작업을 수행 -> 메서드의 리턴 타입 표기 X
	- 기본 생성자 : 매개변수가 없고 몸통은 비어있는 생성자
	- 클래스 타입 : 객체 생성을 위한 개발자 정의 타입
		- 모든 클래스 타입은 생성자 메서드를 1개 이상 가져야 하는데, 개발자가 정의하는 클래스 정의 코드에서 생성자 메서드가 정의되지 않으면 컴파일러가 번역 과정에서 기본 생성자를 그 클래스 타입에 추가하여 줌

- 게터 세터 메서드
	- 어떤 객체가 가진 데이터를 다른 객체가 사용하고자 할때에는 이를 캡슐화 하기 위해 그 데이터를 프로퍼티화 하는것이 좋다.
	- 프로퍼티
		- 필드 = 캡슐 내부에 숨김
		- 게터 / 세터 = 캡슐 바깥에 위치
		- 다른 객체들이 그 데이터를 사용하고 자 할 경우, 게터와 세터를 통해 그 객체의 데이터를 사용
		- 프로퍼티와 게터,세터 이름값은 특별한 관계를 가짐.
			- 게터메서드의 이름값은 프로퍼티의 이름값의 첫 글자를 대문자로 변경,
			  그 앞에 get을 붙여 메서드의 이름값으로 사용
			- 세터 메서드의 이름값은 프로퍼티의 이름값의 첫 글자를 대문자로 변경,
			  그 앞에 set붙음
	- 객체가 가진 데이터를 프로퍼티화 -> 데이터의 타입, 자료구조 등 변경에 대해 애플리케이션 변경이 그 객체로 한정
	- 프로퍼티 안할시 : 데이터를 객체 바깥에 직접 노출함 -> 이 객체를 사용하는 다른 모든 객체들도 함께 변경됨.
		- but 프로퍼티 사용시, 데이터 속성 변경에 따른 애플리케이션의 변경은 그 데이터를 다루고 있는 게터 메서드와 세터 메서드로만 제한됨.
	- *게터와 세터란? : 객체가 가진 데이터를 다른 객체가 사용하고자 할때 이러한 캡슐화를 수행하는 특별한 목적을 가진 , 특별한 형태로 정의되는 메서드*
	- 게터 : 매개변수 X, 필드 타입의 리턴 타입을 가지는 메서드.
		- 메서드 몸통은 해당 필드 값을 리턴
	- 세터 : 리턴 타입은 void, 매개변수는 필드 타입의 1개의 매개변수를 가지는 메서드
	- 메서드 몸통은 매개변수의 값을 객체의 해당 필드에 배정
		- 필드 생성 -> 게터 메서드와 세터 메서드의 생성은 이클립스의 해당 위저드를 사용하여 자동 생성 가능
	- 대부분의 데이터 객체(Value Object)들은 이러한 프로퍼티를 다루는 프로퍼티 컨테이너로 객체를 구현

- 일반 메서드 : 2.4절 봐라

### 오버로딩(Overloading)
- 자바는 이름값 관리에 대한 개발자의 부담을 줄여주기 위해 오버로딩 허용
	- 오버로딩 :  생성자 메서드와 일반 메서드 등은 동일 이름값을 가지는 여러 메서드들이 존재한는 것을 허용
	- 메서드 식별은 메서드 이름값과 메서드의 매개변수를 함께 사용 -> 메서드 식별

## 3.1 상속과 구현
- 클래스 정의시 상속받을 멤버들을 가진 클래스 타입과 생성되는 객체를 접근 
  -> 사용할 인터페이스 타입을 타입 정의의 머리 부분에서 지정, 정의

### 상속
- 예약어 extends를 사용 -> 상속 받을 1개의 클래스 지정
	- 상속 지정 : 상속받은 클래스의 멤버들에 대한 코드 재사용을 위해 수행

- 코드 재사용의 5단계
	1. 복사 & 붙이기 : 문장 혹은 문장 집단
	2. 메서드 호출 : 메서드
	3. 상속 : 클래스
	4. 디자인 패턴 : 문제 해결책
	5. 프레임 워크 : 애플리케이션 골격

- 클래스를 상속 받으면 상속 해준 클래스가 상속 받은 멤버까지 모두 포함
	- 그 클래스의 모든 멤버들을 현재의 클래스가 상속받게 됨.
- 클래스로 객체를 생성시...
	- 클래스가 정의되는 현재 위치애서만 그 클래스로 부터 객체를 생성하는 경우에는 별도의 .java 파일 사용
	- class 예약어 사용
	- extends 예약어 사용
	- 정의되는 클래스  이름값 지정 등
	- 같은 문법은 생략하면서 클래스 정의
	-  = 익명 자식 클래스 : 반드시 "new 연산자" 사용. 그 위치에서 객체 생성도 동시에 수행
	- 현재 클래스로 객체 생성 -> 모든 조상 클래스로 부터의 각 조상 객체들까지 함께 생성
		- 이때 조상 객체 들이 먼저 생성, 후손객체 이후에 생성
- this 예약어 : 현재 객체의 참조를 가리킴
	- () 문자 사용 -> 메서드 호출 수행 -> 현재 클래스의 생성자가 호출
- super 예약어 : 부모 객체의 참조를 가리킴
	- () 문자 사용 -> 메서드 호출을 수행 -> 부모 클래스의 생성자가 호출
	- new 연산자에 의한 호출이 아닌 생성자 호출시 내부에서만 호출 가능.
	- 생성자 메서드 몸통에서 첫번째 문장으로 사용하는것만 가능

### 구현
-  클래스 타입 : 객체 생성을 위한 개발자 정의 타입
	- but 생성된 객체에 접근할때도 사용 가능
	- 타입으로 부터 객체 생성 -> 클래스 타입으로도 객체 접근이 가능 
	  - but! 클래스가 정의 될때 특정 인터페이스가 반영되면서 정의되었다면 인터페이스 타입으로도 객체 접근 가능

- implements 예약어 : 클래스에 반영될 인터페이스를 지정하는것이 가능
	- 복수개의 인터페이스 지정이 가능
- 클래스 정의시 인터페이스를 지정했을때
	- 지정된 인터페이스의 모든 메서드(추상 메서드)들은 현재 클래스에서 반드시 재정의 해야함.
	- 1개의 메서드라도 재정의 안하면 그 클래스는 객체를 생성하지 못하는 추상 클래스가 됨
- 인터페이스가 반영된 클래스로 객체 생성시 new 연산자 사용 -> 그 위치에서 객체도 동시에 생성해야함(3.3 참조)

### 오버라이딩(Overriding)
- 조상 클래스의 메서드 or 인터페이스의 메서드를 현재 클래스에서 다시 정의하는 행위
- @Override 어노테이션을 사용 -> 재정의되는 메서드의 시그니처 검사를 통해 오버라이딩 확인을 컴파일러에게 요청하는 것을 권고

- 상속은 코드 재사용 목적.
	- 대부분 메서드 재정의 X
	- 굳이 함? : 상속받은 코드를 재사용 할 코드로 수정하는것이 주된 목적
- 그러나 구현은 객체 사용에 대해 다형성을 구현하는것이 목적 -> 인터페이스의 모든 메서드들을 무조건 재정의 해야 하고 객체 접근시의 참조 값에 대한 현재 객체 메서드가 동적 바인딩으로 수행되는 것이 주된 목적

## 3.1 패키지
- 물리적 : 폴더 사용
- 개념적 : 정의되는 개발 정의 타입의 이름값 공간을 확대하기 위해 사용하는 도구
- 클래스, 인터페이스 등의 타입 정의 할때 
	- class, interface 예약어 이후에 사용하는 타입의 이름값은 완전한 이름값 X.
	- 타입이 정의되는 패키지의 이름값이 더해진 이름값이 타입의 완전한 이름값.
- 타입 정의 -> 첫번째 문장 = package 예약어 사용하여 정의.
  => 소속되는 패키지 기술
- 타입 블록 내부에서 다른 타입의 이름값을 사용 -> 항상 패키지 이름값을 포함한 완전한 타입 이름값을 사용하는 것은 불편함 -> 패키지 이름 생략
	- 