- 클래스 타입
- 인터페이스 타입
- 내포타입
- 어노테이션 타입
- 제너릭 코드
- 기본 클래스

# 3.객체형 부품
- 절차지향 프로그래밍
- 객체 지향 프로그래밍

- 프로그램 드리븐 프로그램(Program Driven Program) : 프로그램 자체에서 코드 수행 흐름을 갖는 프로그램
	- 프로그램을 구성하는 코드 or 코드들의 순서가 수행 흐름을 결정
		- UI를 가지지 않은 프로그램 -> 프로그램 자신이 수행 흐름 주도 필요
		  (프로그램의 다음 어느 부분을 수행할것인지, 사용자로부터 입력을 받을건지..)
		- UI(User Interface, 사용자 인터페이스)
	- 코드들의 수행 순서 등이 의미가 크다 =  절차를 지향해야 한다.
	  (+ 코드 흐름도 사용 필요(Flow Chart))

## 3.0 절차 지향형 프로그래밍(Procedural Oriented Programming)과 객체 지향 프로그래밍(Object Oriented Programming)

### 절차 지향 프로그래밍
- 현실 세계의 도메인에 어떤 일들이 존재하는가를 찾고 그 일들이 어떤 절차로 진행되는가를 분석
  -> 그 절차대로 프로그램 코드를 구성하는 프로그램 제작 기술
-  주로 목적으로 하는 값을 계산, 연산
- 순차적인 처리가 중요
- 개발 하려는 것을 기능별로 묶어 "모듈화" 함.
- 하드웨어가 같은 기능을 중복으로 연산 X. 모듈 재활용
- 하드웨어의 처리량을 획기적으로 줄여줌
	- 단점
		- UI가 존재하지 않아 사용하기에 불편 
		- 프로그램을 구성하는 코드들 사이의 코드 연결 강도가 높아, 프로그램의 수정과 변경이 어렵다.
	- 그래도 쓰는 이유
		- 프로그래밍 언어만 이해하면 프로그램 제작 가능
		- 언어 학습 과정에서 예제 코듣 등을 다룰때 주로 사용하는 프로그램 형태이기 때문

- UI를 사용하는 프로그램은 UI가 프로그램의 수행 흐름을 주도
- UI를 통해 전달되는 사용자의 요청이 프로그램의 다음 어느 부분을 수행 할건지 결정
- 이벤트 드리븐 프로그램(Event Driven Program)
	- UI를 통해 전달되는 사용자 요청(이벤트가 프로그램의 수행 흐름 주도)을 말함.
	- 객체에 전달되는 메세지의 의해 객체가 동작(=객체형 프로그램 수행 동작 방식)
	- 객체 지향적으로 제작

###  객체지향 프로그래밍
- 현실 세계 실 객체 -> 프로그램 세계의 객체들로 묘사
- 현실 세계에서 발생하는 사건들은 프로그램 세계의 메세지들로 구현
  -> 프로그램의 동작이 현실 세계의 움직임과 동일하게 수행 되도록 함
- *한마디로!* *"현실세계의 것을 프로그램에 그대로 구현하여 수행되는 프로그램 제작 기술"*
- 자바 언어
	- 컴파일러 언어
		- 컴파일러 : 객체형 프로그램을 제작할때 필요한 여러가지 기능을 제공하는것.
	- 객체 생성 + 객체 사이의 관계 설정 및 동작 -> 표현 가능

## 3.0 객체 구현 주요 기술
- 현실세계의  실객체를 그대로 표현 -> 현실세계의 복잡함을 좀 더 효율적으로 표현 하려한다
	- 클래스화
		- 동적 속성(객체의 동작)이 동일하거나 유사한 객체들은 하나의 그룹인 클래스로 집단화
		  -> 한번만  표현 가능
		- 객체형 컴파일러 언어(ex_JAVA) -> 집단화되지 않은 객체(=집단에 소속되는 객체가 1개뿐)에 대해 클래스 사용
		- => 실세계의 모든 객체들을 클래스로 표현
		  프로그램 세계에서 동작하는 모든SW 객체 들은 이러한 클래스로 부터 객체를 생성하여 동작
		- 객체 지향 분석의 개념
			1. 시스템
			2. 객체 추출
			3. 그룹화(클래스 생성)
			4. 관계
	- 상속
		- 클래스를 구현 할때 공통되는 부분이 있다면.......
			- 각 클래스에서 반복적으로 중복 코딩 하지 않는다.
			- 부모 클래스를 이용하여 한번만 묘사한다.
			- 자식 클래스는 상속을 이용한 코드 재사용 -> 클래스의 중복을 줄임
		- 자바에서 클래스를 정의 할때 특정 클래스를 상속하지 않으면 컴파일러가 Object 클래스를 강제 상속 시킴
		- => 자바 Object 클래스는 최상위 조상 클래스가 됨.
		  자바의 모든 클래스는 Object 클래스를 직간접 상속받음
		- *한마디로! "부모 클래스 = 틀 잡아주는거 -> 자식 클래스 = 틀에서 나온것(but 내용물은 다름)"*
	- 추상화
		- 현실 세계의 실 객체들이 가지는 특징, 기능 중 답을 구하는데 관련되지 않거나 관련이 적은 부분은 생략 or 축소 표현
		- 관련 있으면, 요약하여 클래스에 기술
		- => 추상화를 위해 자바 언어가 제공하는 문법적인 요소 존재 X
		  개발자가 에플리케이션을 설계할때 이를 고려, 클래스에 반영 해야함.
	- 캡슐화
		- 객체 표현시 객체 자신의 내용은 보호 + 다른 객체와의 불필요한 관게를 줄이기 위함.
		- 다른 객체와 관계되지 않는 부분들은 캡슐 내부에 숨김
		- 데이터 + 메서드 -> 얘네는 세트임
		- 다른 객체와 관련될 경우
			- 그래도 캡슐 사용. 게테, 세터 메서드를 캡슐 외부에 들어냄
			- 접근 제한자 : 객체와 맴버의 캡슐 두께를 조절.
	- 다형성 
		- 객체 사이의 관계가 의존 관계일때 -> 사용 객체가 대상 객체의 메서드를 접근 할때 객체를 생성한 클래스 타입으로 직접 접근 X
		- 인터페이스 타입 혹은 조상 클래스 타입 등 사용 -> 간접적으로 접근
		- 동일 문장으로 기능을 수행 할수 있는 코드 제작 가능
		- -> 자바의 경우 : 인터페이스 타입이라는 개발자 정의 타입 제공.
			- 상속 받았거나 반영될 타입의 메서드를 재정의  할수 있는 기능 등 제공
			- 컨테이너가 제공하는 의존 주입기능등을 복합적으로 사용 -> 애플리케이션을 변경 -> 개발코드 변경 X, 컨테이너의 변경만으로 애플리케이션 변경 수행 가능
	- 관점 분리
		- 핵심 기능과 보조 기능을 서로 다른 객체에 분리 후 제작.
		- 핵심 기능 객체 수행시 프록시 등을 동원 -> 객체를 통합, 수행
		- 핵심 관점 사항과 관련 -> 응집력 높은 객체 개발을 가능하게 함.
		- 보조 기능이 여러 핵심 기능 객체에서 공통으로 사용될때 보조 기능의 중복 코딩 방지.
		- -> 자바 언어가 제공하는 기능은 없음. 관련 사항들은 스프링 컨테이너 등을 사용하여 구현
		  
		- AOP 관점 지향 프로그래밍(Aspect-Oriented Programming)
			- 프로그래밍 영역이 수행 프로그램 컴파일러 방법을 결정하는 프로그래밍 방법

## 3.0 객체 관계
- 객체형 프로그램 : 클래스로부터 객체 생성 -> 생성되는 객체는 다른 객체들과 관계 형성
  -> 관계된 각 객체들의 동작 과정으로 애플리케이션 수행 진행
- 컨테이너를 사용하는 스프링 애플리케이션, 표준 프레임 워크 애플리케이션 등은 이러한 객체 생성, 객체 사이의 관계 설정, 관계된 객체들의 작동 등 컨테이너가 이를 수행하도록 함.
- 쓰레기 객체 : 애플리케이션이 실행되는 과정에서 다른 객체와 관계를 맺지 못하는 객체들 
	- 쓰레기 수집기(Garbage Collector) : 쓰레기 객체 회수함.
- 상속 관계
	- 클래스 상속에 의해 맺어지는 객체 사이의 관계
	- 클래스로부터 객체를 생성 
	  -> 현재 클래스로부터의 해당 객체 생성 + 상속 받는 모든 조상 클래스들 ~ 조상 객체들 까지 함께 생성
	- 객체 사이의 상속 관계 맺음
- 포함 관계
	- 애플리 케이션을 구성하는 큰 부품 객체 + 작은 부품 객체들 사이의 관계
	- 큰 부품 객체 : 필드에 작은 부품 객체들의 참조값을 저장하는 형태
	- 부품 객체들과의 관계 구현
- 의존 관계
	- 애플리케이션이 실행되는 과정에서 객체의 기능을 다른 객체에 의존하는 관계(지가 수행 안함)
	- 상속 관계와 포함 관계는 객체가 생성되는 과정에서 객체 사이에 맺어지는 관계
	- 객체 관계
		- 객체를 구성할때 하나의 객체를 여러 개의 클래스로 분리 후 구현
		  -> 이를 연결
	- but 의존 관계!
		- 애플리케이션 진행 과정에서 생성된 객체가 동작 할때 사용 객체가 대상 객체의 메서드를 호출
		- 사용 객체 자신이 수행햐야 할 일들을 대상 객체에게 이를 위임.
		- 사용 객체가 대상 객체의 메서드를 호출 하려면 사용 객체가 자신의 필드에 대상 객체의 참조 값을 가지고 있으면서 이를 사용 -> 객체에 먼저 접근 후 그 객체의 메서드를 호출

## 3.0 개발자 정의 타입
- 자바 애플리 케이션에서 객체를 생성 할때 클래스타입이라는 개발자 정의 타입을 사용 -> 객체 생성
- 생성된 객체를 사용 -> 객체를 생성할때 사용된 클래스 타입에 반영된 인터페이스 타입이라는 개발자 정의 타입 사용하여 객체에 접근
- 애플리케이션의 다른 곳에서 제공되는 서비스를 사용하려 할때
	- 어노테이션 타입(개발자 정의 타입)을 사용
- 개발자 정의타입은 기본적으로 적절한 패키지 + 별도의 .java 파일 사용 -> 타입 정의 
	- 이를 컴파일러로 번역 -> 각 타입별로 별도의 .class 파일이 생성

- 클래스 타입
	- 객체를 생성할때 쓰는 개발자 정의 타입
	- 객체를 생성 -> new 연산자 사용
	- 그 클래스 타입의 적절한 생성자 메서드를 호출 -> 객체 생성
	- 클래스 별로 생성자 메서드는 반드시 존재
	- 클래스 타입에 생성자 메서드가 존재 X : 컴파일러가 번역 과정에서 기본 생성자를 만들어 넣음.
		- 기본 생성자 : 형식 매개변수도 없고 내용이 없는 몸통으로 구성되는 생성자
- 인터페이스 타입
	- 객체 사용법을 정의하는 개발자 정의 타입
	- 인터페이스 타입을 반영하는 클래스로 부터 객체를 생성 -> 클래스 타입으로도 그 객체를 접근 가능
	  but 클래스 타입에 반영된 인터페이스 타입으로도 객체에 접근 가능
	- 인터페이스 접근시 객체지향의 다형성 구현 가능
	- 실체를 생성하는 타입이 아님. -> 생성자 메서드 존재 X.
		- 일반 메서드들도 실행을 목적으로 하지 않음
		- 메서드의 몸통이 없는 추상 메서드들로 전체 타입이 구성
- 어노테이션 타입
	- 프로젝트 다른 곳으로 서비스 제공 
	  -> 서비스 사용법을 정의하는 어노테이션 타입도 함께 정의해서 제공 해야함
	- 서비스를 제공 받는 프로젝트는 제공되는 어노테이션을 사용하여 제공 서비스 사용

# 3.1 클래스 타입
- 타입 정의 : 적절한 패키지 + 별도의 .java 파일 사용하여 수행
- but! 중첩 클래스(멤버 클래스와 로컬 클래스), 익명 클래스(익명 자식 클래스와 익명 구현 클래스), 람다 클래스 등의 내포 타입의 클래스 타입에 대한 정의는 별도의 .java 파일을 사용 하지 않고 타입 정의
- 하나의 .java 파일에 내포 타입이 아닌 여러개의 타입 정의시
	- .java 파일의 이름값과 타입의 접근 제한이 public 타입인 이름값은 동일한 이름값을 사용
	- 하나의 .java. 파일에는 public 타입이 1개만 존재함.
- 한편 .java 파일 컴파일 -> 각 타입별로 별도의 .class 파일 생성
- 기본 클래스, 중첩 클래스 등의 클래스 타입 정의시 class 예약어 사용과 클래스 이름값을 지정하면서 클래스를 정의
	- but , 익명 클래스와 람다 클래스 등은 class 예약어 사용과 클래스 이름값을 지정하지 않고 클래스타입을 정의

## 3.1 클래스 타입 정의
- 기본 형식 : 머리 + 몸통
	- 머리 : 타입의 전체적인 내용 
	- 몸통 : 타입의 구체적인 세부 내용
- 클래스 멤버들에 대한 정의 : 클래스의 멤버 + 클래스에서 생성되는 객체의 멤버를 해당 클래스 내부에 동시에 기술

### 머리
- class 예약어 사용 
- 클래스 이름값 지정
- 접근 제한자(public, default...)
- 예약어(abstract, final)들을 class 예약어 이전 위치에서 사용하면서 클래스를 정의
  
- 클래스 접근 제한자
	- public : 현재 정의 되는 클래스는 접근 제한 없이 사용하는 것이 가능
	- default : 현재 정의 되는 클래스는 동일 패키지에서만 사용하는 것이 가능.
	  접근 제한자 사용 안할시, default로 동작
- abstract : 객체를 생성할수 없는 추상 클래스를 정의
- final : 상속을 수행 할수 없는 최종 클래스 정의

- 또한 머리 부분의 클래스 이름값 이후 위치 -> extends 예약어를 사용 -> 상속 받을 클래스 지정 or implements 등의 예약어 들을 사용
	- extends : 상속 받을 클래스 지정, 다중 클래스 상속 불가능
	- implements : 객체 접근에 사용될 인터페이스 지정, 다중 인터페이스 지정 가능

### 몸통
- 클래스와 객체를 구성하는 각 요소들은 클래스 블록({}) 내부에서 다음과 같은 멤버 사용
	- 정적 요소(속성) : 필드 멤버로 기술
	- 동적 요소(동작) : 메서드 멤버로 기술
- 멤버가 클래스에 소속 or 객체에 소속 여부
	- 클래스 소속 멤버 : static 멤버로 기술
	- 객체 소속 멤버 : 비 static 멤버로 기술
- 메서드 멤버의 종류
	- 생성자 메서드 : 객체를 생성할때 호출되는 메서드
	- 게터 메서드 + 세터 메서드 : 캡슐화를 구현 할때 사용되는 메서드
	- 일반 메서드 : 객체나 클래스의 동작을 기술하는 메서드

## 3.1 멤버 정의
- 일반적인 속성 이외에 클래스에 소속되는 각 멤버들에 대한 속성에 대한 예약어 사용(각 멤버의 세부적인 속성들을 기술하는것이 가능)
	- 접근 제한
	- abstract 여부
		- abstract 속성(=abstract 예약어 사용시) : 메서드에 대해 사용하는 속성, 몸통이 없는 추상 메서드
	- final 여부
		- final 속성(=final 예약어 사용시)
		- final 필드 : 값을 한번 할당하면 그 값을 수정할수 없는 필드
		- final 메서드 : 후손 클래스에서 재정의를 할수 없는 메서드
- 멤버 접근 제한
	1. public : 모든 위치에서 접근 가능한 멤버
	2. protected : 동일 패키지에 소속되지 않더라도 후손에서는 접근 가능한 멤버
	3. (default) : 동일 패키지에서만 접근 가능, 멤버에 대해 접근 제한을 기술하지 않으면 default 접근 제한 적용
	4. private : 클래스 혹은 객체 자신만이 접근 가능한 멤버
- 클래스나 객체 외부에서 멤버를 접근 할때..
	- static 멤버 -> 클래스 이름값 사용
	- 비 static 멤버 -> 객체 참조 변수 사용
- 해당 클래스나 객체에 먼저 접근 -> 점(.) 연산자 사용 -> 해당 멤버 접근
	`thread.start(); // 점 연산자`

## 3.1 필드
- 클래스나 객체에 소속되는 변수(2.1.1절 확인)
- 필드 정의시의 타입 지정
- 필드 사용에서의 l-value, r-value 변수 정의시 타입 지정, 변수 사용과 동일

- 