# 4.0 기본 API 프로그래밍
## 1. API
- 애플리케이션은 외부에서 제공되는 서비스를 자신의 프로젝트에 사용 가능
- API (Application programming Interface) : 애플리케이션을 제작하는 과정에서 외부 서비스를 사용할때 사용하는 일련의 규칙들의 집합

### 1. 라이브러리 API
- 애플리케이션이 라이브러리를 통해 서비스를 제공받을때 사용하는 API
- 애플리케이션은 자신의 프로젝트에 해당 라이브러리를 포함 시켜야 한다. 

- 기본 API
	- JRE가 제공하는 기본 클래스 라이브러리를 사용하는 API
	- 애플리케이션 실행에 기초가 되는 클래스
	- 프로젝트 생성시, 기본 포함
- 응용 API
	- 기본 클래스 이외의 라이브러리들을 자신의 프로젝트에 별도의 방법으로 포함 시켜야 함.
		- ex_) JAVA 테스트 프로그램, JavaFx 윈도 프로그램, JSP 서버 프로그램, Spring 프레임워크, 표준 프레임 워크 등...
		- ex_) 프로젝트 생성 과정중 포함, 메이븐의 \<dependency> 등을 사용
- 서버 API
	- 필요한 서비스를 그때그때 제공자인 서버에 요청하여 결과를 문서로 반환받는 방법
	- 인터페이스 : 클라이언트 애플리케이션과 서버 프로그램 상의 서비스 계약
		- 클라이언트 등의 요청과 서버의 응답 구성하는 방법에 대한 프로토콜
		- ex_) JSON, XML 등의 문서로 구현
- 기본 API 도큐먼트
	- 기본 클래스 라이브러리에서 제공하는 개발자 정의타입들에 대한 설명을 HTML 문서로 만든것.
	- 일종의 사용 설명서

# 4.1 예외 처리
## 1. 실행 오류
- 실행 과정에서 발생할 수 있는 오류는 에러와 예외로 구분

### 1. 에러와 예외
1. 에러(Error)
	- JVM(Java Virtual Machine)에 비정상적인 상황이 발생했을 때 오류 발생
	- ex_) 
		- OutOfMemoryError : 메모리 할당량이 모두 사용중일때
		- InternalError : 메모리 부족
		- StackOverflowError : 원래 있는 메모리 보다 더 많은 메모리를 불러올때
	- 개발자가 이를 미리 예측할수 없음 -> 시스템에 변화줘서 해결
2. 예외(Exception)
	- 개발자가 구현한 애플리케이션 코드에서 발생하는 오류
	- 이를 미리 예측 -> 대처
	- 주로 사용자의 잘못된 애플리케이션 조작 or 개발자의 잘못된 코딩으로 발생
		- 예외발생에 대한 대처가 없을때 : 에러 발생
			- JVM에 의해 강제 종료
	- 예외 처리를 수행 -> 이를 대처 -> 프로그램 종료 없이 정상실행 유지.

### 2. 예외
- JRE는 애플리케이션 실행 도중 예외 발생시, 해당 예외 클래스 사용 -> 예외 객체를 생성 -> 애플리케이션에게 던짐
	- 개발 코드에서도 수행 가능
>[!note] 던진다의 의미
>프로그래밍에서 던진다는 의미는 오류가 발생되었다고 말하는것임.

- 일반 예외와 런타임 예외
	- 일반예외(Compiler Exception, Checked Exception) : 예외처리 필수
	- 런타임 예외(Runtime Exception, Unchecked Exception) : 예외처리 개발자 선택(그래도 하는게 낫다)

#### 1. 일반예외
- Exception클래스를 상속하는 예외
	- (Exception 클래스는 자바의 기본 클래스 라이브러리에 존재.)
- 예외 발생 가능 코드에 대해 예외처리 코드의 존재 유무를 컴파일러가 체크
- 해당 코드가 존재하지 않으면 컴파일 오류 발생

#### 2. 런타임 예외
- Runtime Exception 클래스를 상속하는 예외
- 예외 발생 가능 코드에 대해 예외 처리를 개발자가 선택
- 만약 예외가 발생했는데 예외 처리를 하지 않았다면 ? 
	  -> 계속 넘겨지다가 결국 JVM에서 애플리케이션 중단.
- 런타임 예외에 대한 예외 처리 코드의 사용 여부는 개발자의 능력과 경험에 의해 이를 결정

- 주요 런타임 예외
	1. NullPointerException
	2. ClassCastException
	3. ArrayIndexOutOfBoundsException
	4. NumberFormatException

1. NullPointerException
	- 참조가 없는 상태에서 객체 멤버에 접근 할때
		- 멤버 접근 방법 : 점(.) 연산자
2. ClassCastException
	- 타입 변환이 불가능한 타입으로 타입 변환을 시도할때 발생하는 Exception

```JAVA
public class RuntimeExceptionExample{
	public static void main(String[] args){
		Dog dog = new Dog();
		changeDog(dog);
		System.out.println("첫번째 다운 캐스팅 수행 완료");
		
		Cat cat = new Cat();
		changeDog(cat); //ClassCastException 발생.
		System.out.println("두번째 다운 캐스팅 수행 완료");
	}
}
// Dog 클래스와 Cat 클래스는 형제 클래스로, 하나의 상속 라인 상에 위치하지 않아 두 클래스 사이의 타입 변환은 불가능. 즉 animal이 Cat 타입의 업캐스팅인 경우 (Dog)타입으로의 다운 캐스팅은 불가능.
```

3. ArrayIndexOutOfBoundsException
	- 배열에 대해 인덱스 범위를 초과한 원소를 접근하려고 할때 발생
		- 존재하지 않는 원소를 접근하려 할때 발생하는 Exception

4. NumberFormatException
	- 숫자로 변환할수 없는 문자열을 숫자로 변환하려고 할때 발생하는 Exception

## 2. 예외 처리
### 1. try-catch-finally
- 예외처리(Exception Handing)코드 : 프로그램이 비정상 실행될 때(예외가 발생 했을때) 프로그램 수행의 종료를 막고 정상 실행을 유지 할수 있도록 발생한 예외를 처리하는 코드
- try 블록 : 예외 발생 코드들 기술
	- 혼자 사용 X , 무조건 catch와 한세트
- catch블록 : 예외 발생시 해결하는 코드들 기술
- finally 블록 : 예외 발생 여부와 상관없이 무조건 실행하는 코드 기술(생략 가능)

- try 블록
	1. 예외 발생 
	2. 블록에 포함된 예외발생 이후의 문장들은 수행X
	3. 발생 예외를 받아들이는 catch로 이동
	- 만약 정상 수행되면 바로 finally로 이동
- catch 블록
	1. 블록 이전 위치의 소괄호"()"에 자신이 받아들일 예외의 종류를 기술
		1. catch 예약어 이후에 위치하면서 블록 이전에 위치하는 소괄호 블록은 
		   반드시 try블록과 한쌍.
	2. catch가 수행
	3. finally로 이동
- finally 블록
	- try블록에서 예외가 발생하면 catch 블록을 거쳐 수행
	- try블록에서 예외가 발생 X -> catch 생략 후 수행
	- finally 블록은 생략 가능(필요에 따라 구현)
	- 예외 발생 여부와 상관 X. 반드시 수행해야 하는 블록이 있으면 사용

### 2. 다중 catch와 멀티 catch
- 다중catch : 하나의 try에 여러개의 catch를 사용 
- 멀티 catch : 하나의 catch에서 여러 종류의 예외를 받아들임

- 다중 catch
	- 복수개의 catch를 사용 -> 각 catch가 받아들이는 예외들에 대한 비교 검토는 순차적으로 실행
		- 1번째 catch 예외인지 검토 -> 현재의 예외가 그 catch에서 제시한 예외가 아니면 다음으로 넘어감.(순차적)
	- catch의 위치
		1. 가장 작은 범위의 예외(후손 예외 클래스)를 가장 먼저 생성
		2. 넒은 범위의 예외(조상 예외 클래스)를 뒤에 위치
		- try에 대한 catch는 복수 개가 존재하더라도 하나의 catch만 수행.
			(if 넓은 범위 -> 작은 범위 = 작은 범위 실행 x)
		- 넓은 범위의 catch를 먼저 수행 시키면,그 catch가 모든 예외를 받아들임.
		  => catch의 올바른 동작X.

```JAVA
try{
	String[] str = {"노근배", "이승익"};
	System.out.println(str[0] + " , " + str[2]);
} catch(ArrayIndexOfBoundsException e){
	System.out.println("ArrayIndexOutOfBoundsException 실행");
} catch(Exception e){
	System.out.println("Exception 실행");
```

- 멀티 catch
	- 하나의 catch에서 여러 종류의 예외들을 받아들임

```JAVA
try{
	String[] str = {"노근배", "이승익"};
	System.out.println(str[0] + " , " + str[2]);
} catch(ArrayIndexOfBoundsException e | NumberFormatException e){
	System.out.println("숫자 문자열 사용 혹은 첨자 사용이 잘못됨");
} catch(Exception e){
	System.out.println("무언가 잘못됨");
```

## 3. 예외 해결
- catch에서 수행
- catch는 try에 종속
- try가 던지는 예외를 받아서 해결
	- try는 예외 발생 가능 코드를 수행 -> 예외 발생 -> catch로 던짐
	- catch는 항상 try와연결되어 함께 위치
- catch 구현 -> 발생 예외는 처리된 것으로 간주 -> 오류가 없는것으로 판단
  -> 프로그램 정상 실행 유지

- catch의 예외 해결 방법
	1. 예외 복구 : 문제의 원인 찾아 해결.
	2. 예외 떠넘기기(회피) : 발생한 예외를 자신이 호출한 메서드에게 해결하도록 넘겨줌.
	3. 예외 전환 : 발생한 예외를 일관된 방법으로 해결하도록 예외를 발생시켜서 던짐.
### 1. 예외 복구
- 어떤 시도에 의해 발생한 예외들에 대해 catch에서 이를 다시 시도하여 예외가 발생하지 않는 상황을 만드는 방법
- EX_) catch에서 재시도를 통해 예외 복구
	- 네트워크 구림 -> 서버 접속 어려움 -> 여러번 반복수행

```JAVA
while(maxRetry--> 0){
	try{
		if(success-- <= 0)
			break;
		System.out.println("서버 접속 시도");
		
		if(maxRetry <= 0)
			throw new SomeException();
	}catch(SomeException e){
		System.out.println("정해진 시간을 기다림");
		acessServer();
	}
}
```

### 2. 예외 떠넘기기
- 예외가 발생된 메서드에서 이를 해결하지 않고, 그 메서드를 호출한 메서드로 발생된 예외를 떠넘기는 방법
	- try-catch 미사용시 -> 자동으로 그 메서드를 호출한 메서드로 발생 예외가 떠넘겨짐.
	- 이때, 예외 발생 메서드의 머리에서 throws(throw가 아님)예약어 사용
	  -> 그 메서드 호출과 관련하여 try-catch 사용 여부를 판단할때 도움됨.

>\[ 예외 떠넘기기와 try-catch ]
> - 예외 발생 가능 코드 블록(try블록)의 내부 코드에서 다른 메서드를 호출하고 있을때
>   예외 해결을 위한 catch 블록을 어느 메서드에서 구현하느냐
>   => try블록의 위치에 따라 달라짐(try-catch는 한쌍이기 때문)
>   
> - 메서드 내부에서 다른 메서드 호출 -> 호출된 메서드에서 발생한 예외를 처리-> try-catch를 사용한 예외 처리 코드를 _호출한 메서드에 구현_ or _호출된 메서드에서 구현 하느냐_ 에 대한 문제 
>   
> 결론 : 예외 발생 가능 코드들에 대한 블록의 범위를 고려, try-catch의 위치를 결정
> 주의 : catch 블록에서 발생예외를 해결할때 사용할 정보가 어느 위치에 존재하는지도 생각해서 결정.

---

- 메소드 호출 = 자신이 수행 해야되는 작업을 호출된 메서드가 수행 하도록 하는것.
	- 작업에 필요한 정보 => 매개변수등을 통해 피호출 메서드에 전달.
	- 해당 메서드 호출
- 작업도중 예외 발생시
	1. 자신이 가진 정보를 통해 해결 가능한 경우
	   - try-catch를 피호출 메서드에 구현 -> 정상 실행 유지 -> 작업 결과 호출 메서드에게 보고
	2. 예외 발생을 자신을 호출한 메서드에게 이를 보고
	   - try-catch를 호출한 메서드에 구현

#### 1. throws 예약어
- 피호출 메서드 머리에서 throws 예약어 사용 -> 떠넘기기
- throws로 떠넘길때, 런타임 예외이면 try-catch 사용 안해도 정상 수행, but 일반 예외면 오류 발생
1. throws에서 떠넘기는 예외가 일반 예외일때
	- 피호출 메서드에 대한 메서드 호출은 반드시 try블록 내부에서 수행
2. throws에서 떠넘기는 예외가 런타임 예외일때
	- 개발자 선택 사항
	- but!! try 블록에서 피호출 메서드를 호출하는 것이 문법적으로 안전함.

### 3. 예외 전환
- catch에서 새로운 예외를 생성 -> 그 메서드를 호출하는 메서드에게 이를 떠넘기는 방법.
- 왜 씀?
	- 예외 전환은 시스템이 서로 다른 종류의 시스템들을 연동할때 사용하는 기술.
	  => 서로 다른 시스템에서 발생하는 다른 종류 예외들을 통일된 예외로 이를 전환 해야 하기 때문.

## 4. 리소스 자동 반납
- 리소스 : 목표 달성을 위해 사용 가능한 자원. 컴퓨터 시스템에서 사용 가능한 하드웨어나 소프트웨어
	- ex_) cpu, memory, 저장공간, 네트워크 대역폭 등
- 리소스 자동 반납(try-with-resources)
	- 예외 처리 코드에서 다루는 리소스는 예외 발생 여부와 상관없이 리소스를 자동으로 안전하게 반납 하는게 가능함.
	- 자바 7이상 버전부터 기능 사용 가능.

## 5. 개발자 정의 예외
- 기본 API에서 제공하는 예외로는 다양한 종류의 예외 표현 X
- 개발자 정의 예외 : 기본 API에서 제공되지 않는 예외를 애플리케이션에서 사용할때,
  개발자가 정의하는 해당 애플리케이션만 사용하는 예외를 말한다.

### 1. 개발자 정의 예외 클래스 생성하기
- 개발자 정의 예외 클래스
	- 일반 예외로 정의 가능(Exception 클래스 상속 받으면서 정의)
	- 런타임 예외로 정의 가능(RuntimeException 클래스 상속 받으면서 정의)
	- 클래스 이름값 : ~Exception
	- 생성자 종류 2가지
		1. 기본 생성자 : 매개변수 X
		2. String 타입의 매개변수를 갖는 생성자
			- 상위 클래스의 생성자 호출, 예외 메세지 넘김
			- 예외 메세지의 용도 : 예외를 해결하는 catch에서 그 매서드를 사용하기 위함.

### 2. 예외 발생 시키기
1. new 연산자 사용 
2. 예외 클래스로 부터 예외객체를 생성
3. throw 명령어를 함께 사용
4. 생성된 객체를 던짐
	- 던져지는 예외를 해결하기 위해 try-catch 사용
	- 예외 발생 수행
```java
throw new XXXException();
throw new XXXExcpetion("예외메시지");
```

- try 블록 내부에는 자신이 던지는 예외 발생도 있음.
- 자신이 호출한 메소드로 부터 떠넘겨 지는 예외도 있다.
- 예외 객체의 생성과 던짐은 예외 발생을 현재 메서드의 try-catch에서 수행이 안되면, 
  현재의 메서드를 호출한 메서드로 자동으로 떠넘겨 진다.
	- 이때, 현재 메서드를 호출한 메서드에서 반드시 try 블록 내부에서 현재의 메서드를 호출 해야 함. 

### 3. 예외 해결하기
- 던져지는 예외를 받아 해결하는 곳은 catch 다
- catch 에서 사용하는 메서드들
	- getMessage() : 받은 예외가 어떤 예외 메세지를 가지고 있는지를 조사
	- printStackTrace() : 예외가 어떤 경로를 통해 넘겨졌는가(경로) 조사

## 6. JVM 과 WAS의 예외처리
- JVM : 개인 데스크톱
- WAS : Server(여러명이 사용)
- main()메서드까지 예외를 해결X -> JVM으로 넘겨짐 -> JVM에서 애플리케이션 중단.

- 개인용 데스크탑에서 예외를 해결하지 않으면 JVM에서 그냥 중단 시켜도 문제 X.
- BUT!! 여러명이 동시에 사용하는 서버 애플리케이션의 경우 문제 발생 -> 중단 되면 큰일남.

>[!warning] 서버 애플리케이션 예외 처리
>다른 사용자의 잘못된 조작에 의한 예외에 대해서는 애플리케이션을 중단 시키지 말아야 함.

- WAS(Web Application Server, 웹 애플리케이션 서버)
	- 예외를 해결X -> WAS에게 넘겨짐 -> 애플리케이션 중단 X -> 자신이 소유한 오류 페이지만 보여주고 애플리케이션 계속 정상 수행
	- 사용자가 이해할수 있는 개발자가 대체한 오류 페이지가 사용자에게 전달

# 4.2 스레드와 테스크
## 1. 스레드와 테스크
- 멀티 태스크 -> 동시처리 -> CPU 과부화 -> 성능저하 -> 스레드 풀 사용으로 해결!
### 1. 프로세스와 스레드
- 운영체제에서 프로세스를 위한 공간 생성 -> 여기서 애플리케이션 실행
- 프로세스 : 운영체제가 관리하는 애플리케이션 실행에 필요한 독립적인 가상공간.
	 OR 그 공간에서 수행되고 있는 애플리케이션의 실행
- java 명령어로 애플리케이션 수행 -> JVM 실행됨 -> JVM은 RuntimeDataArea 공간에 애플리케이션 배치 -> 수행
	- 프로세스 관리 : 운영체제가 담당, 애플리케이션 개발 코드에서는 제어 불가

#### 1. 스레드(Tread)
- 하나의 애플리케이션 수행 공간에서 상호 독립적으로 존재하는 코드 수행의 흐름.
- 스레드에 대한 관리 : 애플리케이선 개발 코드에서 다룸.

![[Pasted image 20241024212930.png]]

### 2. 스레드와 태스크
- 싱글 스레드 애플리케이션 : 하나의 애플리케이션에 하나의 실행 흐름을 가짐
- 멀티 스레드 애플리 케이션 : 하나의 애플리케이션에서 여러개의 실행 흐름을 가짐
- 멀티 스레드 제작 과정
	1. 스레드와 태스크의 개념적 분리
	2. 애플리케이션 제작
- 각 스레드는 자신이 진행할 작업에 대해 RuntimeDataArea영역의 스택 공간에 스레드별로 별도의 스택 형성 -> 수행되는 태스크의 각 블록에 대해 해당 스택에서 스택 프레임 형성 -> 해당 블록의 코드들 수행

#### 1. 태스크(Task)
- 스레드가 관리하는 작업에서의 작업 내용을 기술하는 수단
- 시스템 스레드의 경우, 스레드들이 다룰 태스크 메서드가 결정되어 있지만,
  작업 스레드의 경우, 개발 코드에서 여러가지 방법으로 스레드와 태스크를연결 하여 다루어야 함.

### 3. 스레드 분류

#### 1. 시스템 스레드
- 스레드 운영의 주도권을 개발 코드가 갖지 못하는 스레드.
- ex_) 메인 스레드(main메서드에서 직간접 호출되는 모든 메서드 포함)

#### 2. 작업 스레드
- 멀티스레드 애플리케이션에서 개발 코드에 의해 생성되고 운영되는 스레드.
- 작업 스레드 사용 방법
	1. Thread 클래스 사용 -> 직접 생성
	2. 개발 코드에서는 태스크만 생성 -> 스레드 풀에게 위임

#### 3. 데몬 스레드
- 주 스레드의 작업을 돕는 보조 스레드
- 주 스레드(스레드를 수행시킨 스레드) 종료시, 자동으로 함꼐 종료.
- 데몬 스레드 생성 방법
	- 보조 스레드를 start() 하기 전, 주 스레드에서 그 보조 스레드의 setDaemon(true) 메서드를 호출
	  -> 수행될 보조 스레드는 데몬 스레드가 된다.
	- 이런 특징 이외에는 일반 작업 스레드와 동일함.

## 2. 작업 스레드의 생성과 실행
### 1. 스레드와 태스크의 분리 생성
- 스레드 객체 생성
	- Tread 클래스 직접 사용
	- 태스크 객체는 스레드 객체를 생성할때 생성자 매개변수로 전달
- 스레드 객체 사용
	1. 생성된 스레드를 start()
	2. 그 스레드를 생성할때 전달된 태스크의 객체의 run() 메서드가 수행

![[Pasted image 20241024215201.png]]

### 2. 스레드와 태스크의 동시 생성
- 스레드 + 태스크 => 통합, 재정의 -> 자신이 가진 테스크 수행
- Thread클래스 상속 하는 자식 클래스를 사용 -> 스레드 객체 생성
	- Thread 자식 클래스에서 재정의하는 run()메서드를 사용
- start() -> run() 메서드 사용

> !!! 스레드 실행
> 태스크 코드 에서 다른 스레드 객체의 start() 메서드 호출 
> -> start() 된 스레드 객체는 자신이 관리하는 run() 메서드를 수행 
> 
> 스레드는 실행되면 종료할때까지 다양한 상태를 가짐.
> 스레드의 작업 진행과 관련한 상태 관리는 개발 코드에서 스레드 객체를 사용하여 수행(작업변경)

### 3. 스레드 풀에게 요청(위임)
- 개발 코드가 스레드 생성과 관리를 직접 수행 X -> 스레드 풀(Thread Pool)에게 이를 위임하는 방법
- 개발 코드는 Runnable,Callable 인터페이스를 구현하는 태스크 객체만 생성
  ->  스레드 풀에게 태스크를 처리할 스레드의 생성과 실행을 요청

![[Pasted image 20241024224635.png]]

>[!note] Core 코어
> 컴튜터의 중앙처리 장치(CPU) 에서 독립적으로 명령할수 있는 처리 장치, 프로세서의 작은 단위
> 실제로 연산을 처리하는 일을 함.

## 3. 병렬처리와 동시 처리
- 하나의 어플리케이션에서 많은 스레드 들이 동시에 진행되는 경우, 이런 조건은 현실적으로 실현 X
	- ex_) 서버 애플리케이션
- 해결법 : 여러 스레드들이 프로세서를 시간적으로 분할 -> 공유

### 1. 병렬처리(Parallel Processing)
- 동시 진행될 스레드 수 < 코어 수
- 각 스레드는 코어 공유 없이 스레드의 태스크 코드 동시 진행
- 스레드 스케줄링 작업 필요 X

### 2. 동시 처리(Concurrent Processing)와 스레드 우선순위
- 동시 진행될 스레드 수 > 코어 수
- 스레드의 동시 진행을 위해 코어를 시간으로 분할 -> 공유 -> 스레드 진행 
- 스레드 스케줄링(Thread Scheduling) : 코어를 공유할 스레드들이 어떤 순서로, 얼마만큼의 시간으로 코어를 사용할 것인가 결정.
	- setPriority(우선순위) 메서드 : 개발 코드에서 우선순위를 설정
		- 1~10 사이의 숫자를 사용하여 우선순위 부여
		- MAX_PRIORITY, NORMAL_PRIORITY, MIN_PRORITY 사용

## 4. 스레드 제어
- 스레드가 생성되면 종료될때 까지 그 스레드는 작업 진행과 관련하여 여러 상태에 놓임.
- 스레드 상태(state) : 스레드 객체의 메서드 등을 사용하여 여러가지 목적으로 이를 제어.

![[Pasted image 20241024230207.png]]

### 1. 스레드 상태(state)
- getState() 메서드 호출 -> 그 스레드의 현재 상태 정보를 Thread.State 타입의 열거 상수 값으로 구함

| 상태    | Thread.State 타입 열거 상수 | 설명                                |
| ----- | --------------------- | --------------------------------- |
| 객체 생성 | NEW                   | 스레드 객체는 생성됨, but 아직 스레드가 수행 시작 전임 |
| 실행 대기 | RUNNABLE              | 스케줄링에 의해 실행 상태로 갈수 있는 상태          |
| 일시정지  | WAITING               | 다른 스레드가 통지할때까지 기다리는 상태            |
|       | TIME_WATING           | 주어진 시간(ms) 동안 기다리는 상태             |
|       | BLOCKED               | 블로킹에 의해 일시 정지된 상태                 |
| 종료    | TERMINATED            | 실행을 마친 상태                         |

### 2. 스레드 상태 제어
- 다양한 메서드 들을 사용 -> 스레드의 상태 변화
- ex_)동기화 블록 내부에서만 사용할수 있는 Object 클래스의 메서드들
	- wait()
	- notify()
	- notifyAll()
- Thread 클래스 메서드
	- sleep()
	- join()
	- interrupt(), stop()

1. sleep() 메서드
	- 실행중인 현재의 스레드가 매개변수가 가리키는 밀리세컨드 동안 일시 정지됨
	- 정적 메서드임
		- 클래스에서 Tread.sleep() 형식으로 호출

>[!note] 일시정지 상태에서 inturrut() 메서드 
>일시정지 상태 -> intrrupt() 메서드가 호출 -> InterruptedException(일반 예외) 발생 => 예외처리 필요

2. join() 메서드
	- 상대 스레드가 종료할떄 까지 현재 스레드는 블로킹 되어 일시 정지됨.
	- 주로 현재 스레드가 상대 스레드의 결과 정보를 사용해야 할때 씀.
	- 객체 메서드
		- 상대 스레드 객체의 참조 변수를 사용 -> join() 메서드 호출

3. interrupt() 메서드
	- 스레드가 현재 작업을 멈추고 중단 상태를 처리하도록 요청
	- 종료 순서
		1. 스레드가 일시정지 상태됨
		2. interrptedException 예외 발생 
		3. 종료 요청에 대한 반복 검사 필요 X
		4. 스레드의 안전한 종료
	- 스레드 객체 메서드
	- ADT
		1. interrupt 사용
		2. 일시 정지된 스레드(sleep())를 interrupt 하면 오류 발생
		3. try-catch로 넘어감
		4. catch에서 자원 반납

>[!warning] stop()메서드
>원래는 stop()메서드로 스레드를 강제 종료 할수 있는데, 이렇게 하게되면 자원 반납을 못함.
>
>그 방법의 대안으로, stop 플래그가 세팅되었는가를 반복적으로 체크 
>-> 그 플래그가 세팅이 되면 종료하도록 함.
>
>ex_) boolean stop = false; -> boolean stop = true; -> 종료


