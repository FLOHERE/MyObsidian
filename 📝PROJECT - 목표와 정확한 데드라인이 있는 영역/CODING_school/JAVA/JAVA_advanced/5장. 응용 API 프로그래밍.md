- 학습 목표(자바로 제작하는 대표적인 프로그램의 종류)
	- Junit 테스트 프로그램
	- javaFx 윈도 프로그램
	- 앱
	- JSP
	- Spring 프레임워크

# 5.1 JUNIT 테스트 프로그램
- JUNIT이란 ? 일종의 테스트 프로그램 도구
- 소스가 잘 작동하는지 시험 하는 역할
## 1. 실행 테스트와 정적 테스트
- 계발 단계의 테스트
	- 테스트 도구의 도움으로 코드 테스트 -> 오류가 있는지, 잘 돌아가는지 확인

#### 실행 테스트
1.  소스(테스트 대상 클래스)가 기댓값에 맞게 결과를 도출하는지 테스트.
	- 이를 위한 테스트 케이스(테스트 클래스) 함께 작성
2. 테스트 클래스 완성시 테스트 프레임워크(JUNIT) 사용 -> 대상 클래스의 메서드 수행을 테스트 함
	- 단위 테스트 수행 : 실행 테스트 코드가 대상 클래스 코드를 메서드 단위로 테스트 하는것

#### 코드리뷰(정적 테스트)
- 개발자들이 모여서 코드 작동 여부 체크(온라인도 가능)
- 결함이 있는 코드에 대해 상호 의견 교환. 코드 개선 작업

![[Pasted image 20241212163243.png]]

- 자바 개발 소스
	- main/java
	- main/resources
	- test/resources

### 실행 테스트
- 비정형화된 실행 테스트
	- System.out.println 써서 결과만 보는 방식
	- 개발자만 문제점을 알 수 있음(규모가 커지면 힘듦)
	- 단점
		- 테스트 성공/실패 개념 명확X
		- 구조적 표현 방법 X
		- 외부 이용 관점에서 테스트 하기 힘들다
		- 코드 뒤섞임 -> 분리 힘들다..
		- 코드 배포시 테스트 코드는 주석 처리 or 제거
- 테스트 프레임 워크를 사용한 정형화된 실행 테스트 : 소프트웨어 기능 테스트
	- ex_) Jnit테스트
	- 병렬 테스트 프레임 워크
	  : Junit 테스트 프레임워크가 수행하는 테스트 코드(테스트 케이스 코드)는 실제 코드(대상 클래스 코드)와 완벽하게 경로, 파일이 일치 해야함(1:1)
	- 장점
		- 자동화된 단위 테스트 구현
		- 빌드 도구(Ant, Maven,Gradle)와 연계하여 빌드 시 자동 테스트 구현
		- 테스트 케이스 작성을 위한 API 제공
		- 뛰어난 확장성 제공
		- 대부분의 자바 IDE에서 지원
	- 테스트케이스 수행 흐름 순서
		1. @BeforeClass(해당 테스트 클래스가 실행되기 이전의 수행할 코드 구현)
		2. @Before(테스트 작성 전에 수행할 코드 구현)
		3. @Test(테스트 코드 구현)
		4. @After(테스트 종료 전에 수행할 코드 구현)
		5. @AfterClass(해당 테스트 클래스가 실행된 이후에 수행 할 작업 구현)

- 테스트 케이스의 assert계열 메서드들
	- 테스트 수행에 필요한 메서드

| 메서드                           | 기능                                               |
|----------------------------------|----------------------------------------------------|
| assertEquals(expected, actual)   | 기대값과 실제값이 같은 편인지 확인합니다.          |
| assertNotEquals(expected, actual) | 기대값과 실제값이 다른지 확인합니다.                |
| assertNull(actual)               | 객체가 null인지 확인합니다.                        |
| assertNotNull(actual)            | 객체가 null이 아닌지 확인합니다.                   |
| assertSame(expected, actual)     | 두 참조가 같은지 확인합니다.                       |
| assertNotSame(expected, actual)   | 두 참조가 다르다는 것을 확인합니다.                |
| assertTrue(condition)            | 조건이 true인지 확인합니다.                        |
| assertFalse(condition)           | 조건이 false인지 확인합니다.                       |
| fail()                            | 강제로 테스트를 실패로 종료시킵니다.              |

- 단위 테스트 수행 가이드

| 종류                | 설명                                 |
| ----------------- | ---------------------------------- |
| 생성자 테스트           | 단순한 로직인 경우에는 테스트하지 않음              |
| getter/setter 테스트 | 단순한 로직인 경우에는 테스트하지 않음              |
| Null 체크 테스트       | Null이 발생할 경우를 미리 체크하는 등            |
| 동등 테스트            | 객체의 종류에 따라 동등 테스트를 수행              |
| 테스트 수행 전제 조건      | 클래스, 메서드 단위에 대해 수행 전제 조건 반드시 작성 필요 |
| 파라미터 검증           | 파라미터 값이나 범위가 바뀌면 반드시 테스트           |
| 타입 검사             | 결과는 시간을 지연하고 오래 걸릴 경우 처리           |
| 테스트 무시            | 메서드 또는 테스트를 건너뛸 수 있음               |

### 정적테스트 = 코드리뷰
- 개발된 코드 실행 x, 개발자들이 코드를 보면서 오류, 개선점을 찾음
- 코드 인스펙션 도구 : 소스코드 품질 분석
	- ex_) PMD, FIndbugs
- 코드 리뷰 주요 체크 리스트 - 전자정부 표준 프레임워크
	- 변수 명은 다른 사람이 봐도 이해할 수 있는가?
	- 문자열 혹은 숫자 리터럴이 여기저기 쓰여서 의미를 알 수 없게 하지 않는가?
	- 어떤 기능을 하는 로직인지 알 수 없도록 작성되지 않았는가?
	- null check는 분명히 있는가?
	- 정보 은닉은 이루어 졌는가?
	- 의미 없이 성능을 저하하는 코드를 넣지는 않았는가?
	- 메소드가 유추할 수 있는것 이외의 동작을 하지는 않았는가?
	- 임시 변수가 지나치게 많이 사용되지는 않았는가?
	- 의미를 알 수 업슨 상수가 사용되지는 않았는가?
	- 중첩된 if문이 지나치게 많거나 알아보기 어렵게 적혀 있지는 않은가?
	- 상속과 구현은 의미 있게 이루어졌는가?

- PMD(Programming Mistake Detection) 인스펙션 도구
	- 개발코드 테스트 도구 
		- 검사 , 점검 수행
	- 소스코드에 대한 코딩 품질 검사
	- PMD 룰셋 사용 -> 잠재적 결함의 코드 조사
	- 표준 프레임 워크의 PMD 룰셋
		- 10개의 룰셋, 39개의 룰들로 구성
- 출처 : https://byul91oh.tistory.com/453

- FindBugs 인스펙션 도구
	- 바이트 코드(.class)에 대한 잠재적인 버그 검사
	- 멀티스레드 관련 버그, 라이브러리 잘못 사용에 대한 검사, 객체 동등에 대한 검사 등등을 수행

## 2. Junit 테스트
### 1. Junit 라이브러리 추가 
: JRE 기본 API가 제공 X, 개발자가 프로젝트에 별도 포함.

- 별도 포함 방법
	1. 라이브러리 복사 & 클래스 패스 추가
		- https://search.maven.org <--여기서 다운, 폴더 환경변수 CLASSPATH에 추가
	2. 이클립스를 사용한 라이브러리 추가(자바 심화 328pg 참조)
	3. 메이븐 디펜던시 설정을 통한 라이브러리 추가(얘가 제일 간단)
		- `pom.xml에 <dependency> 엘리멘트 사용 -> .jar 포함`

### 2. 테스트 대상 클래스 작성

```java
package chapter5;

public class MyArrayList {
	private Object[] elementData;  // 이 변수는 데이터 저장을 위한 배열
	private int capacity;           // 현재 배열의 용량
	private int elementCount;       // 현재 저장된 데이터 개수
	
	public MyArrayList(int cap) {
	    this.capacity = cap;        // 주어진 최대 용량 설정
	    elementData = new Object[capacity];
	}
	
	// 특정 인덱스와 관련된 데이터에 대한 접근
	public boolean add(int element) {
	    if (elementCount < capacity) {
	        elementData[elementCount++] = element; // 요소 추가
	        return true;
	    } else {
	        throw new ArrayIndexOutOfBoundsException();
	    }
	}
	
	public int sum() {
	    int sum = 0;
	    for (int i = 0; i < elementCount; i++) {
	        sum += (int) elementData[i]; // 요소의 합계
	    }
	    return sum;
	}
	
	public int getElementCount() {
	    return elementCount;
	}
	
	public int getCapacity() {
	    return capacity;
	}
}
```

### 3. 테스트 케이스 작성
- (maven) test 폴더 생성 -> 거기에 테스트 실행
- 1:1 형태로 똑같아야 함.
- Intellij와 eclipse의 방식이 다름. 알아서 해라

>[!note] 메서드 스텁
>개발 테스트에서 사용되는 용어, 메서드의 기본 구조 정의를 말함.
>(하지만 함수의 실제 구현은 포함 X)

- 테스트 메서드 전후로 어떤 작업을 수행 할것인지 고려 -> 메서드 스텁 선택
- 이후 테스트 케이스 클래스의 세부 코드 작성
	- assert 메서드들 사용 -> 결과값 = 기댓값인지 확인

- 테스트 스위트 작성
	- 테스트 스위트 : 패키지 단위로 묶어서 테스트 진행 할때 사용
	- 장점 : 효울적임
	- 여러개의 테스트 케이스 or 테스트 스위트 묶어서 만듦

### 4. 테스트 실행
- 테스트 케이스 클래스 선택 -> 우클릭 -> run as -> JUnit Test 선택

>[!note] 라이프 사이클
>- 객체가 생성, 사용, 소멸되는 과정
> - ! Scope(범위) 와의 차이점 : 메서드 접근시 변수의 유효범위를 말하므로 둘이 다른 개념임.

# 5.2 JavaFx 윈도 프로그램

## 1. UI에 의한 애플리케이션 분류
- 애플리케이션은 애플리케이션 사용자와 프로그램 사이 어떤 종류의 사용자 인터페이스를 사용하는지에 따라 나뉨
	- 콘솔 프로그램
		- UI 사용 x
		- 키보드, 마우스로 부터 입력, 모니터에서 직접 출력
	- 윈도 프로그램
		- 창(window)을 UI로 사용
	- 서버 프로그램
		- 웹 클라이언트 프로그램 + 웹 애플리케이션 서버(WAS) 로 연결된 웹 환경을 UI로 사용

### 콘솔(console) 프로그램
-  사용자와 프로그램 사이 UI 없음.
- 키보드, 마우스로 직접 입력받음
- 모니터로 프로그램 출력 받음
- 특징
	- 수행 흐름 제어할 UI가  X -> 프로그램을 구성하는 코드 자신이 이를 수행
	- 코드 위치와 순서 중요 -> 코드 흐름도 사용(절차 지향적)
	- 거의 사용 안함(불편해서)

키보드 마우스 -> 명령/데이터 입력 -> 콘솔 프로그램 
		모니터 	<-   결과 출력    <-

### 윈도 프로그램
- 창(window)을 이용해서 사용자와 프로그램 사이의 UI로 사용하는 프로그램임.
	- 사용자는 프로그램에 직접 입력 수행 X
	- 프로그램이 제시하는 "창"에 입력 -> 창에서 메세지로 변환 -> 프로그램에게 전달
	- 사용자는 시스템에 의해 제어된 창으로 출력 내용 전달 받음
- 특징
	- 창에서 전달하는 메세지가 프로그램의 수행 흐름 제어
	- 코드 위치 중요 X(객체 지향적)

키보드 마우스 -> 명령/데이터 입력 -> 메세지 전달 -> 윈도 프로그램
				{창(window)}
			모니터 <- 모니터 출력 <-  창 출력 <-

- Win32 API 윈도 프로그램
	1. 메세지 큐 : 시스템이 스레드 별로 제공
	2. 메세지 루프 : 메세지 큐의 메세지를 메세지 핸들러에게 전달
	3. 메세지 핸들러 : 프로그램에서 보통 관련 객체의 멤버 함수로 구현

>[!note] 멤버 함수
>객체 지향 프로그램 내 함수 or method 클래스의 데이터 접근
>
>- 장점 : 캡슐화 + 재사용성
>  - ex_) 인스턴스 함수 (특정 인스턴스에 속한 멤버 함수), 정적함수

- JavaFx 윈도 프로그램
	- 메세지 핸들러(이벤트 핸들러)를 각 UI 객체(컨트롤객체)에 연결 등록
	- 사용자 입력에 대해 해당 이벤트 핸들러가 동작하는 구조
	- javafx 라이브러리
		- Java에서 윈도우 프로그램을 사용 가능하게 해주는 라이브러리, 창을 띄워준다.

![[Pasted image 20241212193629.png]]

### 서버 프로그램
- 2인 이상이 사용하는 애플리이션은 서버 프로그램이 필수
	- 서버 프로그램 - 클라이언트 프로그램 필요
		- 클라이언트 프로그램 제작 :  개인 기기에서 동작하는 콘솔프로그램 or 윈도 프로그램.
			- ex_) 스마트폰의 엡, 웹 브라우저
		- 대부분 웹 서버 프로그램으로 구현함
- 웹 서버 애플리케이션 
	- 웹 환경을 UI로 사용하는 서버 프로그램
	- 사용자는 웹 클라이언트 프로그램을 사용  -> 애플리케이션에 접근
	- 애플리케이션은 웹 애플리케이션 서버를 통해 사용자에게 응답.
	- 웹 클라이언트 프로그램으로 웹 브라우저 많이 사용.

사용자 - 웹 클라이언트 프로그램 - 웹 - WAS - 웹 서버 애플리케이션
		<- - - - 	웹 환경(UI) - - - - - - >

>[!note] 클라이언트란?
> 사용자와 서버를 연결시켜주는 수단

## 2. 애플리케이션 분석, 설계 , 구현
1. 제작하려는 애플리케이션이 수행할 작업들에 대한 분석
2. 사용자가 사용할 프로그램이 제시하는 모습(UI) 설계
   (세부 작업들의 별도 수행등과 같이 작업의 진행이 별도의 스레드로 수행 되어야 할 작업들의 분류)
3. 이들을 구현하는 클래스 제작

### 요구분석 
- 클라이언트 애플리케이션 : 채팅 참여자의 모든 요구 내용들을 서버에 전달
	- 서버 애플리케이션과의 연결 요청
	- 채팅 참여자의 닉네임 기억 요청
	- 모두 대화 요청
	- 상대 대화자를 지정한 1:1 대화 요청
- 서버 애플리케이션 : 채팅 수행, 서버 동작과 관련한 주요 기록들을 창에 출력
	- 서버 소켓을 사용한 연결 요청 기다림
	- 연결 요청 수락
	- 클라이언트와 통신할 통신 소켓 생성
	- 클라이언트 별 닉네임 기억
	- 모두 대화 요청 
	- 1:1 대화 요청에 대한 대화 메세지를 해당 클라이언트에게 전송

### 애플리케이션 및 UI 설계
- 윈도 프로그램
	1. 사용자(채팅 참여자)의 요구들을 창을 통해 전달 받음
	2. (창에 등록된)이벤트 핸들러가 이를 처리
	3. 창 모습(UI) 설계가 중요
- 통신 프로그램
	1. 전달받는 메세지에 의해 채팅을 수행
	2. 클라이언트로 받는 메세지에 대한 구성 규칙이 필요


### 스레드 및 태스크 설계
1. 독립적으로 수행 될 각 작업들을 찾는다.
2. 별도의 스레드(작업 운영 객체)와 태스크(작업 내용 객체)로 처리

- 메인스레드 : JVM에 의해 생성되는 프로그램 시작 스레드(main() 메서드 실행)
- application 스레드(UI 스레드)
	- 창(UI)과 관련된 작업 수행(start()메서드 실행)
	- 다양한 창들을 사용한 창 모습 구현 -> 이벤트 핸들러 등록 -> 사용자의 창 사용 -> 등록된 이벤트 핸들러 작동
- 작업 스레드
	- 창 처리 관련 작업 이외의 작업
	- 서버 소켓 사용 -> 클라이언트 연결 요청 기다림
	- 서버 - 각 클라언트에서 별도 스레드들이 처리(통신 소켓을 사용하여 메세지 수신하는 등의 송신작업)
	- 서버 애플리케이션 흐름
		1. 서버 소켓 사용
		2. 클라이언트로 부터 연결 요청 기다림
		   - + 동시에 클라이언트별 통신 소켓을 사용하여 클라이언트와의 대화도 수행
		     (=클라이언트와 서버 간의 연결 대기 및 커뮤니케이션)

>[!warning] 화면 멈춤 발생
>창 처리는 별도의 작업 스레드로 수행해야 함. 아니면 화면 멈춤
>=> 창과 연결된 이벤트 핸들러에서 논리적인 기다림 발생, 오랜 시간이 걸리는 작업들은 별도 작업 스레드 필요.


### 클래스 구현
- 창 모습의 구현
- 이벤트 핸들러 작성
- 스레드가 수행 할 태스크 생성(작업 내용 구현)
- 스레드 운영 등등
- 애플리케이션이 필요로 하는 모든 작업 -> 클래스로 구현

- 클래스 작성
	- 각 작업을 수행하는 객체를 위한 다양한 클래스 제작
	- 객체의 동작 : 클래스 소속 메서드로 기술
	- 동작에 사용되는 정보 : 클래스 소속 변수로 기술
- 애플리케이션 수행과 관련하여 클래스 로부터 객체 생성 및 작동

## 3. 요구 사항 분석
### 프로젝트 구성
- 채팅 프로젝트 = 클라이언트 애플리케이션 + 서버 애플리케이션
	- 클라이언트 애플리케이션 : 대화 참여자의 요구 정보를 서버에게 전달
	- 서버 애플리케이션 : 전달되는 참여자의 요구 정보들을 처리하여 채팅 수행

- javaFx를 사용한 윈도 프로그램
	1. 창을 통해 대화에 필요한 모든 정보를 애플리케이션에게 입력
	2. 애플리케이션도 창을 통해 채팅과 관련된 모든 내용을 대화 첨여자에게 출력

- 통신 소켓만을 사용하는 통신 프로그램
	- TCP/IP 통신 소캣 사용

클라이언트 -> 메세지 송출 -> (통신소켓) 출력 스트림 추출 -> 사용자의 입력정보 -> 서버
	<- 서버로부터 전달되는 정보    <- (통신소켓) 입력 스트림 추출    <- 메세지 수신

>[!note] 입력/출력 스트림
>- 입력 스트림(InputStream) : 데이터를 읽어오는 통로(외부 소스를 이용해 데이터 가져옴)
>- 출력 스트림(OutputStream) : 데이터를 외부로 전송하는 통로

서버 소켓(기다림) <-- (연결중) -- 클라이언트  <- 통신 수행 
	-> (수락) -> 서버소켓(연결O) -> 통신소켓 ->

![[Pasted image 20241212210308.png]]

### 서버 애플리케이션 실행
- start 버튼 : 클라이언트 애플리케이션의 연결 요청 기다림

### 클라이언트 애플리케이션 실행
1. 클라이언트 애플리케이션 실행
2. 연결 요청 버튼 클릭
3. 연결 요청 버튼 -> 연결끊기 버튼으로 변신

- 클라이언트 메인 창에는 \[연결완료] 등의 메시지가 출력 
	- 메인 창을 로그 정보와 채팅의 대화 내용을 보여주는 창으로 사용

- IO 스트림을 사용한 메세지 송출과 메시지 수신
	1. 통신 소켓으로 부터 입출력 스트림 객체 추출
	2. 추출된 입출력 스트림 객체를 사용
	3. 메세지를 송출(write() 메서드)
	4. 메세지를 수신(read()메서드)

### 채팅 수행
- 클라이언트 서버 모델링의 채팅
	- 클라이언트 사이의 직접적인 연결X
	- 모든 클라이언트들은 하나의 서버로 연결
	- 클라이언트 사이의 대화 = 서버를 통한 간접적인 연결을 통해 치팅을 수행
- 채팅에서 사용할 자신의 닉네임 입력
	- \[이름...] 버튼 클릭
- 서버 애플리케이션에서는 \[요청처리] 메시지 출력
- 1:1 대화
- 모두 대화

- 서버 메세지 구분
	1. 닉네임 입력 메세지
	2. 1:1 대화에 사용되는 메세지
	3. 모두 대화에 사용되는 메세지
	- 클라이언트 - 서버 사이에 사용되는 메세지를 위한 프로토콜이 필요

## 4. UI 설계
### javaFx 애플리케이션
- 클라이언트 애플리케이션 - 채팅 사용자가 창을 사용
- 서버 애플리케이션 - 서버 관리자가 창을 사용

- 메인 클래스 - javaFx 라이브러리의 Application 클래스 상속
	- launch() 메서드 호출
		- UI 스레드 생성하여 진행
- UI 스레드
	- start() 메서드를 태스크로 사용하여 진행되는 스레드
		- start() 메서드 : 프로그램 수행에 필요한 UI 준비 및 관련 작업 수행
		  ex_) 창을 생성 후 모니터에 출력(이벤트 핸들러 등록, 사용자의 창사용에 따른 이벤트 핸들러의 작동 등)

- javaFx가 다루는 창의 종류
	: start 메서드에서 계층적으로 창을 구성. 애플리케이션 시작 단계에서 이를 사용자에게 제시
	- stage : scene 창 세팅, 모니터에 출력
	- scene : 루트 container를 사용 -> 장면 구성하는 창
	- container : control, container의 레이아웃 관리하는 창
	- control : 사용자와의 대화를 수행하는 창

- 레이아웃 : 컨테이너 창에서 컨트롤 창의 크기와 위치 등을 결정
	- 프로그램 코드 사용 : start() 메서드에서 자바 코드를 사용하여 레이아웃 수행
	- FXML을 사용한 레이아웃 : 창의 모습 그린 후 start()메서드에서 FXML로더 사용 -> 창의 레이아웃 파일 로딩

- 이벤트 핸들러
	- 사용자의 입력에 반응하여 프로그램의 동작을 결정
	- 핸들러 객체 생성 : EventHandler\<ActionEvent> 제너릭 함수적 인터페이스를 사용
		- handle() 추상 메서드 1개 가짐
		- 대부분 람다 표현식 사용 -> 핸들러 객체 사용
	- 컨트롤의 setOnXXX 메서드 사용 -> 핸들러 객체를 컨트롤에 등록
		- 사용자가 컨트롤 사용 -> 등록된 핸들러 객체 작동

- UI 스레드
	- 역할 : UI(창)와 관련된 모든 행위 수행
		- ex_) 창의 생성 및 변경, 핸들러 객체의 컨트롤 등록 + 핸들러 객체의 작동 등
- UI 스레드가 아닌 다른 작업 스레드에서 창과 관련된 작업 수행 할때
	  : Platform.runLater() 사용
		  -> UI스레드에게 이를 요청
	- UI 스레드의 이벤트 큐에서 대기 -> UI스레드가 이를 수행

### 스레드 설계
- 처리할 작업들 독립적 수행시 별도의 스레드 준비 후 수행
	- 태스크 객체
		- Runnable, Callable 인터페이스를 구현하는 객체
		- !! 태스크 객체는 Thread를 상속받는 스레드 후손 객체에 run() 메서드 재정의 통한 스레드 객체의 내장 객체로 구현도 가능
		- 스레드 객체 : 작업 진행을 관리하는 객체
- javaFx 애플리케이션의 경우 main()메서드에서 launch()메서드를 호출 해야함.
	- launch()메서드 내부에서는 javaFx 기본 스레드들이 생성, 그 스레드들이 수행됨
	- UI(Application)스레드는 start()메서드를 테스크로 사용
		1. start()메서드 실행
		2. 창 사용
		3. 이벤트 헨들러 동작

### 클라이언트 애플리케이션의 스레드 운영
- 클라이언트 애플리케이션
	- 스레드가 필요한 태스크들에 대해 Thread를 상속하는 익명 후손 클래스를 사용
	- 태스크 객체와 스레드 객체를 동시에 생성
- 별도 작업 스레드 과정
	1. 메세지를 받을때 서버 응답 기다림
	2. 메세지 올때까지 모든 작업 일시 중지(사용자가 메세지를 입력 하더라도)
	3. 창은 정지한 상태

```java
socket = new Socket();
//서버 소켓에게 연결 요청
//서버에 의해 연결 요청이 수락되고 그 확인이 올때까지 기다림 수행
.
.
.
InputStream inputStream = socket.getInputStream();
//서버로부터 메세지를 수신할 때 가지 기다림 수행
```

- 서버로 메세지 송출
	- 사용자가 버튼 클릭 -> (그때 수행되는 이벤트 핸들러에서)스레드 진행 시작 -> 메세지 송출 완료 -> 스레드 종료

```java
byte[] byteArr = data.getBytes("UTF-8");

//출력 스트림 추출
OutputStream outputStream = socket.getOutputStream();

//서버에게 메세지를 송출하는 작업 수행
outputStream.write(byteArr);
outputStream.flush();
```

### 서버 애플리케이션의 스레드 운영
- 서버 애플리케이션
	- 많은 스레드 필요
	- 스레드풀 사용 -> 멀티스레드 운영

- 요청 기다림의 연속............

```java
//연결 요청이 들어올때 까지 기다림을 수행
//요청이 들어오면 이를수락, 통신 소켓 생성
Socket.socket = serverSocket.accept();
```

```java
//클라이언트로부터 메세지가 수신될때 까지 기다림
//메세지 수신
int readByteCount = inputStream.read(byteArr);
.
.
.
PlatForm.runLater(()->displayText(message));
```

- 전달 받은 메세지를 특정 클라이언트(들)에게 그 메세지를 다시 송출하는 작업
	- 답글 기능
	- 송출 완료시 스레드 종료
	- 애플리케이션 = 현재 클라이언트 수 * 각 클라이언트에서 메세지 개수만큼의 스레드들 필요
	- 메세지 송출 과정
		1. 통신 소켓에 메세지 전달 받음
		2. 통신 소켓이 클라이언트에게 재송출(재전송)
		3. 송출 완료시 종료

```java
//메세지 송출
outputStream.write(byteArr);//실질적 메세지 전송(재전송)
outputStream.flush();//메세지 지연X, 출력 스트림의 데이터 강제 전송
```

>[!note] Runnable, flush()
>- Runnable : 새로운 스레드 생성(run메서드 구현 -> 스레드가 실행할 코드 작성)
>- flush() : 메세지 강제 전송
> 	 flush() 쓰면 데이터 유실 없음? => try-catch로 해결!

### 스레드 풀
- 스레드 많이 이용 -> 스레드풀 사용(스레드 생성, 관리)
	- 스레드 많이 이용시 오버헤드 발생 
	  -> 스레드풀 사용으로 해결(스레드 미리생성 후 동시에 수행되는 스레드의 적정개수 관리)
	- 스레드 풀 사용시 순서
		1. 애플리케이션 초기에 스레드 풀 생성
		2. 스레드 필요작업 -> 별도의 태스크 객체로 만듦 -> 스레드 풀에게 제출
		3. 풀의 작업 큐에서 대기
		4. 큐에 대기한 태스크 객체 선택 -> 자신이 관리하는 스레드를 작업에 배치 -> 수행
		5. 애플리케이션 종료시 스레드 풀 shutDown

## 5. 클래스 구현
- 개발자 정의 타입에 애플리케이션 수행 내용을 기술
	- 서버 애플리케이션 중점으로 봄

### 서버 애플리케이션 클래스
- 다양한 문법으로 정의중
	- server 클래스 : 별도 .java 파일로 클래스 정의
		- main()메서드(시작하는 기능) 가짐
		- `public class Server extends Application{}`
	- Client 클래스 : 메인 클래스의 중첩 클래스인 객체 맴버 클래스로 정의
		- 서버에 연결되는 모든 클라이언트들은 해당 클라이언트와 통신하는 서버 내부에 위치하는 각 객체들을 위한 클래스
		- 같은 서버에 연결된 클라이언트들과 서버의 객체를 위한 클래스

>[!note] 메인클래스의 중첩인 클래스?
>- 메인 클래스 안에 있는 또 다른 클래스를 말함.
>- 중첩 클래스 : 하나의 클래스 안에 정의된 클래스를 말하며, 코드 응집력이 높고
>	(바깥 클래스의 멤버 속성에 쉽게 접근이 가능하다는 뜻) 관련 클래스 관계가 명확.

![[Pasted image 20241212225617.png]]

- 이벤트 핸들러 클래스
	- handle()메서드 실행 순서
		1. (start) 버튼 클릭
		2. startServer()메서드 호출
		   ----
		1. (stop) 버튼 클릭
		2. stopServer() 메서드 호출

![[Pasted image 20241212225905.png]]

>[!note] 이벤트 핸들러
>- 이벤트 : 프로그램에서 발생하는 특정 행동, 상태 변화
>- 이벤트 핸들러 : 프로그램에서 발생하는 특정 이벤트 감지, 그에 대응하는 특정 작업을 수행하는 코드 블럭


- 테스크 클래스
	- 인터페이스 구현 익명 클래스를 정의 
	- 스레드 풀에게 제출되는 태스크 객체 생성

![[Pasted image 20241212230157.png]]

### 서버 애플리케이션의 메서드 
: 서버 애플리케이션의 각 클래스를 구성하는 메서드

- Server 클래스 메서드
	- main() : launch() 메서드 호출
	- displayText() : TextArea에 문자열 덧붙임
- start() 메서드
	- UI 스레드의 태스크 메서드
	- control 창 : 핸들러 객체의 handle() 메서드 수행
- startServer() 메서드
	- handle() 메서드가 호출하는 메서드
	- 스레드 풀 생성
	- 서버 소켓 생성
	- 서버 소켓 포트 바인딩 수행
	- 요청이 들어올때 마다 클라이언트와의 연결을 위한 작업 수행
		- 수행내용 -> 별도의 태스크로 제작 -> 스레드 풀에게 처리 요청
		- 태스크 내용 : 연결 수락(통신 소켓 생성), client 객체 생성(생성 객체에 통신 소켓 전달), 생성 Client 객체를 클라이언트 객체 리스트에 추가
- stopServer()메서드
	- 클라이언트 객체 리스트 사용 -> 모든 통신 소켓 close()
	- 서버 소켓 close(), 스레드 풀 shutDown()

- Client 클래스의 메서드 
	- 생성자 메서드
		- 전달받은 통신 소켓을 필드(socket)에 보관
		- receive() 호출
			-  : 메세지를 수신 할때마다 연결된 모든 클라이언트에게 수신 메세지 송출 or 닉네임 기억
		- 수행 내용 -> 태스크로 만듦 -> 스레드 풀에게 처리 요청
			- 태스크 내용 : 통신 소켓으로 부터 입력 스트림 추출, 추출 스트림을 사용 -> read()수행 -> 읽은 메세지를 연결된 모든 클라이언트에게 다시 송출
	- send() 메서드
		- 수신 메세지를 다시 클라이언트에게 송출
		- 수행 내용 -> 태스크로 만듦 -> 스레드 풀에게 처리 요청
			- 태스크 내용 : 통신 소켓을 부터 출력 스트림 추출, 추출 스트림 사용 -> 메세지 write() 수행

### 서버 애플리케이션의 변수
- 서버 애플리케이션에서 사용하는 필드 변수와 메서드 변수

- 클래스 변수(필드)
	- 필드 : 클래스에서 정의되는 클래스 or 객체에 소속되는 변수
		- 클래스 or 객체에 소속되는 여러 메서드들이 공동으로 사용할 변수
	- 메인 클래스 소속 : Server 클래스에서 정의하는 필드 변수
	- Client 클래스 소속 : Client 클래스에서 정의하는 필드 변수
- 메서드 변수
	- 메서드에서 정의하는 로컬 변수 혹은 형식 매개변수
	- 각 run() 메서드 소속 변수
		- 별도의 스레드로 수행, 각 태스크의 run()메서드에서 정의 하는 변수
- start() 메서드 소속 변수
	- 메인 클래스에서 재정의
	- Application 스레드에 의해 수행되는 start()메서드에서 정의하는 변수

