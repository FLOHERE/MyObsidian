# 클래스
- C는 함수 중심의 절차적인 프로그래밍 언어
- C++은 객체 중심의 객체지향 프로그래밍 언어
- 객체(object) 
	- 객체 지향의 개념에서 가장 중효한 것
	- (C++에서) 객체는 클래스(class)로 표현된 추상적인 틀을  이용하여 만들어진 구체적인 대상
		- 클래스
			- 헤더 파일(\*.h)에 정의 
			- 맴버 변수
			- 맴버 함수

## 객체 지향 프로그래밍(Object-Oriented Programming, OOP)
- 여러 독립적인 부픔들의 조합
	- 객체들의 유기적인 협력과 결합으로 파악하고자 하는 컴퓨터 프로그래밍의 패러다임을 의미
- ex_) 자동차를 만들때  부품들을 따로 만들고 마지막 본체에 최종 조립함
- 객체 지향적으로 소프트웨어를 설계를 한다 = 어떤 프로그램의 일부분에 해당하는 작은 부품
	-> 객체를 먼저 만들고 이렇게 만들어진 여러 객체들을 조립해서 하나의 완성된 프로그램을 만드는것.
- 각 부품 = 객체
- 프로그래밍에서 필요한 데이터를 추상화 
	  -> 상태와 행위를 가진 객체로 만듦 
	  -> 객체들간의 상호 작용을 통해 로직 구성
- 객체 : 프로그램에서 사용되는 데이터 또는 식별자에 의해 참조되는 공간을 의미
	- 값을 지정할 변수와 작업을 수행 할때 메소드를 서로 연관된 것들끼리 묶어서 만든것
- 객체 지향 언어
	- C++
	- C#
	- Java
	- Python
	- Javascript
	- Ruby
	- Swift

## 객체 지향 프로그래밍의 특징4대 요소(추상화, 캡슐화, 상속, 다형화)
### 1. 추상화(Abstraction)
- 객체에서 공통된 속성과 행위를 추출하는 것
- 공통의 속성과 행위를 찾아서 타입을 정의하는 과정
- 추상화는 불필요한 정보는 숨김, 주용한 정보만을 표현 -> 프로그램을 간단하게 만듦
- 추상화가 필요한 이유
	- ex_) 현대와 같은 다른 자동차 브랜드가 추가될수도 있다.
	  이때, 추상화로 '자동차'를 구현해 놓으면 다른 곳의 코드를 수정할 필요 없이 추가로 만들 부분만 새로 생성해 주면 된다.

### 2. 캡슐화(Capsulation)
- 데이터 구조와 데이터를 다루는 방법들을 결합시켜 묶는 것(변수와 함수를 하나로 묶는 것을 뜻함)
- 낮은 결합도를 유지할수 있도록 설계하는 것
- 속성과기능을 정의하는 변수와 메소드를 클래스라는 캡슐에 넣어서 분류하는것
- 장점
	- 재활용에 용이하다
	- 정보 은닉 활용 가능(접근 제어자의 활용)

### 3. 상송(Inheritance)
- 클래스의 속성과 행위를 하위 클래스에 물려주거나 하위 클래스가 상위 클래스의 속성괴 행위를 물려받는것
- 새로운 클래스가 기존의 클래스의 데이터와 연산을 이용할수 있게 하는 기능
- 장점
	- 재사용으로 인한 코드가 줄어든다
	- 범용적인 사용이 가능하다
	- 자료와 메서드의 자유로운 사용및 추가가 가능하다
- 단점
	- 상위 클래스의 변경이 어려워 진다
	- 불필요한 클래스가 증가 할수 있다
	- 상속이 잘못 사용될수 있다

### 4. 다형성
- 하나의 변수명, 함수명이 상황에 따라 다른 의미로 해석될수 있는것
- 어떠한 요소에 여러 개념을 넣어 놓은 것
- 객체 지향 프로그래밍은 하나의 클래스 내부에 같은 이름의 행위를 여러개 정의하거나 
  상위 클래스의 행위를 하위 클래스에서 재정의 가능
- 대표적인 형태
	- 오버라이딩 : 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의 하여 사용
		  -> ==상속받은 메서드의 내용만 변경==
	- 오버 로딩 : 같은 이름의 메서드가 인자의 개수나 자료형에 따라 다른 기능을 하는것
		  -> ==기존에 없던 새로운 메서드 정의==
- ex_) 조소영 <-- 집에서는 "딸", 학교에서는 "조소영 학생", 동아리 에서는 "부회장"

## 객체 지향 프로그래밍의 장점
1. 객체 지향 설계를 통해서 프로그램을 보다 유연하고 변경이 용이하게 만들수 있다
2. 코드의 변경을 최소화, 유지 보수 하는데 유리
	- ex_)컴퓨터 부품을 갈아 끼울때 해당 부품만 쉽게 교체하고 나머지 부품들을 건드리지 않아도 되는 것과 같다
3. 코드의 재사용을 통해 반복적인 코드를 최소화 시키고, 코드를 최대한 간결하게 표현
4. 인간 친화적이고 직관적인 코드를 작성 하기에 용이

==Class : 객체 지향 프로그램의 가장 기본적인 단위 이자 시작점==

- SoftwareSerial.h파일에 정의된 SoftwareSerial클래스의 일부
- 첫번째 라인 : public Stream -> 상속
	- 상속 : 부모 클래스의 특징을 그대로 물려받아 새로운 자식 클래스를 생성하는 방법
- 동일한 특징들을 중복해서 정의할 필요 없이 상속을 통해 정의
	- 클래스 사이의 연관성을 형성해 줄수 있는도구
- 맴버 변수와 맴버 함수는 외부로의 공개 여부에 따라 'private:'과 'public:' 영역에 정의
```C
class SoftwareSerial : public Stream
{
	private:
		unit8_t_receivePin;
		unit8_t_recieveBitMask;
public:
	void begin(long speed);
	bool listen();
	void end();
}
```

- 클래스로 만들어지는 객체는 다른 객체들과 상화작용 하면서 프로그램이 실행되는 동안 존재
- 객체 지향에서 클래스는 추상적인 대상을 가리킴
	- 클래스는 클래스 라는 틀을 이용, 구체적인 객체를 생성한 이후 사용 가능
- 이는 int가 정수형 값에 대한 추상적인 대상 -> 실제 int a;와 같이 변수를 선언한 이후 변수 a에 실제로 ㄱ밧을 대입하고 연산을 수행할수 있는 것과 마찬가지.

# 인터럽트(Interrupt)
- 가로채다 , 방해하다
- 프로그램이 실행되고 있을때, 외부의 어떤 변화에 의해 그 프로그램의 실행이 정지됨, 변환에 대응하는 다른 프로그램이 먼저 실행되는 일.
- ex_) 블루 스크린
	- 원인은 잘 모르겠지만 OS가 실행되는 영역인 커널모드에 치명적인 오류가 발생했을때 인터럽트 발생-> 현재 프로그램 중단 -> 블루스크린
- 아두이노에서는 loop()안의 코드들이 '현재 실행되는 프로그램'임
- 인터럽트는 지정된 핀의 현재 상태가 어떻게 변하는냐에 따라 결정됨.
	-> 인터럽트가 발생했다면 loop()안의 코드 실행이 중단
	-> 인터럽트로 지정된 함수 실행
- 아두이노에서 핀의 의한 인터럽트(외부 인터럽트)는 하드웨어 적으로 구현되어 있기에 지정된 핀이 있다
	- 그러므로 인터럽트를 사용하기 위해 보드별로 지정된 핀을 사용해야 함

# 실습
- Volatile : 휘발성의
	- 인터럽트 함수 안에서 변경되는 전역변수 앞에 붙여야 한다.
- State가 LOW <-> HIGH 토글 됨
- attach Interrupt : 인터럽트 함수(인터럽트를 등록 하겠다는 함수)
	- `attachInterrupt(digitalPin ToInterrupt(interruptPin), blick, CHANGE);`
- 첫번째 값 : 인터럽트 번호 핀(2, or 3)
- 두번째 값 : 인터럽트 걸렸을때 실행 할 함수
- 세번째 값 : 인터럽트가 발생될 조건
	- FALLING : 핀의 상태가 HIGH -> LOW
	- RISING : 핀의 상태가 LOW -> HIGH
	- CHANGE : 핀의 상태가 바뀔 경우
	- LOW: 핀의 상태가LOW일 경우
```C
const byte ledPin = 8;
const byte interruptPin = 2;
vlatile byte state  = LOW;

void setup(){
	pinMode(ledPin, OUTPUT);
	pinMode(interruptPin, INPUT_PULLUP);
	attachInterrupt(digitalPinToInterrupt(interrupPin), blick, CHANGE);
}
void loop(){
	digitalWrite(ledPin, state);
}
void blick(){
	state = !state;
}
```

# 조도 센서란?
- 