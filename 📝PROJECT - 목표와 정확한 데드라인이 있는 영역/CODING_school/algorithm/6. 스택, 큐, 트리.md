# 1.  스택
- 쌓는다
- 가장 마지막 데이터 -> 가장 위에 쌓임
	- ex_) 접시 쌓기, 책더미, 웹브라우저 검색 기록

==주차 관리 시스템==
1. 차량 입차
2. 차량 출차
3. 현재 주차된 차량 보기
4. 메뉴를 선택하세요
- 원소 : 15,20,30,7
- `final int MAX_CAPACITY = 10;` //주차장 최대 크기(정적)
	- final = 무조건 실행되는 코드, (불변성) 초기화된 후 변경 못함
	- MAX_CAPACITY = 프로그램 전체에 같은 값 할당(상수)


## 1. 스택 생성 및 원소 추가
### 스택 생성
- `Stack<Integer> stack  = new Stack<>();`
	- 정수형
- `Stack <String> parkingLot = new Stack>();`
	- 문자열
	- <\~~> : 원소의 데이터 타입 지정 가능

### 스택에 원소 추가
- `stack.push(데이터 값 추가 = 원소);`
- 스택 출력
	- `System.out.println("현재 스택" + stack);`
- 스택의 영역(메모리)

| 구분     | 정적 영역 | 동적영영 |
| ------ | ----- | ---- |
| 메모리 크기 | 고정    | 유동적  |
| 성능     | 빠르다   | 느리다  |
| 유연성    | 제한적   | 유연함  |
- 정적영역 : 메모리 크기 고정(스택 오버플로우에 주의)
- 동적영역 : 메모리 크기를 늘리거나 줄일때

- 정적 스택
	- 장점 : 빠르고 효율적임
	- 단점 : 오버플로우 발생 (크기 초과시)
- 동적 스택
	- 장점 : 필요에 따라 공간이 유동적으로 축소, 확대
	- 단점 : 속도가 느리다(메모리 재할당 하기 때문)

>[!note] 자바 코드에 스택 사용시 필수 Import문
>Import.java.util.Stack; 

```java
Stack<Integer> stack = new Stack<>();

stack.push(15);
stack.push(20);
stack.push(30);
stack.push(7);
System.out.println("현재 스택에 대한 데이터" + stack);
```

### ==1. 스택 동작 과정==
- 시작 과정 : 스택이 주어진다. 스택의 크기는 0일수 있다.
- 동작 선택 : 사용자는 스택에서 수행할 동작 선택
	- 가능한 동작 push, pop, peek, isEmpty
1. push : 스택에서 데이터를 추가(스택 크기 증가, 다시 동작)
2. pop : 스택 제거 후 반환
	1. 스택이 비어있는지 확인.
	2. 비어있지 않으면 최상단 요소 제거
	3. 제거 후 반환
	   ==> 스택 크기 감소 !!
3. peek : 최상단 요소 확인
	1. 스택이 비어있는지 확인
	2. 비어있지 않으면 최상단 요소 반환
		=> 스택 크기는 그대로
4. isEmpty : 스택이 비어있는지 확인

- 스택 : 한쪽으로 데이터를 넣을 수 있는 구조.
	- 자료를 정해진 방향(위->아래)으로 쓸 수 있다.
	- TOP 으로 지정한 곳을 통해서만 접근 가능.
	- "가장 최근 데이터 = 가장 위 데이터"
	- push 사용 -> 데이터 확인 먼저(isEmpty() 사용)
- ex_) stack, 재귀, 피보나치
	- 메모리를 효율적으로 관리 가능

![[Pasted image 20241216090136.png]]

