## 01_소개
### 1.1 프로세서 스케줄링 정책
- 주어진 시간에 시스템이 실행할 프로세스를 선택하는 작업
- 여러 성능 요건의 충족 필요
	- 처리량 최대화
	- 지연시간 최소화
	- 무기한 연기 방지
	- 명시된 데드라인 전에 작업 완료
	- 프로세서 활용도 극대화

## 02_스케쥴링 수준
### 2.1 고수준 스케줄링(long term shceduling)
- HDD에 있는 프로그램을 언제 메인메모리에 올릴지 결정
	- = 시스템이 어떤 작업에 자원을 얻으려고 경쟁하게 해줄지 결정
- 임의의 시간에 시스템에 존재하는 프로세스의 총 수 지정
- 서버등에서 사용
### 2.2 중간 수준 스케쥴링(middle term shceduling)
- 메인 메모리가 꽉 찼을때, 어떤 프로세스를 삭제 시킬지 결정
	- = 어떤 프로세스가 프로세서를 얻으려고 경쟁 할수 있는지 결정
	- 실행중이던 내용을 HDD에 임시 저장
	- Swap - IN : 메모리에 올림
	- Swap - Out : 실행하지 않는 프로그램을 백킹 스토어(HDD)에 저장
- 단기적인 시스템 부하의 높낮이에 따라 결정

### 2.3 저수준 스케줄링(low term shceduling = CPU shceduling)
- 준비 상태에 있는(Ready Queue)곳에서 어떤 프로세스를 먼저 실행시킬지 결정
	-  = 활성화된 프로세스 중 어떤 프로세스에 프로세서를 할당할지 결정
- 우선순위 부여

> 속도 비교 (왼쪽부터 제일 빠름)
> 저수준 > 중간 수준 > 고수준

![[Pasted image 20250419204602.png]]

## 03_선점형 / 비선점형 스케쥴링
### 3.1 선점형 스케쥴링
- 프로세서에서 프로세스가 실행중일때 시스템이 프로세서의 쟁취가 가능
- 우선순위가 높은 프로세스에 대한 응답 시간 향상
- 대화식 시분할 시스템에서 반응 시간 보장
- 여러 프로세스를 메인 메모리에 유지하는것이 필요

### 3.2 비선점형 스케쥴링
- 프로세스가 프로세서를 할당 받으면 작업을 완료하거나 자발적으로 프로세서를 반납할때 까지 프로세서에서 실행 가능
- 중요한 프로세스라도 앞의 프로세스가 완료될때까지 대기
	- 주로 단일 프로세스에서 많이 사용
	- 절대 프로세서를 스틸 할수 없음
- 시분할 시스템과는 상성이 좋지 않다...

## 04_우선순위

### 4.1 정적 우선순위
- 처음에 정해진 우선순위가 고정
- 쉬운 구현
- 낮은 오버헤드
- 환경 변화에 대한 반응이 불가능
- 지연 시간 감소의 어려움

### 4.2 동적 우선순위
- 상황에 따라 우선순위의 변화
- 복잡한 구현
- 높은 오버헤드
- 시스템의 반응성 향상

## 05_스케쥴링 목적
### 5.1 시스템 유형에 따라 다른 목적
- 처리량 최대화
- '수용 할만한' 시간 안에 반응을 보이는 대화식 프로세스의 수 최대화
	- 수용할만한 시간은 그냥 '느리다'는 생각이 안들정도...?
- 자원 활용도 최대화
- 무기한 연기 회피
- 우선순위 강화
- 오버헤드 최소화
- 예측 가능성 보장

### 5.2 대부분의 스케쥴러가 가지는 공통된 목적
- 공평성 : 스케쥴링 규칙이 유사한 프로세스들을 모두 동일하게 대우, 어떤 프로세스도 무기한 연기 X
- 예측 가능성 : 유사한 시스템 실행시에는 주어진 프로세스가 항상 비슷한 시간동안 실행 되어야 함.
	- 특정 프로세스에 대한 실행 시간이 어느 정도 예측이 가능해야 한다.
	- 이유 : **다음 프로세스를 언제 실행 할지 측정**하거나 예측할수 있어야 하기 때문에(안정적으로 동작)
- 규모 확장성 : 시스템에 현재 프로세스가 많은 프로세스가 돌아가도 스케쥴러의 성능이 점진적으로 감소해야 한다.

## 06_스케줄링 기준
### 6.1 프로세서 중심 프로세스 
- 시스템이 할당하는 프로세서 시간을 모두 사용

### 6.2 입출력 중심 프로세스
- 입출력 요청을 하기 전에 프로세서를 잠시 사용 -> 곧 반납
- I/O 요청을 하는 프로세스

### 6.3 배치 프로세스(일괄)
- 사용자와의 상호작용 없이 수행할수 있는 작업을 포함

### 6.4 대화식 프로세스
- 빈번한 사용자 입력을 요구
- ex_) "진짜 프로그램을 삭제 하시겠습니까? \[YES] \[NO]" 형식의 창 등등

> 빠름 정도 (왼쪽부터 빠름)
> 입출력 > 프로세서 > 배치

>[!note] 스케줄링 순서
>1. I/O burst(요청)
>2. 블락
>3. CPU burst
>4. Time Out
> -> 1~4 과정 반복

![[Pasted image 20250425232430.png]]

## 07_스케줄링 알고리즘
- 각 프로세스가 언제, 얼마동안 실행할지 결정
- 여러 요인에 따라 고려
	- 선점/비선점 여부
	- 우선순위
	- 실행 시간
	- 완료 시까지 남은 시간
	- 공평성
	- 기타 프로세스 특성

### 7.1 선입 선출 스케줄링(First-In-First-Out(FIFO) Scheduling)
- 가장 간단한 스케줄링 알고리즘
- 준비 큐(Ready Queue)에 도착한 순서에 의해 프로세스 할당
- 비선점형
- 현대 시스템에서 주요 스케줄링 정책으로 사용하는 일 거의X

![[Pasted image 20250425232824.png]]

![[Pasted image 20250425232840.png]]

![[Pasted image 20250425232918.png]]

### 7.2 라운드 로빈 스케줄링(Round-Robin(RR) scheduling)
- 프로세스를 FIFO 순서로 디스패치
- 타임 슬라이스(퀀텀) 라는 제한된 프로세서 시간 안에서만 수행
- 선점형
- 대기 프로세스를 메인 메모리에 유지 -> 선점에 의해 발생하는 오버헤드 최소화
- 주로 복잡한 스케줄링 알고리즘 내부에서 사용

![[Pasted image 20250425233120.png]]

####  이기적인 라운드로빈 스케줄링(Selfish Round-Robin(SRR) Scheduling)
- 에이징 기법 사용
	- 시간이 지남에 따라 프로세스의 우선순위를 높이는 기법
 