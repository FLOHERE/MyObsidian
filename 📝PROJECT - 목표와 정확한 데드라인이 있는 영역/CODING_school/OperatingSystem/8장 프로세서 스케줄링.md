## 01_소개
### 1.1 프로세서 스케줄링 정책
- 주어진 시간에 시스템이 실행할 프로세스를 선택하는 작업
- 여러 성능 요건의 충족 필요
	- 처리량 최대화
	- 지연시간 최소화
	- 무기한 연기 방지
	- 명시된 데드라인 전에 작업 완료
	- 프로세서 활용도 극대화

## 02_스케쥴링 수준
### 2.1 고수준 스케줄링(long term shceduling)
- HDD에 있는 프로그램을 언제 메인메모리에 올릴지 결정
	- = 시스템이 어떤 작업에 자원을 얻으려고 경쟁하게 해줄지 결정
- 임의의 시간에 시스템에 존재하는 프로세스의 총 수 지정
- 서버등에서 사용
### 2.2 중간 수준 스케쥴링(middle term shceduling)
- 메인 메모리가 꽉 찼을때, 어떤 프로세스를 삭제 시킬지 결정
	- = 어떤 프로세스가 프로세서를 얻으려고 경쟁 할수 있는지 결정
	- 실행중이던 내용을 HDD에 임시 저장
	- Swap - IN : 메모리에 올림
	- Swap - Out : 실행하지 않는 프로그램을 백킹 스토어(HDD)에 저장
- 단기적인 시스템 부하의 높낮이에 따라 결정

### 2.3 저수준 스케줄링(low term shceduling = CPU shceduling)
- 준비 상태에 있는(Ready Queue)곳에서 어떤 프로세스를 먼저 실행시킬지 결정
	-  = 활성화된 프로세스 중 어떤 프로세스에 프로세서를 할당할지 결정
- 우선순위 부여

> 속도 비교 (왼쪽부터 제일 빠름)
> 저수준 > 중간 수준 > 고수준

![[Pasted image 20250419204602.png]]

## 03_선점형 / 비선점형 스케쥴링
### 3.1 선점형 스케쥴링
- 프로세서에서 프로세스가 실행중일때 시스템이 프로세서의 쟁취가 가능
- 우선순위가 높은 프로세스에 대한 응답 시간 향상
- 대화식 시분할 시스템에서 반응 시간 보장
- 여러 프로세스를 메인 메모리에 유지하는것이 필요

### 3.2 비선점형 스케쥴링
- 프로세스가 프로세서를 할당 받으면 작업을 완료하거나 자발적으로 프로세서를 반납할때 까지 프로세서에서 실행 가능
- 중요한 프로세스라도 앞의 프로세스가 완료될때까지 대기
	- 주로 단일 프로세스에서 많이 사용
	- 절대 프로세서를 스틸 할수 없음
- 시분할 시스템과는 상성이 좋지 않다...

## 04_우선순위

### 4.1 정적 우선순위
- 처음에 정해진 우선순위가 고정
- 쉬운 구현
- 낮은 오버헤드
- 환경 변화에 대한 반응이 불가능
- 지연 시간 감소의 어려움

### 4.2 동적 우선순위
- 상황에 따라 우선순위의 변화
- 복잡한 구현
- 높은 오버헤드
- 시스템의 반응성 향상

## 05_스케쥴링 목적
### 5.1 시스템 유형에 따라 다른 목적
- 처리량 최대화
- '수용 할만한' 시간 안에 반응을 보이는 대화식 프로세스의 수 최대화
	- 수용할만한 시간은 그냥 '느리다'는 생각이 안들정도...?
- 자원 활용도 최대화
- 무기한 연기 회피
- 우선순위 강화
- 오버헤드 최소화
- 예측 가능성 보장

### 5.2 대부분의 스케쥴러가 가지는 공통된 목적
- 공평성 : 스케쥴링 규칙이 유사한 프로세스들을 모두 동일하게 대우, 어떤 프로세스도 무기한 연기 X
- 예측 가능성 : 유사한 시스템 실행시에는 주어진 프로세스가 항상 비슷한 시간동안 실행 되어야 함.
	- 특정 프로세스에 대한 실행 시간이 어느 정도 예측이 가능해야 한다.
	- 이유 : **다음 프로세스를 언제 실행 할지 측정**하거나 예측할수 있어야 하기 때문에(안정적으로 동작)
- 규모 확장성 : 시스템에 현재 프로세스가 많은 프로세스가 돌아가도 스케쥴러의 성능이 점진적으로 감소해야 한다.

## 06_스케줄링 기준
### 6.1 프로세서 중심 프로세스 
- 시스템이 할당하는 프로세서 시간을 모두 사용

### 6.2 입출력 중심 프로세스
- 입출력 요청을 하기 전에 프로세서를 잠시 사용 -> 곧 반납
- I/O 요청을 하는 프로세스

### 6.3 배치 프로세스(일괄)
- 사용자와의 상호작용 없이 수행할수 있는 작업을 포함

### 6.4 대화식 프로세스
- 빈번한 사용자 입력을 요구
- ex_) "진짜 프로그램을 삭제 하시겠습니까? \[YES] \[NO]" 형식의 창 등등

> 빠름 정도 (왼쪽부터 빠름)
> 입출력 > 프로세서 > 배치

>[!note] 스케줄링 순서
>1. I/O burst(요청)
>2. 블락
>3. CPU burst
>4. Time Out
> -> 1~4 과정 반복

![[Pasted image 20250425232430.png]]

## 07_스케줄링 알고리즘
- 각 프로세스가 언제, 얼마동안 실행할지 결정
- 여러 요인에 따라 고려
	- 선점/비선점 여부
	- 우선순위
	- 실행 시간
	- 완료 시까지 남은 시간
	- 공평성
	- 기타 프로세스 특성

### 7.1 선입 선출 스케줄링(First-In-First-Out(FIFO) Scheduling)
- 가장 간단한 스케줄링 알고리즘
- 준비 큐(Ready Queue)에 도착한 순서에 의해 프로세스 할당
- 비선점형
- 현대 시스템에서 주요 스케줄링 정책으로 사용하는 일 거의X

![[Pasted image 20250425232824.png]]

![[Pasted image 20250425232840.png]]

![[Pasted image 20250425232918.png]]

### 7.2 라운드 로빈 스케줄링(Round-Robin(RR) scheduling)
- 프로세스를 FIFO 순서로 디스패치
- 타임 슬라이스(퀀텀) 라는 제한된 프로세서 시간 안에서만 수행
- 선점형
- 대기 프로세스를 메인 메모리에 유지 -> 선점에 의해 발생하는 오버헤드 최소화
- 주로 복잡한 스케줄링 알고리즘 내부에서 사용

![[Pasted image 20250425233120.png]]

####  이기적인 라운드로빈 스케줄링(Selfish Round-Robin(SRR) Scheduling)
- 에이징 기법 사용
	- 시간이 지남에 따라 프로세스의 우선순위를 높이는 기법
- 먼저 온 오래된 프로세스를 선호(FIFO)
- 2개의 큐
	- 보류 큐
	- 활성 큐
- 퀀텀 크기
	- 매우 큰 퀀텀 크기
		- 프로세스가 작업을 마칠 정도의 크기
		- FIFO 방식처럼 동작
	- 매우 작은 퀀텀 크기
		- 프로세서 사이클의 대부분을 문맥 전환 오버헤드에 사용
			1. 현재 내용을 저장 
			2. 이전 작업을 HDD에서 불러옴 
			3. 퀀텀이 작으므로 컨택 스위칭 과정에서 많은 오버헤드 발생

![[Pasted image 20250425235404.png]]

![[Pasted image 20250425235500.png]]

### 7.3 최단 프로세스 우선 스케줄링(Shortest-Process-First(SPF) Scheduling)
- 완료 시까지 실행 시간이 가장짧을 것으로 예상하는 프로세스 선택
- FIFO 보다는 평균 대기 시간 감소
	- 대기하는 프로세스의 수 줄임
	- 긴 프로세스 뒤에 대기하는 프로세스 수 최소화
- 변량이 큰 대기 시간
- 비선점형
- 부정확한 예상 실행 시간
- 부적절한 반응 시간을 보장해야 하는 환경에서는 부적합
	- 실행시간이 짧은 프로세스 우선이기 때문.

![[Pasted image 20250426000011.png]]

### 7.4 최고 응답률 우선 스케줄링(HIghest-Response-Ratio-Next(HRRN) Scheduling)
- SPF의 약점을 보강
- 비선점형
- 대기 시간 고려 -> 스케줄링
- 무기한 연기 방지
	- 실행 시간이 짧은 애들이 먼저 하기 때문에 뒷단 애들은 기다려야 함.
- $우선순위 = \frac{대기시간 + 서비스시간}{서비스시간}$

### 7.5 최소 잔여 시간 스케줄링(Shortest-Remaining-Time(SRT) Scheduling)
- SPF의 선점형 버전
- 실행 시간이 짧은 프로세스가 프로세서를 선점
- 실행중인 프로세스의 경과 시간에 관한 정보의 유지가 필요
- 실행 시간이 긴 프로세스는 SPF보다 대기 시간이 길어질수 있음.
	- 대기시간의 변량이 크다.
- 선점 오버헤드에 의한 성능 저하
	- 실행 중인 프로세스가 거의 완료되어 갈때, 예상 서비스 시간이 '아주 짧은 프로세스'가 도착하는 경우
	- 실행중인 프로세스보다 실행 예상 시간이 짧다. but 차이가 아주 적은 경우

![[Pasted image 20250426000625.png]]

### 7.6 다수준 피드백 큐
- 서로 다른 특징의 프로세스는 다른 스케줄링 방법을 요구
	- 프로세스가 행동 양식을 확립할 기회를 얻지 못한 경우
		- 정확한 프로세서 시간을 결정하지 X
	- 짧은 프로세스, 입출력 중심 프로세스 -> 프로세스 중심 프로세스 이전에 실행되는것 선호.

- 다수준 피드백 큐
	- 새로운 프로세스는 가장 높은 큐에 들어감 (낮은 큐의 프로세스보다 높은 우선순위 획득)
		- 실행중인 프로세스도 더 높은 큐에 도착하는 프로세스에 의해 선점 당함.
	- 퀀텀을 모두 소비 -> 한 수준 낮은 큐로 이동
		- 짧은 프로세스와 입출력 중심 프로세스에게 높은 우선순위 활당
		- 실행 시간이 긴 프로세스는 짧은 프로세스나 입출력 중심 프로세스의 종료 후 실행
	- 라운드 로빈 방식 : 가장 낮은 수준 큐
	- FIFO 방식 : 나머지 수준의 큐
	- 프로세스의 변화에 대해 적절한 반응 필요
	- 적응 메커니즘의 본보기
		- 시스템의 변화에 민감하게 적응, 시스템의 반응성 향상

![[Pasted image 20250426001825.png]]

![[Pasted image 20250426001857.png]]

### 7.7 공평 분배 스케줄링(Fair Share Scheduling(FSS))
- 어떤 사용자 그룹은 다른 그룹보다 중요함
	- ex_) 수석 연구원 그룹 > 보조 연구원그룹
- 낮은 중요도의 그룹이 자원을 독점하는것 방지
- 자원을 다양한 공평분배 그룹별로 배치
- 상대적인 필요에 따라 한 공평 분배 그룹이 사용하지 않는 자원을 다른 공평 분배 그룹에 할당

![[Pasted image 20250426002106.png]]

![[Pasted image 20250426002211.png]]

## 08_데드라인 스케줄링
- 프로세스들이 특정 시간안에 마치도록 스케줄링
- 데드라인을 놓침 -> 프로세스 가치 낮아짐 or 사라짐
	- 
- 복잡한 스케줄링
	- 정확한 자원 요구량을 미리 제시하는것이 필요
	- 다른 사용자들에 대한 서비스에 심각한 악영향을 미치는 것 방지
	- 데드라인이 될때까지 자원 요구량을 철저하게 계획
	- 상당한 오버헤드 초래