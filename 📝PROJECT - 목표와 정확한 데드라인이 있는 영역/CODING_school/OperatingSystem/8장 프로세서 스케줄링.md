## 01_소개
### 1.1 프로세서 스케줄링 정책
- 주어진 시간에 시스템이 실행할 프로세스를 선택하는 작업
- 여러 성능 요건의 충족 필요
	- 처리량 최대화
	- 지연시간 최소화
	- 무기한 연기 방지
	- 명시된 데드라인 전에 작업 완료
	- 프로세서 활용도 극대화

## 02_스케쥴링 수준
### 2.1 고수준 스케줄링(long term shceduling)
- HDD에 있는 프로그램을 언제 메인메모리에 올릴지 결정
	- = 시스템이 어떤 작업에 자원을 얻으려고 경쟁하게 해줄지 결정
- 임의의 시간에 시스템에 존재하는 프로세스의 총 수 지정
- 서버등에서 사용
### 2.2 중간 수준 스케쥴링(middle term shceduling)
- 메인 메모리가 꽉 찼을때, 어떤 프로세스를 삭제 시킬지 결정
	- = 어떤 프로세스가 프로세서를 얻으려고 경쟁 할수 있는지 결정
	- 실행중이던 내용을 HDD에 임시 저장
	- Swap - IN : 메모리에 올림
	- Swap - Out : 실행하지 않는 프로그램을 백킹 스토어(HDD)에 저장
- 단기적인 시스템 부하의 높낮이에 따라 결정

### 2.3 저수준 스케줄링(low term shceduling = CPU shceduling)
- 준비 상태에 있는(Ready Queue)곳에서 어떤 프로세스를 먼저 실행시킬지 결정
	-  = 활성화된 프로세스 중 어떤 프로세스에 프로세서를 할당알지 결정
- 우선순위 부여

> 속도 비교 (왼쪽부터 제일 빠름)
> 저수준 > 중간 수준 > 고수준

![[Pasted image 20250419204602.png]]

## 03_선점형 / 비선점형 스케쥴링
### 3.1 선점형 스케쥴링
- 프로세서에서 프로세스가 실행중일때 시스템이 프로세서의 쟁취가 가능
- 우선순위가 높은 프로세스에 대한 응답 시간 향상
- 대화식 시분할 시스템에서 반응 시간 보장
- 여러 프로세스를 메인 메모리에 유지하는것이 필요

### 3.2 비선점형 스케쥴링
- 프로세스가 프로세서를 할당 받으면 작업을 완료하거나 자발적으로 프로세서를 반납할때 까지 프로세서에서 실행 가능
- 중요한 프로세스라도 앞의 프로세스가 완료될때까지 대기
	- 주로 단일 프로세스에서 많이 사용
	- 절대 프로세서를 스틸 할수 없음
- 시분할 시스템과는 상성이 좋지 않다...

## 04_우선순위

### 4.1 정적 우선순위
- 처음에 정해진 우선순위가 고정
- 쉬운 구현
- 낮은 오버헤드
- 환경 변화에 대한 반응이 불가능
- 지연 시간 감소의 어려움

### 4.2 동적 우선순위
- 상황에 따라 우선순위의 변화
- 복잡한 구현
- 높은 오버헤드
- 시스템의 반응성 향상

## 05_스케쥴링 목적
### 5.1 시스템 유형에 따라 다른 목적
- 처리량 최대화
- '수용 할만한' 시간 안에 반응을 보이는 대화식 프로세스의 수 최대화
	- 수용할만한 시간은 그냥 '느리다'는 생각이 안들정도...?
- 자원 활용도 최대화
- 무기한 연기 회피
- 우선순위 강화
- 오버헤드 최소화
- 예측 가능성 보장

### 5.2 대부분의 스케쥴러가 가지는 공통된 목적
- 공평성 : 스케쥴링 규칙이 유사한 프로세스들을 모두 동일하게 대우, 어떤 프로세스도 무기한 연기 X
- 예측 가능성 : 유사한 시스템 실행시에는 주어진 프로세스가 항상 비슷한 시간동안 실행 되어야 함.
	- 특정 프로세스에 대한 실행 시간이 어느 정도 예측이 가능해야 한다.
	- 이유 : **다음 프로세스를 언제 실행 할지 측정**하거나 예측할수 있어야 하기 때문에(안정적으로 동작)
- 규모 확장성 : 시스템에 현재 프로세스가 많은 프로세스가 돌아가도 스케쥴러의 성능이 점진적으로 감소해야 한다.

