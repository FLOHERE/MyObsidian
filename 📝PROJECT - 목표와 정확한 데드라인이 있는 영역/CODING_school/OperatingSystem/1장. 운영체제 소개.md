## 01_소개
- 수십년동안 빠르게 진화해온 컴퓨터 분야
- 사용자 워크스테이션 BIPS(Billions of Instructions per second)의 처리속도
- 일상 생활의 모든 영역에서 컴퓨터 사용
	- 운영체제의 역할과 책임 변화 
		- 문서, 게임, 음악, 비디오 , 자산관리
		- 노트북, 휴대폰 등등
- 이 책에서 다루는 내용
	- 우녕체제의 원리 
	- 운영체제의 구조와 책임
	- 운영체제 설계 시 고려사항
	- 분산 컴퓨팅과 관련하여 운영체제 설계 이슈

## 02_운영체제란 무엇인가
- 운영체제 : 하드웨어를 제어하기 위한 소프트웨어
	- 현재 : 응용 소프트웨어 실행
		- 하드웨어 사용 효율을 늘리기 위해 응용 프로그램과 하드웨어 분리 -> 안전하고 효율
- 응용프로그램이 하드웨어와 상호 작요할수 있도록 해주는 소프트웨어
- 운영체제 = 자원관리자
	- 하드웨어
		- 프로세서
		- 메모리
		- 입출력장치
		- 통신 장치
	- 소프트웨어

## 03_초기 역사(1940~1950)
- 1940 : 초기 디지털 컴퓨터는 운영체제를 포함하지 않음
- 1950 : 한번에 한가지 작업만 수행, 단일 스트림 배치 시스템(일괄처리 시스템), 시스템 자원 직접 제어, 사용 효율 증가를 위해 자겁 사이의 이동을 원할하게 하는 기술 사용

## 04_1960년대
- 배치 처리 시스템
>배치 처리 : 데이터를 모아놨다가 한번에 처리하는 시스템

### 4.1멀티 프로그래밍
- 목표 : 자원 공유
	- 운영체제는 여러 작업을 동시에 처리하는 방향으로 발전
- 1964년 IBM System/360 발표
	- 360 : 전 세계적으로 사용 가능
### 4.2 대화식 사용자(interactive user) 
- 프로그램이 어떤일을 수행할때 사용자와 상호작용함
	- ex_) 프로그램창의 예/아니오

### 4.3 시분할 시스템
-  대화식 컴퓨팅 지원, 프로그램과 데이터 공유
	- MIT의 CTSS, IBM의 TSS, IBM Cabridge Scientific Center의 CP/CMS 등등...
- 자원을 나눠서 사용하는 시스템
	- 프로그램의 동시 실행 = 아주 작은 시간으로 나눠서 여러 프로세스가 공유해서 쓰는것.
- 특정 작업이 주변 장치 사용시 다른 작업에서 프로세서 사용 가능하도록 함 => 자원 활용도 높음.

>[!note] 프로세스 VS 프로세서
>- 프로세스(현재 실행중인 프로그램) : 애플리케이션 실행을 위한 독립적인 가상공간
>- 프로세서(CPU) : 컴퓨터에서 명령어 실행, 데이터 처리

## 05_1970년대
### 5.1 멀티모드 멀티 프로그래밍 시스템
- 배치처리
- 시분할
- 실시간 응용 프로그램

### 5.2 TCP/IP 통신 표준 활성화
- 이더넷(표준)의 등장 -> 근거리 통신망 환경 발전
- 보안 문제 등장
	- 암호 작성/해독 기술 주목

### 5.3 운영체제가 네트워크와 보안을 아우르는 수준으로 발전
- 상업적 요구 충족할 마큼 개선

## 06_1980년대
### 6.1 개인용 컴퓨터와 워크스테이션의 시대
- 마이크로프로세스 : 소형 컴퓨터의 중앙 처리 장치 기술
- 소프트웨어의 발전
	- 스프레드 시트, 워드 등등
- 그래픽 사용자 인터페이스(GUI) 등장

### 6.2 네트워크 기술의 발전
- 컴퓨터간 정보 전송 경제적, 현실적 수준의 전환
- 클라이언트, 서버 컴퓨팅 모델의 널리 보급
	- 분산 컴퓨팅 환경 제공

### 6.3 소프트웨어 공학 분야의 발전
- 코드의 재사용 등등...

### 07_인터넷과 월드 와이드 웹의 역사
- ARPA(Advanced Research Project Agency)
	- ARPAnet 구현
	- 오늘날 인터넷의 시조
	- 빠르고 쉬운 통신 능력
	- 중앙 집중적인 통제 없이 작동
		- 네트워크의 일부가 고장나도 남은 부분은 다른 경로로 전송
- [[TCP/IP]] 프로토콜
	- 오류없는 전송 보장
- 상업용 목적으로 활용
	- 대역폭 증가
	- 하드웨어와 통신 비용 감소
- World Wide Web(WWW)
	- 사용자는 모든 주제에 대해 멀티미디어 기반 문서 조회
	- 1989년 CERN에서 하이퍼링크 기반 문서 공유 방법 개발 시작

## 08_1990년대
### 8.1 1990년대 특성
- 하드웨어 성능의 기하급수적 발전
	- 프로세싱 파워, 저장공간 증가
- 우러드 와이드 웹의 탄생 -> 분산 컴퓨팅의 증가
	- 분산 컴퓨팅 : 여러 컴퓨터가 네트워크를 통해 서로 협력하여 처리 작업을 수행하는 컴퓨팅 모델
	- 자원의 사용 확대 및 효율 향상
	- 네트워크 속도가 컴퓨터의 처리 속도에 미치지 못한 한계
- Microsoft의 성장
	- windows 운영체제 
	- 사용자 친화적 인터페이스
	- 데스크탑 운영체제 잠식
	- 기업용 운영체제 Window NT 출시
- 객체 기술
	- 객체의 구성 요소
		1. 변수(스테이트)
		2. 메서드(액션)
	- 객체 지향 프로그램의 등장 -> 컴포넌트의 재사용 가능 -> 개발 시간 단축
	- 객체 지향 운영체제 등장 -> 유지보수와 확장 용이

>[!note] 컴포넌트란?
>프로그램의 기능을 구현하는 독립적인 모듈.
>독립적인 기능으지만 전체 시스템의 일부이다.(전체적인 작업 수행)
>- ex_) 자바의 class, HTML의 버튼요소, 폼요소 등

- 오픈소스 운동
	- 리눅스, 아파치 등...

## 09_2000년 이후
- 미들웨어 : 네트워크를 통해 독립적인 응용 프로그램을 서로 연결하는 소프트웨어
- 웹 서비스 
	- 분산 컴퓨팅으로 전환 촉진
- 멀티 프로세스와 네트워크 아키텍쳐
	- 멀티 프로세스란? : 여러개의 프로그램을 동시에 실행하는것.
	- 새로운 하드웨어와 소프트웨어 설계 기술 개발 기회 제공
- 고도 병렬성(massive parallelism)
	- 프로세서를 다수 보유해 여러 독립적인 계산으로 병렬로 수행
- 운영체제 인터페이스 표준화
	- 다양한 프로그램을 지원, 사용 용이

## 10_응용 프로그램 기반
- IBM 개인용 컴퓨터는 거대한 소프트웨어 산업을 활성화 
	- ISV(Independent software vendors) DOS에서 동작하는 IBM PC용 응용 발표
- 응용 프로그램 기반
	- 운영체제는 응용 소프트웨어 개발자들의 _메모리관리 입출력 회선 관리 부담 해소_
		- API 제공으로 하드웨어 조작을 간단히 해결
		- 리소스 보호를 위해 System Call 사용

>[!note] System Call
>운영체제에게 컴퓨터의 하드웨어 제어를 부탁하는것
>
>- ex_) print 함수 사용

- 응용프로그램 개발자는 특정 루틴만을 호출
	- 커널안 하드웨어에 조작시 운영체제에 요청

![[Pasted image 20250418102741.png]]

## 11_운영체제 환경

### 11.1 범용 컴퓨터
- 대용량 메모리 + 디스크 + 고속 프로세서 + 주변 장치로 구성
- 개인용 컴퓨터 or 워크스테이션으로 사용
- 고성능 하드웨어를 갖춘 고사양 웹 서버와 데이터베이스 서버에 적용 가능
- 대용량 메모리와 특수 목적 하드웨어, 여러 프로세스를 지원

### 11.2임베디드 시스템
- 소형 기기에 기능을 제공하는 특화된 소규모 자원(ex_휴대폰, PDA 같은...)
- 효율적인 자원관리 요구
- 적은 코드로 서비스 제공
- 전력관리
- 사용자 친화적 인터페이스 제공

### 11.3 ==실시간 시스템==
- 정해진 시간 안에 특정 작업 완료
	- 소프트 실시간 시스템 : 우선순위가 높아도 반드시 그 시간에 처리 하지 않아도 된다.
		- ex_) VOD
	- 하드 실시간 시스템 : 한가지 일이라도 제시간에 되지 않으면 안되는 시스템이다.
		- ex_) 미사일 , 항공 등등

### 11.4 가상 머신
- 컴퓨터를 소프트웨어로 추상화
- 가상머신 운영체제
	- 가상머신에 의해 제공되는 자원관리
- 가상머신의 응용프로그램
	- 여러 운영체제의 인스턴스를 동시에 실행 가능하도록 허용
	- 에뮬레이션
		- 시스템에 존재하지 않는 하드웨어나 소프트웨어 기능 흉내
	- 여러 사용자가 하드웨어 공유
		- 소프트웨어 이식성 향상
	- 가상머신
		- JVM
		- VMware

![[Pasted image 20250418103908.png]]

## 12_운영체제의 구성 요소와 목표
### 12.1 ==운영체제의 핵심 구성 요소==
- 프로세스 스케줄러 : 프로세스 관리
- 메모리 관리자 : 프로세스에 메모리를 할당하는 시점이나 방식
	- 메인 메모리 가득 찼을떄 어떤 방식으로 처리할지 결정
- 입출력 관리자 : 하드웨어 장치들과 연동 -> 입출력 요청
- 프로세스간 통신 관리자 : 프로세스끼리 통신함.
	- 프로세스 : HDD -> 클릭 -> 프로그램이 메모리로 올라간 순간
- 파일 시스템 관리자 : 저장 장치에 있는 이름있는 데이터의 목록을 조직화 한것.
	- 해당 데이터에 접근할수 있도록 인터페이스를 제공.

### ==12.2 운영체제의 목표==
1. _효율성_
	- 처리량은 높지만 처리 시간은 작아야 한다.
2. _견고함_
	- 장애 내구성, 신뢰성, 하드웨어 때문에 망가지면 안된다.(오류, 버그가 없어야 한다.)
3. _규모 확장성_
	- 자원 추가 후 바로 사용 가능, 리소스가 쉽게 확장 가능해야 함.
4. _확장성_
	- 새로운 기술에 잘 적응
5. 이식성
	- 다양한 하드웨어 구성에 동작할수 있게 설계
6. 보안
	- 사용자나 소프트웨어가 허가 받지 않은 서비스나 시스템 자원에 접근하는 일 예방
7. 상호 작용성
8. 사용성
	- 많은 사용자 기반을 지원할수 있는 역량이 있는 시스템
	  => 사용하기 쉬운 인터페이스 제공
	- ex_)리눅스, win, mac....

>[!note] 리소스란?
>메모리, 입출력장치, HDD, CPU 등 컴퓨터 자원을 말함

## 13_운영체제 아키텍쳐
- 현대 운영체제는 복잡
	- 다양한 서비스 제공
	- 다양한 사드웨어와 소프트웨어 지원
	- 운영체제의 구성 요소의 실행 권한을 지정하여 복잡성 해결
		- 모놀리식 커널 : 운영체제의 모든 요소 포함
		- 마이크로 커널 : 필요 구성 요소만 포함

### 13.1 모놀리식 아키텍쳐(Monolithic Architecture)
- 모든 컴포넌트 커널에 포함
- 호출 기능만으로 다른 구성 요소와 통신 가능
- 컴퓨터 시스템에 제한 없이 접근
- 높은 성능
- 오류나 악성 코드에 취약

![[Pasted image 20250418105625.png]]

### 13.2 계층적 아키텍쳐
- 유사한 기능을 수행하는 요소들을 그룹으로 묶어 계층 구분 -> 계층적 접근법
- 각 계층은 바로 상위 또는 하위 계층과 상호 작용
- 하위 계층은 구체적인 구현 숨기고 인터페이스만 제공 -> 작업 수행등은 숨김
- 운영체제의 구조화와 일관성 부여
- 소프트웨어 검증과 디버깅 및 수정 과정 간편
- 단점 
	- 사용자 프로세스 요청 수행시 많은 계층통과 필요
	- 커널에 비하면 성능이 떨어진다.
	- 오류 , 악성 코드에 민감하다.
- ex_) win xp, Linux....

![[Pasted image 20250418110223.png]]

### 13.3 마이크로 커널 아키텍쳐
- 소수의 서비스만 제공
	- 커널 규모 감소, 규모 확장성 향상
- 저수준 메모리 관리, 프로세스간 통신, 프로세스간 협력을 위한 동기화 기능
- 프로세스 관리, 네트워킹, 파일 시스템 상호작용과 장치 관리 등 대부분의 운영체제의 구성 요소
  -> 낮은 수준의 권한으로 커널외부에서 실행
- 모듈화 정도가 높아 확장성, 이식성, 규모 확장성 향상
- 모듈간의 통신이 많아 성능 감소 우려
- 한 두군데 오류가 생겨도 운영체제의 전체 시스템이 멈추지는 않는다.

>[!note] 내가 아는 마이크로 커널 아키텍쳐 OS의 예시
>Rabbit OS : L4 마이크로 커널 위에 다양한 서비스를 유저 모드에서 돌리는 형식.
>고성능 마이크로커널 설계를 목표로 한 OS임.


### 13.4 네트워크 운영체제와 분산 운영체제
#### 1. 네트워크 운영체제
- 네트워크에 있는 다른 컴퓨터의 자원에 접근 가능
- 네트워크 파일 시스템
	- 네트워크 프로토콜 사용 -> 파일, 프로세서 시간과 같은 자원 요청, 서버는 해당 자원을 통해 응답
	- ex_) CMU의 Andrew and Coda

#### 2. 분산 운영체제
- 한대 이상의 컴퓨터에 있는 자원을 관리하는 특별한 운영체제
- 구현 복잡
- 프로세스가 공유 데이터에 접근하기 때문에 복잡한 알고리즘 요구

>[!note] 분산 시스템
>여러 컴퓨터 -> 강력한 컴퓨터 한대 처럼 모이게 함.
>네트워크 어느곳에 위치하던 시스템들에 있는 모든 자원 접근

![[Pasted image 20250418211403.png]]

![[Pasted image 20250418211430.png]]

>[!note] 교수님의 질문
>1. 멀티 프로그래밍이란 : 프로그램을 한번에 하나씩 돌리면 CPU 낭비다. CPU를 최대한 여러 프로그램들을 메모리에 올려서 시간 공유 -> 나눠서 쓴다.(동시에 씀)
>2. [[TCP/IP]] vs [[UDP]]
>   : TCP/IP는 신뢰 가능, UDP는 신뢰 x, but 실시간 거쳐가는 라우터가 바뀔수도 있다.(패킷 손실 우려)

