
## 01_소개
- 컴퓨터는 동시에 여러 기능을 수행
	- ex_) 프로그램을 컴파일 -> 파일을 프린터에 보냄 -> 웹페이지를 화면에 보여줌 + 이메일 받고 + 비디오 틀기(세개를 동시 진행)
	- 프로세스는 시스템을 동작시키고 동시에 수행되는 많은 활동을 관리
	- 프로세스는 프로세스 상태(Process state)를 변화
	- 운영체제는 프로세스 생성, 종료 , 일시정지, 재시작 , 깨우기 등과 같은 프로세스가 서비스 할때 수행하는 다양한 연산 제공

![[Pasted image 20250419124404.png]]

![[프로세스 상태.canvas]]


### 1.1 프로세스 정의 
- **실행중인 프로그램(Program in execution)**
1. 텍스트 영역(Text region)
	- 프로세서가 실행하는 코드를 저장하는 영역
2. 데이터 영역(Data region)
	- 데이터 영역 + 힙영역
		- 데이터 영역 : 변수들을 저장하는 영역
		- 힙 영역 : 프로세스가 실행중에 사용하려고 동적으로 할당받은 메모리 공간
3. 스택 영역(Stack region)
	- 함수 내 지역변수
	- 호출된 프로시저용으로 지역 변수와 명령어들을 저장하는 공간
	- 프로세스 중첩, 프로시저 호출 할수록 증가, 호출된 프로시저 수행을 마치고 반환할때마다 줄어듦

## 02_프로세스 상태 : 프로세스 생명 주기

### 2.1 프로세스 생명주기 동안의 구분된 프로세스 상태(Process state)
#### 실행 상태(running state)
- 프로세스가 프로세서에서 실행 중

#### 준비 상태(Running state)
- 프로세스가 프로세서에서 실행 가능
- 특정 이벤트나 조건이 발생할때까지 대기

#### 블록 상태(Block State)
- 프로세스가 작업을 진행하기 앞서 특정 이벤트 발생을 대기(실행 X)
	- 사용자 프로세스가 스스로 일으키는 상태 전의

### 2.2 준비 리스트(Ready list)와 블록 리스트(blocked list)
#### 준비 리스트(Ready Queue)
- 우선순위 정보를 포함
- 리스트에서 우선순위가 가장 높은 첫번째 프로세스가 프로세서를 할당
- 큐의 특성상 순서대로 실행된다.(선입선출)

#### 블록 리스트
- 블록된 프로세스가 기다리는 이벤트가 발생하는 순서로 블록 해제
  -> 순서가 없다. (우선순위에 따라 블록 해제X)

>[!note] 단일 프로세서 시스템
>한번에 한 프로세서만 실행 가능 but 준비 상태(or 블록상태)에서는 프로세스가 여러개 존재 가능

## 03_프로세스 관리
### 3.1 운영체제는 프로세스에 기본적인 서비스 수행
- 프로세스 생성(create)
- 프로세스 소멸(dstroy)
- 프로세스 일시 정지(suspend)
- 프로세스 재시작(resume)
- 프로세스 우선순위 변경(change priority)
- 프로세스 블록(block)
- 프로세스 깨우기(wake up)
- 프로세스 디스패치(dispatch)
	- 프로세스 상태를 중지 상태 -> 실행상태로 바꾸는것
- Intercrosses communication(IPC)
	- 프로세스끼리 의사 소통

>[!note] 디스패칭과 디스패처
>- 디스패칭 : 준비 리스트에 있는 첫번째 프로세스에 프로세서를 할당하는것.
>- 디스패처 : 디스패칭을 수행하는 시스템 개체

> 아래는 책 내용이다. 내가 중요하다고 생각했던거 정리함.
- 운영체제는 프로세서들의 실행 사이에 끼어들면서 프로세서들이 인터럽트됨 -> 재시작 할때 오류 생기지 않게 관리해준다.
	- 단순한 프로세스 작업도 운영체제와 통신 가능해야 한다.
1. 사용자가 프로그램 실행
2. 프로세스 생성
3. 준비 리스트에 추가
4. 다른 프로세스들이 프로세서 사용을 마치면 준비 리스트의 머리쪽으로 이동 (= 레디큐)

- 인털럽팅 클록(간격 타이머) : 시스템의 프로세서 독점 방지를 위한 프로세스가 특정 시간 간격 or 퀀텀동안만 실행 가능하게 함
	- 프로세스가 시간 만료되기 전, 프로세서 자발적 반납하지 않을 경우
	  -> 인터럽트 발생
	- 프로세서에 대한 제어를 운영체제가 갖는다.
- 입출력 완료 대기시 프로세스가 자발적으로 프로세서 반납(셀프 블록)

### 3.2프로세스 상태와 상태 전이
#### 프로세스 상태(Process state)
- 디스패칭 : 준비 리스트에 있는 첫번째 프로세스에 프로세서를 할당하는것
- 운영체제는 한 프로세스가 시스템의 프로세서를 독점하는 일을 방지 하려고 하드웨어 인터럽팅 클록(간격 타이머 : interrupting clock)을 두어, 프로세스가 특정 시간 간격 또는 퀀텀 동안만 실행할수 있게함.
	- 10m/s 정도..

#### 상태 전이(state transition)
- 네가지 상태 전이 정의
	1. 프로세서를 할당 받으면 프로세스의 상태가 준비 상태 -> 실행상태로 전이
	2. 할당 받은 시간 만료 -> 실행상태 -> 준비 상태
	3. 프로세스가 블록되면 실행 상태 -> 블록상태로 전이
	4. 대기하던 이벤트 완료시 프로세스 깨어남, 블록 상태 -> 준비 상태로 전이

>[!note] interrupt service Routine
>현재 실행중인 프로세스 중지 -> 다음 Ready큐에 있는 프로세스를 실행할수 있도록 스위칭 시키는 역할

![[Pasted image 20250419141734.png]]

![[Pasted image 20250427112103.png]]

### 3.3 프로세스 제어 블록, 프로세스 기술자
#### PCB는 운영체제가 생성한 프로세스를 관리하는데 필요한 정보 보관(=정보 보관소)

- Process identification number(PID)
- 프로그램 상태(process state)
- 프로그램 카운터(program counter) : 해당 프로그램이 다음번에 시작 될 번지수
- 스케쥴링 우선순위(scheduling priority) : 프로세스마다 우선순위가 있다. 해당 정보(어떤 작업을 얼마나 했는지에 대한 기록 저장)가 있음
- 권한(credential) : 프로세스가 접근할수 있는 자원을 결정하는 정보
- 프로세스의 부모 프로세스(parent process) : 해당 프로세스를 생성한 프로세스를 가르키는 포인터
- 프로세스의 자식 프로세스(child process) : 해당 프로세스가 생성한 프로세서들을 가리키는 포인터
- 프로세스의 데이터와 명령어가 있는 메모리 위치를 가리키는 포인터
- 프로세스에 할당된 자원들을 가리키는 포인터

>[!note] 프로세스끼리 커뮤니케이션
>서로 다른 프로그램이 어떤 동작을 수행하기 전, 프로그램 끼리 소통 -> 충돌 방지 + 순서 정함.
>- ex_) 프로그램 다운 중에 실행버튼을 눌렀을 때 동작되면 안되기 때문에 프로세스끼리 커뮤니케이션 함.

### 3.4 프로세스 제어 블록, 프로세스 기술자
#### 프로세스 테이블(process table)
- 운영체제는 각 프로세스의 PCB를 가리키는 [[포인터]]를 시스템 전체 or 사용자별 프로세스 테이블에 유지
- PCB에 빠르게 접근 가능
1.  프로세스 종료
2. 운영체제는 프로세스의 메모리와 기타 자원을 해제
3. 다른 프로세스가 사용 가능
4. 프로세스 테이블에서 해당 프로세스를 제거

- 운영체제는 프로세스가 상태 전이시 해당 프로세스의 PCB 안에 있는 상태 정보도 갱신해야 함.

>[!note] PCB(Process Control Block) : 프로세스 제어 블록
>프로그램이 어디까지 실행이 완료 되었고, 다음은 어디부터 시작하며, 로컬 변수의 값들 등등의 정보가 있다.

![[Pasted image 20250419143834.png]]

### 3.5 프로세스 연산
- 프로세스는 새로운 프로세스를 생성(spawn)
	- 부모 프로세스(parent process)
		- 프로세스를 생성하는 프로세스
	- 자식 프로세스(child process)
		- 생성된 프로세스
	- 각 자식 프로세서는 정확히 한 부모 프로세스를 통해 생성
	- 프로세스가 소멸될 경우(1or2)
		1. 부모 프로세스가 소멸될떄 자동으로 자식 프로세스까지 소멸
		2. 자식 프로세스가 부모에 독립적으로 계속 실행 -> 부모 프로세스의 소멸이 자식에 영향 X

![[Pasted image 20250419144143.png]]

 ![[Pasted image 20250419144218.png]]

### 3.6 일시정지와 재시작
- 프로세스 일시 정지 ( = 롤에서 애들 한타하는데 존야쓴거랑 같음)
	- 아직 소멸되지는 않고 프로세서를 차지하려고 하는 경쟁 대기열에서 무기한으로 배제
		- 프로세스를 기다리지 않음
	- 악성 코드 실행과 같은 보안 위협 요인 추적 or 디버깅시 유용
	- 일시 정지는 해당 프로세스 혹은 다른 프로세스에 의해 발생 
		- 실행중인 프로세스가 일시정지 가능
	- 일시 정지 블록 상태 프로세스는 다른 프로세스에 의해 지시작 가능
		- 단일 프로세스의 경우 일시정지 시킬 다른 프로세서가 동작 X
	- 일시 정지 상태
		1. 일시정지 준비(suspended ready)
		2. 일시정지 블록(suspended blocked)

>[!note] 중지 VS 일시정지
>- 블록 : 그냥 이벤트 끝날때까지 기다리고 그 다음에 실행하는게 낫지 않음?
>- 일시정지 : 근데 일시정지는 우선순위가 높기 때문에 즉시 수행됨(위험도 차이)

![[Pasted image 20250419144851.png]]


### 3.7 문맥 교환(context seitches)
(비유 : 축구 경기 중에 선수 교체 하는거랑 비슷하다고 생하면 됨. 경기 전체의 흐름을 막지 않으면서 선수들간의 교체는 이루어지는...)

1. 운영체제에 의해 실행중인 프로세스를 멈춘다
2. 준비 상태에 있던 다른 프로세스를 실행
3. 실행중인 프로세스외 실행문맥을 해당 프로세스의 PCB에 저장
	- 운영체제나 다른 프로세스들이 해당 프로세스의 레지스터 값을 덮어쓰는 일 방지
4. 실행할 준비 상태 프로세스의 이전 실행 문맥을 PCB에서 읽어 로드
	- 이전까지 실행했던 부분부터 시작
- 기본적으로 프로세스에 투명(transparent) 해야함
	- 프로세스는 자신이 계속 실행중이라고 착각함.
- 문맥 교환이 일어나는 동안 프로세서는 '의미있는' 작업을 전혀 수행하지 못함(CPU 사용 X)
	- 운영체제는 문맥 교환에 드는 시간을 최소화 해야 함.
	- 마치 프로세스가 멈추지 않고 계속 돌아가는것 처럼 느낌

>[!note] 실행 문맥이란?
>프로세스의 중단 및 재실행을 위한 상태를 저장해둔 정보의 집합
>- 정보의 집합? 무슨 정보인데...?
>  => 프로세스 상태, 프로그램카운터, 레지스터 값, 스텍 정보, 메모리 관리 정보, 입출력 상태, 스케쥴링정보(우선순위 , 큐 위치 등등)

![[Pasted image 20250419165059.png]]

![[Pasted image 20250419165117.png]]

## 04_인터럽트
### 4.1 인터럽트(interrupts)
1. 인터럽트(하드웨어 이벤트)는 소프트웨어가 하드웨어로부터 오는 신호에 반응할수 있게 함
   (약간...사람 꼬집으면 아픈것마냥 신호 받는거 아님? 꼬집는다(이벤트)->아프다(몸의 신호를 뇌로 받음))
	- 프로세서는 프로세스의 명령어를 실행 한 결과로 인터럽트 발생
		- 트랩
		- 프로세스의 작동과 동기(synchronous)
		- 예를들어, 0을 나누거나 보호되는 메모리 위치를 참조하려고 하는 경우 트랩 발생
	- 프로세서의 현재 명령어와 관련 없는 이벤트에 의해서도 인터럽트 발생
		- 프로세스 작동과 비동기(asynchronous)
		- ex_) 사용자가 키보드를 누르거나 마우스를 움직이는경우, 
		  키보드 누름 -> 화면에 표시 / 마우스 클릭 -> 클릭한거 표시
	- 해당 이벤트 발생 -> 현재 프로세스 블락 -> 인터럽트 서비스로 처리
	- 적은 오버헤드(폴링 방식보다 효과적)

#### 폴링(polling)
- 인터럽트의 대안
- 프로세서가 각 장치의 상태를 반복적으로 확인
- 컴퓨터 시스템의 복잡도가 증가할수록 오버헤드 증가
	- => 비효율적

### 4.2 인터럽트 처리
- 인터럽트 처리 방법들
	1. 인터럽트 컨트롤러 사용 -> 우선순위에 맞게 처리
	2. 현재 명령어 실행 완료시 현재 프로세스의 실행을 멈춤
	3. 제어 권을 적절한 인터럽트 처리기에 넘김
	4. 인터럽트 유형을 기반으로 수행
	5. 인터럽트 처리기 완료후 , 인터럽트 된 프로세스의 상태 복구
	6. 인터럽트 된 프로세스 실행
- 인터럽트 처리라는 일련의 명령어 지정 -> 각 유형의 인터럽트가 발생할때 실행

### 4.3 인터럽트 처리

![[Pasted image 20250419170435.png]]

>[!note] 인터럽트 벡터
>인터럽트 처리를 가르키는 포인터들의 배열

- 인터럽트 처리 흐름
	1. 인터럽트 라인 활성화 -> 일정시간 초과, 입출력 종료를 알림
	2. 프로세서가 현재 명령어를 완료하면 실행문맥 PCB에 저장
	3. 제어권을 인터럽트 처리기에 넘김
	4. 인터럽트 유형기반 착업 처리
	5. 작업 완료시 인터럽트된 프로세스가 복구 or 문백 교환 시작시 다음 프로세스 복구
	6. 인터럽트된 프로세스 or 다음 프로세스가 실행 (둘중 무엇을 실행할지는 운영체제의 책임)

### 4.4 인터럽트 클래스
- 인터럽트 집합은 시스템 아키텍쳐에 따라 상이
	- IA - 32 명세서에서 프로세서가 받을 수 있는 신호
		- 인터럽트(interrupts)
			- 이벤트 발생
			- 외부 장치의 상태 변경
		- 예외(Exceptions)
			- 하드웨어나 소프트웨어 명령어의 실행 결과 오류
			- 폴트(fault), 트랩(TRAP), 중단(abort)

- 인터럽트 유형과 상세 내용
	1. 입출력 : 입출력 하드웨어에서 발생하는 인터럽트. 
		- 프로세서에 채널이나 장치의 상태가 변한 사실을 알려준다. 입출력 인터럽트는 입출력 작업이 완료될때 발생
	2. 타이머 : 시스템은 주기적으로 인터럽트를 발생시키는 장치를 가질수도 있다.
		- 시간 점검, 성능 모니터링 임무등에 사용
		- 운영체제는 타이머를 통해 프로세스들의 퀀텀이 다 되었는지 확인
	3. 프로세서간 인터럽트 : 멀티 프로세서 시스템에서 한 프로세서가 다른 프로세서에 메세지를 보낼 수 있게 해준다.


- 예외 분류
	1. 폴트 : 프로그램의 기계어 명령어가 실행될때 발생하는 넓은 범위의 문제 때문에 발생
		- 이런 예외의 예외로는
			-  0을 나누거나, 
			- 처리중인 데이터의 포맷이 잘못되었거나, 
			- 유효하지 않은 코드를 실행하거나 
			- 실제 메모리의 한계를 넘어서는 메모리 위치 참조, 
			- 사용자 프로세스가 특권 명령어를 실행하거나,
			- 보호되는 자원에 접근하려고 하는 일 등이 있다.
	2. 트랩 : 오버플로우와 같은 예외때문에 발생 or 프로그램 제어권이 코드의 중단점에 도달할때 발생
	3. 중단 : 프로세서가 프로세스가 극복해낼수 없는 오류를 탐지 할때 발생
		- ex_) 예외처리 루틴 자체가 예외를 발생시킬때 프로세서가 두가지 오류를 순차적으로 처리할수 없을때 발생, 이를 "이중 디폴트 예외" 라고 하며, 이 경우 예외를 발생시킨 프로세스가 종료된다.(아니 짬때리는것 마냥 예외처리를 예외처리하네;;)

>[!note] 오버플로우
>레지스터에 저장된 값이 레지스터의 용량을 초과하는것

## 05_프로세스간 통신
### 5.1 많은 운영체제에서 프로세스간 통신(IPC : InterProcess Communication) 메커니즘 제공
- 멀티프로그래밍 네트워크 환경
	- ex_) 원격 서버에서 데이터 조회 : 프로세스간 메세지로 소통 가능
- 공통의 목적 달성을 위해 서로 협력

### 5.2 신호(signal)
- 프로세스에 이벤트가 발생했음을 알리는 소프트웨어 인터럽트
	- 프로세스들이 다른 프로세스와 교환할 데이터를 명시하지 않음

- 잡음, 무시, 마스킹
	1. 잡음(catch) : 프로세스는 신호를 전달 할때 운영체제가 호출하는 루틴을 정함으로써 "신호 잡음".
	2. 무시(ignore) : 프로세스는 신호 처리를 위한 운영체제의 기본 동작에 의존함으로써 "신호 무시"
	3. 마스킹(masking) : 프로세스가 특정 유형의 신호를 마스크 하면, 해당 유형의 
	   "신호를 전달하지 않음"

>[!note] 비유
>상황 : 길 건너편에 있는 친구에게 인사함
>1. 잡음 : 날 발견하고 같이 인사 해줌 ㅎㅎ
>2. 무시 : 걍 무시함(못봄)
>3. 마스킹 : 나 봤는데 걍 못본척함 ㅡㅡ

### 5.3 메세지 전달(message passing)
- 메세지 기반 통신
	- 메세지는 한번에 한 방향으로 전달
		- 송신자
		- 수신자
	- 메세지 전달이 양방향으로 일어날수도 있음
		- 전송자인 동시에 수신자
	- 블록킹 송신, 넌블록킹 송신
		1. 블록킹 송신 : 수신자가 메세지를 수신할때까지 대기
		2. 넌블록킹 송신(비동기식 방법) : 송신자가 수신자로 부터 메세지를 받지 않았을때도 다른 작업을 계속 할수 있는 전송 방식
	- 파이프(pipe) - 리눅스에서 많이 쓰임
		- 잘 알려진 메세지 전달 구현
		- 운영체제에서 보호하는 메모리 영역
		- 버퍼 역할을 해준다. 
			=> 프로세스 둘 이상이 데이터를 교환(양방향)

- 분산 시스템에서 IPC
	- 네트워크를 통한 데이터 전송
	- 전송에 오류가 생기거나 심지어 데이터를 잃어버릴수도 있음
		- 승인 프로토콜 사용
		- 타임아웃 매커니즘
			=> 위 둘은 오류, 유실된 데이터 복구가 가능하다.
	- 명확하지 않은 프로세스 이름은 메세지 전달을 어렵게 함.
		- 번호가 부여된 포트들을 통해 컴퓨터들 사이에서 메세지 전송
	- 보안 문제
		- 인증 문제
- ex_) A 메세지 전송 -> 잘 받았다 -> 다시 A에게 메세지를 받았다는 신호를 주어야 한다.
  신호가 없으면 못받은줄 알고 다시 줌.

## 06_사례연구 : 유닉스 프로세스
- 가상 주소 공간(virtual address space)라는 일련의 메모리 주소를 제공 받음
- PCB를 사용자 프로세스가 접근할수 없는 보호된 메모리 영역에 유지
- 유닉스 PCB
	- 프로세서 레지스터의 내용
	- 프로세스 식별자(PID)
	- 프로그램 카운터
	- 시스템 스택
- 모든 프로세스는 프로세스 테이블에 리스트
- 시스템 호출을 통해 운영체제와 상호 작용
- fork 시스템 호출을 통해 자식 프로세스 생성
	- 자식 프로세스는 부모 프로세스의 자원들의 사본을 받음
- -20 ~ 19 사이의 정수로 프로세스 우선순위를 가짐
	- 낮은 숫자가 높은 우선순위 의미
- 데이터 통신을 위해 신호나 파이프 메커니즘 제공


![[Pasted image 20250419173126.png]]
