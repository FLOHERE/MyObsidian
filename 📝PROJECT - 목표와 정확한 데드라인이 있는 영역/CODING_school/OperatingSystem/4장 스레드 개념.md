## 01_소개
- 최근에는 java, C#, Visual C++.NET, Visual Basic.NET, python...등을 포함한 다양한 범용프로그래밍 언어에서 응용 프로그래머가 병행 프리미티브(스레드)를 사용 가능
- 멀티 스레딩
	- 응용 프로그램이 '스레드 실행'을 포함하도록 프로그램 작성
	- 각 스레드는 프로그램의 한 부분을 이루는 병행으로 실행될 작업들로 지정
	- 화면 출력 스레드 + 오류 스레드 등등 = 멀티 스레드(여러 스레드를 함께 사용)

>[!note] 스레드란?
>프로그램의 문맥 흐름을 말한다.

![[Pasted image 20250419183934.png]]

## 02_스레드 정의
### 2.1 스레드
- 경량 프로세스(LWP : Light Weight Process)
- 명령어들의 한 줄기 혹은 프로그램 제어 흐름
- 프로세스에 있는 스레드들은 병행으로 실행되면서 공통의 목표를 이루려고 협력
- 레지스터, 스택, 신호 마스크처럼 스레드마다 있는 특정 데이터들은 각 스레드에 국한
- 프로세스에 속한 주소 공간은 해당 프로세스에 속한 모든 스레드에 공통
	- = 공통 스레드는 모든 프로세스가 공유해서 사용
- 특정 플랫폼에서 스레드를 구현한 방식에 따라 스레드를 운영체제 
  or 스레드를 생성한 사용자 프로그램에서 관리
- ex_) Win32 thread, C-thread, Pthreads

![[Pasted image 20250419184243.png]]

## 03_스레드 사용 동기

### 3.1 멀티 스레딩을 선호하게 된 요인
- 소프트웨어 설계
	- 병렬 작업 처리를 더 간단하게 표현 가능
- 성능
	- 멀티 스레드 응용프로그램이 작업 완료를 하는데 필요한 시간이 크게 감소
- 협력
	- 한 프로세스에 속한 스레드들은 주소 공간 공유 -> 서로 통신 가능

### 3.2 스레드와 프로세스는 공통된 많은 연산들을 소유
- ex_) create, exit, resume, suspend

### 3.3 스레드의 생성은 운영체제가 부모 프로세스와 스레드 간에 공유되는 자원을 초기화 할 필요 X

- 프로세스의 생성과 종료에 비교하여 스레드의 생성과 종료에 대한 오버헤드 감소를 위함

## 04_스레드 상태 : 스레드 생명 주기

### 4.1 스레드 상태(프로세스 상태와 유사)
- 탄생 상태
- 준비 상태
- 실행 상태
- 데드 상태
- 블록 상태
- 대기 상태
- 휴면 상태
	- 일정 시간동안 휴면 상태일지를 휴면 간격이라고 한다.
	- ex_) java의 .sleep(1000)...

![[Pasted image 20250419184722.png]]

## 05_스레드 연산

### 5.1 스레드와 프로세스는 공통된 연산들을 소유(흐름이 비슷함)
- 생성
- 종료
- 일시정지
- 재시작 
- 휴면
- 휴면 깨어남

### 5.2 일부 스레드 연산은 프로세스 연산과 대응되지 X
- 취소
	- 스레드와 프로세스 공통점 : 취소를 통해 프로세스나 스레드를 실행 중간에 종료 가능
	- 차이점 : 스레드 취소는 스레드가 종료함을 보장하지 못함. (프로세스 종료는 보장함)
- 결합
	- 하나의 스레드가 완료될때까지 기다렸다가 결과를 받아서 다음 스레드에 실행
		- 주 스레드는 각 스레드가 작업을 완료할때까지 휴면하는것이 보통
	- 한 스레드가 다른 스레드를 결합 -> 이전 스레드는 후자의 스레드가 종료할때까지 실행 X

## 06_스레딩 모델
### 6.1 세가지의 대중적인 스레딩 모델
1. 사용자 수준 스레드
2. 커널 수준 스레드
3. 사용자 수준과 커널 수준 스레드의 조합

### 6.2 사용자 수준 스레드는 사용자 영역에서 스레드 연산 수행
- 특권 명령을 실행 할수 없거나 커널 프리미티브에 직접 접근 할수 없는 런타임 라이브러리가 스레드 생성
	- 사용자 영역에서 스레드에 대한 라이브러리를 가지고 스레드 생성하는 경우

>[!note] 특권 명령이란?
>운영체제의 커널에 직접 접근이 되지 않기 때문에 특별한 명령어를 사용하여 접근하는데, 이게 특권 명령어이다.

>[!question] 왜 특권 명령어를 쓸까?
>보안성과 안전성 때문. 사용자 프로그램이 직접 하드웨어를 제어하거나 메모리 관리시 시스템 불안정할수도

>[!note] 오버헤드란?
>운영체제가 작업을 처리할때 발생하는 필연적인 자원 비용.
>오버헤드를 피할수는 없지만 최대한 줄이도록 설계하는게 핵심(스케쥴러 알고리즘, 가상 메모리 등등)


### 6.3 사용자 수준 스레드 운용
- 다대 일 스레드 맵핑
	- 운영체제가 멀티스레드 프로세스 하나에 있는 모든 스레드에 실행 문맥 하나를 맵핑
	- 장점
		- 사용자 수준 라이브러리로 프로세스의 스레드를 스케쥴링 하고 디스패치 함
		- 커널 밖에서 동기화 수행(문맥 변환을 회피하기 위함)
	- 단점
		- 커널은 멀티스레드 프로세스
- 커널에서는 스레드를 지원 x => 스레드의 존재 자체를 모름

![[Pasted image 20250419191128.png]]

### 6.4 커널 수준 스레드
- 각 스레드마다 고유한 실행 문맥을 맵핑하는 방법으로, 사요자 수준 스레드의 한계 해결
	- 일대일 스레드 맵핑 제공
		- 장점 : 상호작용성 증가
		- 단점 : 실행될 시스템이 달라지면 해당 운영체제에서 제공하는 스레드 API를 사용 -> 프로그램을 수정 해야 함.
- 커널 수준 스레드는 항상 멀티 스레드 응용에 최적화된 정답이 될수는 없음.
- 프로세스 하나가 블락이 되어도 나머지 두개는 정상 작동

![[Pasted image 20250419191329.png]]

### 6.5 사용자 수준 스레드와커널 수준 스레드의 조합
- 사용자 수준 스레드 + 커널 수준 스레드
	- 다대 다 스레드 맵핑 (m to n)
		- 많은 사용자 수준 스레드를 한 그룹의 커널 스레드에 맵핑
		- 스레드 풀링을 통해 오버헤드 문제 해결
- 작업자 스레드
	- 풀에서 지속되는 커널 스레드는 할당된 스레드에 따라 다른 기능 수행
- 스케줄러 활성화
	- 사용자 수준 스레드 라이브러리에 이벤트 발생을 통보하는 커널 스레드
	- 이벤트 통지를 통해 '활성화' 되었을때,
	  사용자 수준 스레드 라이브러리가 스레드 스케쥴링을 수행 가능
- 스레드 풀 : 스레드의 생성, 소멸 과정에서 많은 오버헤드가 발생, 이를 줄이기 위해 사용
	- 스레드는 이미 만들어져 있음
	- 이를 통해 작업만 할당하면 OK!!
	- 굳이 생성, 소멸시킬 필요가 없음!

![[Pasted image 20250419192104.png]]

## 07_스레드 구현시 고려 사항
- 신호의 두가지 유형
	- 동기 신호
		- 프로세스나 스레드가 실행한 명령어의 직접적인 결과로 발생
	- 비동기 신호
		- 현재 실행하는 명령어와 무관한 다른 이벤트에서 발생
	- 프로세스는 신호 마스킹을 통해 여러 스레드가 받을 신호 나눌수 있음
	- 신호 마스킹은 운영체제가 신호를 받을 스레드를 결정할수 있게 해줌

![[Pasted image 20250419192316.png]]
