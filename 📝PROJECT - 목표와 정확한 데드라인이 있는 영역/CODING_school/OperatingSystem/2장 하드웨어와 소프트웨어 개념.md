- 시스템 프로그래밍(옛날) : 하드웨어 관리, 프로그램에 서비스를 제공하도록 코딩
- 응용 프로그래밍(now!) : 운영체제에 서비스 요청
- 디바이스 드라이버 : 운영체제에서 특정 장치를 대상으로 입출력 할때 사용하는 시스템
	- 보통 하드웨어 제조사가 제공
	- 오늘날 시스템에서 매우 중요하다.(리눅스 커널의 소스 60% 차지)
	- 디바이스 드라이버는 어떤 방식으로 운영체제의 확장성를 지원하는가?
- 하드웨어 장치를 다루는 세세한 작업 부담 해소 + 하드웨어 쉽게 추가
- 플러그 앤 플레이 : 운영체제가 컴퓨터의 하드웨어 자원을 쉽게 파악해 각 장치 설치, 해당 드라이버 쉽게 사용

## 01_소개
### 1.1 운영체제의 주요 역할
- 메모리 관리 + 사용자 편의 제공
- 자원 관리
	- 운영체제 설계 시 관리할 하드웨어 + 소프트웨어간 밀접한 연계 필요
	- 하드웨어 & 소프트웨어 자원
		1. 프로세서
		2. 메모리
		3. 2차 저장소 -> HDD, SDD
		4. 기타 장치
		5. 프로세스 
		6. 스레드(SW)
		7. 파일(SW)
		8. 데이터 베이스(SW)


## 02_하드웨어 장치의 발전
### 2.1 대부분의 운영체제는 하드웨어 구성에 의존하지 않게 구현
- 특정 장치를 대상으로 입출력 -> 디바이스 드라이버 사용
	- ex_) 플러그 앤 플레이 장치 - 컴퓨터에 연결시 자신이 어떤 장치인지 운영체제에 알림
- 인텔 프로세서의 연도별 트랜지스터 수
	- 무어의 법칙 : CPU의 속도가 매년 2배씩 증가

>[!note] 트렌지스터
>전기의 흐름을 제어하는 작은 스위치(0과 1구현)
>- IOT에서 트렌지스터 배웠는데 그거랑 다른거임?
>  => 사실 같은건데 운영체제에서 작동 하는것과 IOT에서 작동하는게 문맥이 다르다고 함. 
>  IOT에는 아두이노 보드에서 외부장치를 제어하는 실제 전자 부품이고, 
>  운영체제에서는 CPU와 메인보드가 전기적 통신을 하는건 맞지만 실질적인 운영체제의 역할은 하드웨어 간 통신 위에서 작동하는 소프트웨어 계층이다.

## 03_하드웨어 구성요소
### 3.1 컴퓨터 하드웨어 구성
- 프로세서
- 메인 메모리
- 입출력 장치

### 3.2 메인 보드
- 인쇄 회로 기판(PCB, Printed Circuit Board)
	- 보드의 장치들을 전기적으로 연결해주는 하드웨어 구성 요소
- 메인보드 - 시스템의 중심 PCB
	- 여러 하드웨어 구성요소(프로세서, 메인메모리 등)를 꽂을 수 있는 슬롯 내장
	- 저수준 기능을 담당하는 컴퓨터 칩 포함(BIOS...)
		- 하드웨어와 소프트웨어 간의 원활한 통신 (자원관리, 데이터 전송, 장치 및 연결통신 등등)

### 3.3 프로세서 -> CPU
- 일련의 기계어 명령어를 실행하는 하드웨어 구성요소
	- CPU, Central Processing Unit - 프로그램의 명령어를 실행하는 프로세서
	- 보조 프로세서 : 특수 목적 명령어들을 효율적으로 실행
		- ex_)그래픽 or 디지털 신호 처리기
	1. 명령어 페치기 : 명령어 레지스터에 명령어를 로드
	2. 명령어 해석기 
		1. 명령어를 해석
		2. 이에 해당하는 입력 정보를 실행 처리기에 전달
		- ALU(Arithmetic and Logic Unit) : 덧셈, 곱셈같은 기본적인 산술 연산과 대소 비교같은 논리 연산 수행
			- 명령어를 실질적으로 실행
		- 캐시 : 고속 메모리, 메인메모리에 있는 데이터의 복사본 저장 -> 프로세서의 효율 향상
			- 종류 : L1, L2 캐시
			- 메모리에 프로그램을 불러올때 시간이 많이 걸림 -> 캐시에 자주쓰는 프로그램들을 미리 넣어놓는다. (즐겨찾기 같은거 ㅇㅇ)
		- 레지스터 : 프로세서에 위치한 고속 메모리
			- 프로세서가 데이터 조작시, 해당 데이터가 레지스터에 위치해야함.
			- 데이터 사용시 레지스터에 있어야함. 프로세서가 바로 사용할수 있는 데이터를 담는다.
			- 레지스터의 크기는 프로세서가 한번에 처리할수 있는 비트수에따라 결정
				- ex_) 32 비트 프로세서 -> 각 레지스터에 32비트 데이터 로드
			- 범용 레지스터 : 레지스터의 일정 부분을 응용 프로그램이 데이터 값이나 실행중 포인터 값을 빠르게 읽으려고 별도로 예비 해둔것.
			- 컨트롤 레지스터 : 프로그램 카운터(다음 실행할 명령어가 무엇인지 알려줌) 등의 시스템에 관한 정보를 저장

>[!warning] 내가 헷갈렷던거
>Q. 레지스터(고속 메모리)랑 메인메모리랑 같은거임? : ㄴㄴ
>- 레지스터의 역할 : CPU가 데이터 조작시 사용
>- 메인 메모리의 역할 : 프로세스 실행을 위해 Ready상태 -> CPU에 할당하는 과정
>=> 결정적으로 메인 메모리는 CPU외부에 있고, 고속 메모리는 CPU 내부에 있음

>[!note] IOT에서의 레지스터와는 조금 다르다!
>- IOT : 하드웨어와 소프트웨어간의 상호작용
>- 운영체제 : CPU의 명령어실행과 관련된 여러 작업

### 3.4 프로세서(CONT)
- 프로세서 구성요소
	- 컴퓨터 시간은 사티클(클록틱)을 통해 측정
		- 사이클 - 시스템 클록 생성기가 보낸 전기 신호의 한 진폭
		- 클록 생성기는 버스가 데이터를 나르는 주기 설정
			- 초당 사이클 수 (Hz, hertz)로 측정
			- ex_)프론트 사이드 버스 : 프로세서들을 메모리 모듈에 연결, 흔히 몇백메가 헤르츠 정도로 작동
- 시스템의 구성 요소는 다양한 클록 속도로 동작.
	- 프론트사이드 버스 기준, 각 장치의 속도를 결정하는 곱수나 제수 사용
		- 곱수 : 어떤 수에 다른 수를 곱해서 만든 수
		- 제수 : 어떤 수를 나누는 수
- 버스에 있는 어떤 구성요소는 매우 높은 곱수를 가지고, 동일 버스에 있는 다른 구성 요소는 매우 높은 제수를 가진다면?
	- 병목 현상 발생
	- 제수가 큰 장치 < 곱수가 큰 장치
		- 제수가 큰 장치는 느리고, 곱수가 큰 장치는 제수가 높은 장치의 정보에 의존해서 많이 기다려야 함.

![[Pasted image 20250418230727.png]]

>[!Question] 근데 왜 시스템 실행 속도(클록 속도)를 조절 할까? 빠르면 다 좋은거 아닌가...
>- CPU와 메모리, 버스 등은 서로 다른 속도로 동작해야 안정적임
>- 곱수/제수를 써서 각 부품이 적절한 클록 속도로 작동하게 만듦
>- 클록 속도만 높인다고 무조건 성능이 오르지도 않고, 발열, 전력소모 등등 고려 필요

- 칩셋 : 하드웨어(컨트롤러 , 보조 프로세서, 버스 등등)의 집합
	- 메인보드에 통합 -> 시스템의 하드웨어 능력 결정
- 컨트롤러 : 보드의 버스를 통해 데이터 이동 관리

### 3.5 메모리 계층
- 최상위 계층 : 가장 빠르고 비싼 메모리
- 최하위 계층 : 가장 저렴하고 속도가 느린 메모리
	- HDD(하드디스크)가 느린 이유 : 데이터가 순차적으로 배치되어 있음 -> 해당되는 위치에 헤드를 물리적으로 돌리기 때문
- 휘발성 매체 - 전원을 끄면 데이터가 사라짐 (ex:RAM)
	- 레지스터, 캐시, 메인 메모리

### 3.6 메인 메모리
- 휘발성 임의 접근 메모리(RAM, Random Access Memory)
	- 프로세스가 어떤 순서로든 데이터에 접근 가능
- 종류
	- 동적 램(DRAM, Dynamic RAM) - 재생 회로 필요
		- 주기적으로 메모리내용 업데이트 해야 데이터를 기억함.
		- 시간은 많이 걸리지만 가격은 싼편
	- 정적 램(SRAM, Static RAM) - 재생 회로 불필요
- 대역폭 : 단위 시간당 이동하는 데이터 양

### 3.7 2차 저장소(HDD, SSD)
- 저비용으로 대용량의 데이터를 영구적으로 보관
	- 데이터의 접근 속도가 메인 메모리 보다 느림
		- 읽기/쓰기 헤드의 물리적인 움직임
		- 회전 지연 시간
		- 헤드를 통해 데이터가 통과하는 전송 시간
	- 데이터 백업이나 이동 가능한 2차 저장 장치
		- CDs(CD-R, CD-RW), DVDs(DVD-R, DVD+R), 집 디스크, 플로피 디스크, 플래시 메모리 카드, 테이프

### 3.8 버스
- 트레이스의 집합
	- 트레이스 : 하드웨어 장치들간의 정보를 전송, 아주 작은 전기적 연결선
	- 포트 : 정확히 두 장치를 연결하는 버스
	- 입출력 채널 : 서너개 장치에서 입출력 기능을 수행할때 공유하는 버스
	- 프론트 사이드 버스(FSB, Front Side Bus) : 프로세서들을 메모리 모듈에 연결
		- FSB 속도 높음, 메인 메모리와 프로세서 사이에 전송되는 데이터의 양 많음, 성능 향상
- 데이터버스 : 데이터 전송
- 주소 버스 : 해당 데이터의 위치나 수신위치를 결정
- 컨트롤러 : 버스에서 두 신호가 충돌하는 일 방지 -> 메모리 접근에 우선순위 부여
	- 우선순위 : 채널>프로세서
	- 사이클 가로채기!!!!@@ => 입출력 채널이 실제로 프로세서보다 우위에 있음.
- DDR(Double Data Rate) : 200MHz -> 400MHz
	- 데이터 전송을 두번 수행(칩셋과 RAM 모두 지원해야 함.)
- 쿼드 펌핑 : 사이클당 데이터 전송을 네번 수행함. 시스템 메모리 대역폭을 네배로 만든다
- PCI 버스(Peripheral Component Interconnect Bus)
	- 주변장치(사운드 카드, 네트워크 카드 등)를 시스템의 나머지 부분에 연결
- AGP(Acceelerated Graphics Port) : 그래픽 카드와 함께 사용
	- 실시간으로 그래픽 조작(수십~수백 메가바이트 RAM 요구)

### 3.9 직접 메모리 접근(DMA, Direct Memory Access)
- 메모리와 입출력 장치간의 데이터 전송 효율 향상
- CPU 대입 없이 디스크에 있는 데이터 읽어서 메모리에 올리는 방식
	- 장치들과 컨트롤러들이 데이터 블록을 메인 메모리에 직접 전송
	- 프로세서는 자유롭게 소프트웨어 명령어들을 실행
	- DMA 채널은 입출력 컨트롤러를 사용해 데이터 전송 관리
		- 입출력 연산 완료시 인터럽트 통해 프로세서에 알림
	- 다량의 입출력 기능을 담당하는 시스템의 성능 크게 향상
		- ex_) 메인 프레임, 서버

![[Pasted image 20250419002505.png]]

### 3.10 주변 장치
- 컴퓨터가 소프트웨어 명령어를 실행하는데 필수적이지 않은 하드웨어
- 내부 주변 장치(통합 주변 장치)
	- 네트워크 인터페이스 카드, 모뎀, 사운드 카드, 하드디스크, 내부 CD-ROM 드라이브 등
- 문자 장치는 한번에 한 문제 데이터 전송(인터럽트 사용)
	- 키보드, 마우스 등
- 포트와 기타 버스를 통해 컴퓨터에 추가
	- 직렬 포트, 병렬포트, USB, IEEE 1394 포트 , SCSI
		- 직렬포트 : 한번에 한 바이트 데이터 전송(키보드, 마우스에 연결)
		- 병렬포트 : 한번에 여러 비트 전송(프린터와 연결)
		- USB, IEEE : 고속 직렬 인터페이스
			- 핫스와핑 : USB장치는 시스템이 켜져있는 동안 하드웨어 저장 X, 추가 및 인식

![[Pasted image 20250419004313.png]]

## 04_하드웨어의 운영체제 지원
### 4.1 프로세서
- 대부분의 운영체제는 프로세서를 통해 보호 메커니즘 구현
	- 프로세스가 할당 받지 않은 메모리에 접근하는것을 막음
	- 컴퓨터 시스템의 몇가지 다른 실행 모드
		1. 사용자 모드 : System Call 사용
		2. 커널 모드 : 특권 명령어 실행과 원하는 작업을 수행하기 위한 자원의 접근 가능
			- 특권 명령어 : 운영체제와 하드웨어가 특정 기능을 수행하기 위해 필요한 명령어
				- 특권 명령어 사용해서 입출력장치 제어함.
			- 커널모드 = 특권 명령어 가능 +  하드웨어 직접 제어 가능
			- ONLY 운영체제만 사용
	- 메모리 보호와 관리
		- 프로세스가 자신이 할당 받지 않은 메모리에 접근하는 것을 방지
			- 사용자 모드에서는 특권 명령어 사용 X
		- 특권 명령어로만 수정 가능한 프로세서 레지스터를 사용해 구현
	- 인터럽트와 예외
		- 대부분의 장치는 이벤트 발생 시 프로세서에 인터럽트라는 신호를 보냄
		- 예외 - 오류에 대한 반응으로 발생하는 인터럽트
		- CPU에 인터럽트 오면 인터럽트 먼저 처리
- 컴퓨터 아키텍쳐 : 성능 향상을 위해 운영체제가 더 빨리 기능할수 있도록 하드웨어 적으로 지원하는 몇가지 기능 포함
	- 운영체제 -> 엄격한 방어 체계 갖춰 시스템 보안과 무결성 보장

### 4.2 부트스트랩핑
- 운영체제를 메모리에 로드하는 과정
	-  = 운영체제 다운로드 과정
- BIOS, Basic Input/Output System에 의해 수행
	- 시스템 하드웨어 초기화
	- 2차 저장소의 부트섹터에서 명령어들을 읽어 메인 메모리에 로드
		- 부트 섹터(=부트로더) : 운영체제가 저장된 위치 찾아 해당 운영체제를 메모리로 불러옴
	- 시스템 로드 실패시 컴퓨터의 어떤 하드웨어도 접근 불가능
	- BIOS에서 제일 처음 세팅(하드웨어 초기화, 운영체제 초기 부분)
		- HDD -> 부트섹터 -> MainMemory에 올림 -> CPU에서 실행(부트스트랩핑)

## 05_캐싱과 버퍼링
### 5.1캐싱과 버퍼링
- 캐시
	- 고속 메모리
	- CPU 성능 향상을 위해 사용
	- 캐시 적중(cache hit) - 참조하는 정보가 캐시 메모리에 있는 경우
	- 캐시 실패(cache miss) - 참조하는 정보가 메모리에 없는 경우
	- 메모리 참조의 상당수가 캐시 적중되어야 성능 향상 가능
	- ex_)
		1. L1, L2 프로세서 캐시
		2. 메인 메모리의 일정 부분 할당 -> 2차 저장소의 데이터를 캐시하는데 활용
- 버퍼
	- 장치들 사이 혹은 서로 다른 속도로 동작하는 프로세스들 사이에서 데이터를 전송할때
	  일시적으로 데이터를 보관하는 저장 영역
	- 소프트웨어 + 하드웨어 장치들이 데이터를 비동기적으로 전송하게 함 -> 시스템 성능 향상
		- 두 장치간 속도 조절
		- ex_) 메모리, 하드디스크(보통 더 느리다) <-- 얘네 속도 조절함 ㅇㅇ
- 스풀링
	- 한 프로세스와 저속 or 버퍼가 제한된 입출력 장치 사이에 디스크와 같은 중간 매개체를 두는 기술
		- HDD + printer -> 프린터할 데이터 전송 -> 하드디스크에 파일 있음 -> 파일 프린트와 동시에 데이터 읽어옴

![[Pasted image 20250419013135.png]]

>[!warning] 메모리가 꽉 찬경우!
>- LRU(List Resently Used) : 제일 최근에 가장 적게 사용한 데이터를 내보냄 + 최근에 사용한 데이터 가져옴

- 간격 타이머 : 주기적으로 인터럽트 발생, 운영체제 호출
	- 특정 프로세스가 프로세스 독점을 막는다
	- ex_) 현재 프로세스 -> 제거 -> 다른 프로세서 사용
- 시간 클록 : 실제 시간과 오차 없는 시간
	- 시스템 영속성 유지(전력 공급 X)
	- 시간 클록으로 현재 시간과 날짜 결정 가능
- 플러그 앤 플레이 : 운영체제가 새로 설치한 하드웨어를 사용자와 교류 없이 자동 인식, 사용
## 07_응용 프로그래밍 인터페이스
### 7.1 API(Application Programming Interface)
- 프로그래머들이 운영체제에 서비스를 요청할수 있는 일련의 루틴 제공
- 소프트웨어와 운영체제간 통신은 오직 API를 통해 수행
- API의 예
	- Posix 표준
	- 윈도우 API

![[Pasted image 20250419013516.png]]

## 08_컴파일링, 링킹, 로딩
### 8.1 고급 언어로 작성한 프로그램의 실행
- 기계어로 컴파일
- 실행에 필요한 여러 기계어 프로그램과 링크
- 메모리에 로드

### 8.2 컴파일링
- 고급 언어로 작성한 코드를 기계어로 변환하는 작업
- 컴파일 단계
	1. 렉서 : 각 키워드( {}, (), []...) 차례대로 토큰으로 분리
		- 프로그램의 문자들을 토큰으로 분리
	2. 파서 : 토큰들을 순차적으로 문법 검토
		- 거의 여기서 문제가 생긴다(문법적 문제)
		- 토큰을 구문적으로 올바른 문장으로 그룹화
	3. 중간 코드 생성기 : 말 그대로 코드 생성
		- 구문 구조를 간단한 명령어 스트림으로 변환
	4. 옵티마이저 : 비슷한 데이터, 코드 배치를 바꿔 최적화 후 코드 생성
		- 코드의 효율을 높이고 메모리 요구량 줄임
	5. 코드 생성기
		- 기계어 명령어를 담고 있는 오브젝트 파일 생성

![[Pasted image 20250419014107.png]]

### 8.3 링킹
- 심벌들을 하나로 묶는것
	- 심벌이란 ? : 라이브러리에 있는 코드 등을 말함.
- 프로그램은 모듈로 구성됨
	- 모듈 : 독립적으로 개발된 몇개의 하위 프로그램
- [[라이브러리]]로 공통된 컴퓨터 루틴을 수행.
	- 라이브러리 : 미리 컴파일된 모듈 패키지로 준비됨
- 링킹 : 프로그램에서 참조하는 다양한 모듈을 실행 가능한 한 단위로 통합하는 과정
- 오브젝트 모듈

![[Pasted image 20250419014526.png]]

- 링킹 과정

![[Pasted image 20250419014811.png]]

- 심볼 확정

![[Pasted image 20250419014849.png]]

### 8.4 로딩
- 로더
	- 명령어와 데이터 유닛을 특정 메모리 주소에 배치
		- 데이터 유닛 : 데이터의 기본 단위 (bit, byte)
- 절대 로딩 : 메모리에 데이터를 그대로 올림
	- 메모리가 차있으면 충돌
	- 정해진 주소만 로딩 가능
	- 프로그래머나 컴파일러가 명시한 주소에 배치
- 재배치 가능한 로딩 : 프로그램이 아무 메모리 주소에 로드돼도 상관없는 기술
	- 메모리의 어디서든 실행 가능
	- 편한 위치에 쉽게 접근 가능하다
	- 실제 메모리 주소로 변환해야 하는 상대 주소를 포함할때 수행
- 동적 로딩 : 절대 + 재배치
	- 모듈이 사용될때만 가동
	- 프로그램의 모듈을 처음 사용하는 시점에 로딩하는 기술

![[Pasted image 20250419015434.png]]

![[Pasted image 20250419015452.png]]

>[!note] 주소 재배치란?
>각 문장이 파일 내 한 주소로 유일하게 식별되게 하기 위함

## 09_펌웨어
- 종종 읽기 전용 메모리가 부착된 영구 저장소에 저장되는 실행 가능한 명령어들
- 마이크로 프로그래밍으로 프로그래밍
	- 마이크로 프로그래밍 - 기계어보다 아래에 있는 프로그래밍 계층
- ROM 같은 곳에 컴퓨터 부팅 시 초기화
- 마이크로 프로그래밍을 통해 만든 소프트웨어

## 10_미들웨어
- 한 컴퓨터에서 실행하는 응용프로그램이 원격 컴퓨터에서 실행하는 다른 응용 프로그램과 통신할수 있게 함.
- 분산 시스템을 위한 소프트웨어
	- 분산 시스템 : 여러 컴퓨터가 분산되어 어떤 작업을 수행함
	- 이기종 컴퓨터 플랫폼에서 응용프로그램이 실행 가능(win, linux 끼리 데이터 통신 가능)
	  ( = 서로 다른 OS여도 데이터 통신이 가능하다는 뜻)
	- ODBC (Open DataBase Connectivity)
		- ODBC 드라이버라는 미들웨어를 통해 응용프로그램이 데이터 베이스에 접근