- 시스템 프로그래밍(옛날) : 하드웨어 관리, 프로그램에 서비스를 제공하도록 코딩
- 응용 프로그래밍(new!) : 운영체제에 서비스 요청
- 디바이스 드라이버 : 운영체제에서 특정 장치를 대상으로 입출력 할때 사용하는 시스템
	- 보통 하드웨어 제조사가 제공
	- 오늘날 시스템에서 매우 중요하다.(리눅스 커널의 소스 60% 차지)
	- 디바이스 드라이버는 어떤 방식으로 운영체제의 확장성를 지원하는가?
- 하드웨어 장치를 다루는 세세한 작업 부담 해소 + 하드웨어 쉽게 추가
- 플러그 앤 플레이 : 운영체제가 컴퓨터의 하드웨어 자원을 쉽게 파악해 각 장치 설치, 해당 드라이버 쉽게 사용

## 01_소개
### 1.1 운영체제의 주요 역할
- 메모리 관리 + 사용자 편의 제공
- 자원 관리
	- 운영체제 설계 시 관리할 하드웨어 + 소프트웨어간 밀접한 연계 필요
	- 하드웨어 & 소프트웨어 자원
		1. 프로세서
		2. 메모리
		3. 2차 저장소 -> HDD, SDD
		4. 기타 장치
		5. 프로세스 
		6. 스레드(SW)
		7. 파일(SW)
		8. 데이터 베이스(SW)


## 02_하드웨어 장치의 발전
### 2.1 대부분의 운영체제는 하드웨어 구성에 의존하지 않게 구현
- 특정 장치를 대상으로 입출력 -> 디바이스 드라이버 사용
	- ex_) 플러그 앤 플레이 장치 - 컴퓨터에 연결시 자신이 어떤 장치인지 운영체제에 알림
- 인텔 프로세서의 연도별 트랜지스터 수
	- 무어의 법칙 : CPU의 속도가 매년 2배씩 증가

>[!note] 트렌지스터
>전기의 흐름을 제어하는 작은 스위치(0과 1구현)
>- IOT에서 트렌지스터 배웠는데 그거랑 다른거임?
>  => 사실 같은건데 운영체제에서 작동 하는것과 IOT에서 작동하는게 문맥이 다르다고 함. 
>  IOT에는 아두이노 보드에서 외부장치를 제어하는 실제 전자 부품이고, 
>  운영체제에서는 CPU와 메인보드가 전기적 통신을 하는건 맞지만 실질적인 운영체제의 역할은 하드웨어 간 통신 위에서 작동하는 소프트웨어 계층이다.

## 03_하드웨어 구성요소
### 3.1 컴퓨터 하드웨어 구성
- 프로세서
- 메인 메모리
- 입출력 장치

### 3.2 메인 보드
- 인쇄 회로 기판(PCB, Printed Circuit Board)
	- 보드의 장치들을 전기적으로 연결해주는 하드웨어 구성 요소
- 메인보드 - 시스템의 중심 PCB
	- 여러 하드웨어 구성요소(프로세서, 메인메모리 등)를 꽂을 수 있는 슬롯 내장
	- 저수준 기능을 담당하는 컴퓨터 침 포함(BIOS...)
		- 하드웨어와 소프트웨어 간의 원활한 통신 (자원관리, 데이터 전송, 장치 및 연결통신 등등)

### 3.3 프로세서 -> CPU
- 일련의 기계어 명령어를 실행하는 하드웨어 구성요소
	- CPU, Central Processing Unit - 프로그램의 명령어를 실행하는 프로세서
	- 보조 프로세서 : 특수 목적 명령어들을 효율적으로 실행
		- ex_)그래픽 or 디지털 신호 처리기
	1. 명령어 페치기 : 명령어 레지스터에 명령어를 로드
	2. 명령어 해석기 
		1. 명령어를 해석
		2. 이에 해당하는 입력 정보를 실행 처리기에 전달
		- ALU(Arithmetic and Logic Unit) : 덧셈, 곱셈같은 기본적인 산술 연산과 대소 비교같은 논리 연산 수행
			- 명령어를 실질적으로 실행
		- 캐시 : 고속 메모리, 메인메모리에 있는 데이터의 복사본 저장 -> 프로세서의 효율 향상
			- 종류 : L1, L2 캐시
			- 메모리에 프로그램을 불러올때 시간이 많이 걸림 -> 캐시에 자주쓰는 프로그램들을 미리 넣어놓는다. (즐겨찾기 같은거 ㅇㅇ)
		- 레지스터 : 프로세서에 위치한 고속 메모리
			- 프로세서가 데이터 조작시, 해당 데이터가 레지스터에 위치해야함.
			- 데이터 사용시 레지스터에 있어야함. 프로세서가 바로 사용할수 있는 데이터를 담는다.
			- 레지스터의 크기는 프로세서가 한번에 처리할수 있는 비트수에따라 결정
				- ex_) 32 비트 프로세서 -> 각 레지스터에 32비트 데이터 로드
			- 범용 레지스터 : 레지스터의 일정 부분을 응용 프로그램이 데이터 값이나 실행중 포인터 값을 빠르게 읽으려고 별도로 예비 해둔것.
			- 컨트롤 레지스터 : 프로그램 카운터(다음 실행할 명령어가 무엇인지 알려줌) 등의 시스템에 관한 정보를 저장

>[!warning] 내가 헷갈렷던거
>Q. 레지스터(고속 메모리)랑 메인메모리랑 같은거임? : ㄴㄴ
>- 레지스터의 역할 : CPU가 데이터 조작시 사용
>- 메인 메모리의 역할 : 프로세스 실행을 위해 Ready상태 -> CPU에 할당하는 과정
>=> 결정적으로 메인 메모리는 CPU외부에 있고, 고속 메모리는 CPU 내부에 있음

>[!note] IOT에서의 레지스터와는 조금 다르다!
>- IOT : 하드웨어와 소프트웨어간의 상호작용
>- 운영체제 : CPU의 명령어실행과 관련된 여러 작업

### 3.4 프로세서(CONT)
- 프로세서 구성요소
	- 컴퓨터 시간은 사티클(클록틱)을 통해 측정
		- 사이클 - 시스템 클록 생성기가 보낸 전기 신호의 한 진폭
		- 클록 생성기는 버스가 데이터를 나르는 주기 설정
			- 초당 사이클 수 (Hz, hertz)로 측정
			- ex_)프론트 사이드 버스 : 프로세서들을 메모리 모듈에 연결, 흔히 몇백메가 헤르츠 정도로 작동
- 시스템의 구성 요소는 다양한 클록 속도로 동작.
	- 프론트사이드 버스 기준, 각 장치의 속도를 결정하는 곱수나 제수 사용
		- 곱수 : 어떤 수에 다른 수를 곱해서 만든 수
		- 제수 : 어떤 수를 나누는 수
- 버스에 있는 어떤 구성요소는 매우 높은 곱수를 가지고, 동일 버스에 있는 다른 구성 요소는 매우 높은 제수를 가진다면?
	- 병목 현상 발생
	- 제수가 큰 장치 < 곱수가 큰 장치
		- 제수가 큰 장치는 느리고, 곱수가 큰 장치는 제수가 높은 장치의 정보에 의존해서 많이 기다려야 함.

![[Pasted image 20250418230727.png]]

>[!Question] 근데 왜 시스템 실행 속도(클록 속도)를 조절 할까? 빠르면 다 좋은거 아닌가...
>- CPU와 메모리, 버스 등은 서로 다른 속도로 동작해야 안정적임
>- 곱수/제수를 써서 각 부품이 적절한 클록 속도로 작동하게 만듦
>- 클록 속도만 높인다고 무조건 성능이 오르지도 않고, 발열, 전력소모 등등 고려 필요

- 칩셋 : 하드웨어(컨트롤러 , 보조 프로세서, 버스 등등)의 집합
	- 메인보드에 통합 -> 시스템의 하드웨어 능력 결정
- 컨트롤러 : 보드의 버스를 통해 데이터 이동 관리

### 3.5 메모리 계층
- 최상위 계층 : 가장 빠르고 비싼 메모리
- 최하위 계층 : 가장 저렴하고 속도가 느린 메모리
	- HDD(하드디스크)가 느린 이유 : 데이터가 순차적으로 배치되어 있음 -> 해당되는 위치에 헤드를 물리적으로 돌리기 때문
- 휘발성 매체 - 전원을 끄면 데이터가 사라짐 (ex:RAM)
	- 레지스터, 캐시, 메인 메모리

### 3.6 메인 메모리
- 휘발성 임의 접근 메모리(RAM, Random Access Memory)
	- 프로세스가 어떤 순서로든 데이터에 접근 가능
- 종류
	- 동적 램(DRAM, Dynamic RAM) - 재생 회로 필요
		- 주기적으로 메모리내용 업데이트 해야 데이터를 기억함.
		- 시간은 많이 걸리지만 가격은 싼편
	- 정적 램(SRAM, Static RAM) - 재생 회로 불필요
- 대역폭 : 단위 시간당 이동하는 데이터 양

### 3.7 2차 저장소(HDD, SSD)
- 저비용으로 대용량의 데이터를 영구적으로 보관
	- 데이터의 접근 속도가 메인 메모리 보다 느림
		- 읽기/쓰기 헤드의 물리적인 움직임
		- 회전 지연 시간
		- 헤드를 통해 데이터가 통과하는 전송 시간
	- 데이터 백업이나 이동 가능한 2차 저장 장치
		- CDs(CD-R, CD-RW), DVDs(DVD-R, DVD+R), 집 디스크, 플로피 디스크, 플래시 메모리 카드, 테이프

### 3.8 버스
- 트레이스의 집합
	- 트레이스 : 하드웨어 장치들간의 정보를 전송, 아주 작은 전기적 연결선
	- 포트 : 정확히 두 장치를 연결하는 버스
	- 입출력 채널 : 서너개 장치에서 입출력 기능을 수행할때 공유하는 버스
	- 프론트 사이드 버스(FSB, Front Side Bus) : 프로세서들을 메모리 모듈에 연결
		- FSB 속도 높음, 메인 메모리와 프로세서 사이에 전송되는 데이터의 양 많음, 성능 향상
- 데이터버스 : 데이터 전송
- 주소 버스 : 해당 데이터의 위치나 수신위치를 결정
- 컨트롤러 : 버스에서 두 신호가 충돌하는 일 방지 -> 메모리 접근에 우선순위 부여
	- 우선순위 : 채널>프로세서
	- 사이클 가로채기!!!!@@ => 입출력 채널이 실제로 프로세서보다 우위에 있음.
- DDR(Double Data Rate) : 200MHz -> 400MHz
	- 데이터 전송을 두번 수행(칩셋과 RAM 모두 지원해야 함.)
- 쿼드 펌핑 : 사이클당 데이터 전송을 네번 수행함. 시스템 메모리 대역폭을 네배로 만든다
- PCI 버스(Peripheral Component Interconnect Bus)
	- 주변장치(사운드 카드, 네트워크 카드 등)를 시스템의 나머지 부분에 연결
- AGP(Acceelerated Graphics Port) : 그래픽 카드와 함께 사용
	- 실시간으로 그래픽 조작(수십~수백 메가바이트 RAM 요구)

### 3.9 직접 메모리 접근(DMA, Direct Memory Access)
- 메모리와 입출력 장치간의 데이터 전송 효율 향상
- CPU 대입 없이 디스크에 있는 데이터 읽어서 메모리에 올리는 방식
	- 장치들과 컨트롤러들이 데이터 블록을 메인 메모리에 직접 전송
	- 프로세서는 자유롭게 소프트웨어 명령어들을 실행
	- DMA 채널은 입출력 컨트롤러를 사용해 데이터 전송 관리
		- 입출력 연산 완료시 인터럽트 통해 프로세서에 알림
	- 다량의 입출력 기능을 담당하는 시스템의 성능 크게 향상
		- ex_) 메인 프레임, 서버

![[Pasted image 20250419002505.png]]

### 3.10 주변 장치
- 컴퓨터가 소프트웨어 명령어를 실행하는데 필수적이지 않은 하드웨어
- 내부 주변 장치(통합 주변 장치)
	- 네트워크 인터페이스 카드, 모뎀, 사운드 카드, 하드디스크, 내부 CD-ROM 드라이브 등
- 문자 장치는 한번에 한 문제 데이터 전송(인터럽트 사용)
	- 키보드, 마우스 등
- 포트와 기타 버스를 통해 컴퓨터에 추가
	- 직렬 포트, 병렬포트, USB, IEEE 1394 포트 , SCSI
		- 직렬포트 : 한번에 한 바이트 데이터 전송(키보드, 마우스에 연결)
		- 병렬포트 : 한번에 여러 비트 전송(프린터와 연결)
		- USB, IEEE : 고속 직렬 인터페이스
			- 핫스와핑 : USB장치는 시스템이 켜져있는 동안 하드웨어 저장 X, 추가 및 인식

![[Pasted image 20250419004313.png]]

## 04_하드웨어의 운영체제 지원
### 4.1 프로세서
- 대부분의 운영체제는 프로셋서를 통해 보호 메커니즘 구현
	- 프로세스가 할당 받지 않은 메모리에 접근하는것을 막음
	- 컴퓨터 시스템의 몇가지 다른 실행 모드
		1. 사용자 모드
		2. 커널 모드 : 특권 명령어 실행과 원하는 작업을 수행하기 위한 자원의 접근 가능
			- 특권 명령어 : 운영체제와 하드웨어가 특정 기능을 수행하기 위해 필요한 명령어
