## 1. 탐욕기법이란?
- 탐욕기법(=그리디 알고리즘) : 매 순간 최적이라고 판단되는 선택을 하는 전략
	- 당장 눈앞의 이익을 최대화 하는 방향
	- ==근사해(최적에 가장 가까운 해)가 반드시 매 순간 최적해라고 할 수는 없다.==
### 1. 단계별 문제 해결
1. 선택이 실현 가능해야 한다.
	- 선택이 문제의 제약 사항들을 만족시켜야 한다.
2. 모든 실현 가능한 선택들 중 선택하는 순간에 최적이라고 여겨지는 선택을 해야 한다.
3. 한번 선택하면 되돌릴수 없다.
### 2. 배낭문제
- 조건 : 배낭에는 최대 10kg만 담을수 있다.
- 가치 : 물건의 중요도
- 목표 : 제한된 무게에서 가치를 최대화 하는 물건의 조합 흐름
	a. 무게 : 6kg / 가치 : 30
	b. 무게 : 5kg / 가치 : 25
	c : 무게 : 7kg / 가치 : 40
=> 가치가 높은것을 우선적으로 선택한다.
	1. 가치가 가장 높은 40을 선택한다. 
	2. c 선택 -> 배낭 무게 : 7kg/10kg
	3. b 선택 -> 배낭 무게 : 12kg/10kg -> 무게 초과
=> ==실현 가능한 조건들을 선택 해야 한다.==(무게 제한, 시간 제한, 경로 제한)

>[!note] 탐욕기법에서 '가치'란?
>문제의 목표를 수치적으로 표현한 기준

## 2. 활동 선택 문제
- 가치 : 선택 가능한 활동 수
- 목표 : 출발지 -> 각 지점의 최소 거리(최소 비용으로 결정) 경로를 구함
- 활동 선택 순서도
	1. 비어있는 해 모음 시작
		- 처음에는 아무것도 선택하지 않은 상태에서 시작(공집합)
		- ex_)어떤 선택, 어떤 활동 X, 초기 상태
	2. 탐욕적인 기준에 따라 해 모음에 추가 할 다음 해 선택
		- 정의가 된 탐욕 기준 : 최대 이익,시간 최소 등
		- 가장 좋아보이는 하나의 해 선택
		- ex_)가치/무게 비율 높은 물건, 가장 일찍 끝나는 활동 등
	3. 새 해 모음이 실현 가능한지 확인
		- 실행 가능시 새 해 모음 확정 / 아니면 선택한 해 버림
		- 지금 선택한것들과 제약 조건이 만족하는지 확인
		- ex_)무게 초과, 시간 겹침, 제한 초과 등
	4. 새 해 모음이 최종 해라면 종료(아니면 2번 반복)
		- 더이상 선택할 후보가 없거나 해가 문제를 완전히 해결했다면 알고리즘 종료
		- 해 초기화 (공집합 초기화)
		- YES 해를 추가, NO 버리고 다음 해 진행
		- 더이상 없으면 종료
- ex_)활동 선택 문제 : 겹치지 않는 활동을 가장 많이 선택하기(수강 신청)

| 활동  | 시작시간 | 종료시간 |
| --- | ---- | ---- |
| a   | 1    | 4    |
| b   | 3    | 5    |
| c   | 0    | 6    |
| d   | 5    | 6    |
| e   | 8    | 9    |
- 탐욕 기준 : 가장 빨리 끝나는 활동부터 선택해 최적화 : 해 공집합
	1. a : 1,2,3,4(O)
	2. b : 3,4,5 -> a(3,4)가 겹침(X)
	3. c : 0,1,2,3,4,5,6 -> a(1,2,3,4)가 겹침(X)
	4. d : 5,6(O)
	5. e : 8,9(O)
=> a,d,e
### 1. 거스름돈 문제(탐욕적 선택)
>[!question] 거스름돈 주기
> 동전들 500, 100, 50, 10, 5, 1원이 있다.
> 한 문구점에서 손님이 볼펜 1개를 210원, 지우개 1개를 100원, 풀 1개를 36원에 사려고 한다.
> 1000원짜리 지폐를 낸다고 할때 어떻게 하면 거스름돈을 효율적으로 줄 수 있을까?

- 출납원 : 1000-(210 + 100 + 36) = 654원 거슬러 줘야함
	- 500원 : 1개
	- 100원 : 1개
	- 50원 : 1개
	- 1원 : 4개
- 남은 돈보다 작은 동전만 선택
- 가장 큰 동전(최적)으로 구성된 선택

>[!warning] 문제의 제약 조건을 만족하는(실현 가능한) 선택지들만 대상으로 삼는다.
>-> 이중에서 가장 좋아보이는 현재 기준의 최적해 선택

- 한국 화폐 : 상위 단위가 하위 단위의 배수
	- 큰 값 우선 전략이 항상 최소 동전 수를 보장
- 시간 복잡도 : 0(k)
- 공간 복잡도 : 0(k)
- coinValue : 동전 단위
- numcoin : 동전 개수
- 서비스 : 거스름돈 계산으로 분리
- 사용 <-> 콘솔
- 모델링

```java
package Mentoring;
import java.util.Scanner; // 사용자 입력을 받기 위한 라이브러리

public class Coin{
	public static void main(String[] args){
		// coinValue 배열: 동전 액면가를 큰 금액부터 저장 (탐욕 알고리즘 적용을 위해)
		int[] coinValue = {500, 100, 50, 10, 5, 1}; 
		int i; // 동전 배열의 인덱스
		int[] numCoin; // 각 동전별로 사용할 개수를 저장할 배열
		int change; // 사용자가 입력한 거스름돈 액수
		int count = 0; // 사용될 동전의 총 개수
		
		numCoin = new int[6]; // 6개 동전 종류에 대한 배열 생성 및 초기화
		
		Scanner scan = new Scanner(System.in); // 사용자 입력을 받기 위한 Scanner 객체 생성
		
		// numCoin 배열을 모두 0으로 초기화
		for(i = 0; i < numCoin.length; i++){
			numCoin[i] = 0;
		}
		
		System.out.println("거스름돈을 입력하세요(0~999) : ");
		change = scan.nextInt(); // 사용자로부터 거스름돈을 정수로 입력받음
		System.out.println(change + "원의 거스름돈은 다음과 같습니다. ");
		
		i = 0; // 가장 큰 단위 동전부터 시작
		
		// *탐욕 알고리즘 핵심 부분*
		while(change > 0){ 
			// **탐욕적 선택: 현재 가능한 가장 큰 동전을 최대한 많이 사용**
			// 현재 동전으로 줄 수 있는 최대 개수 계산
			numCoin[i] = change / coinValue[i]; 
			
			// 전체 동전 개수에 누적 (최소 동전 개수 계산)
			count = count + numCoin[i]; 
			
			// 남은 거스름돈 계산 (나머지 연산 사용)
			change = change % coinValue[i];
			
			// 사용된 동전이 있으면 결과 출력
			if(numCoin[i] > 0){
				System.out.println(coinValue[i] + "원짜리 동전 : " 
				+ numCoin[i] + "개");
			}
			i++; // 다음 동전 종류로 이동
		}
		System.out.println("\n거스름돈에 포함된 동전들의 총 개수 : " + count);
		scan.close(); // Scanner 자원 해제
	}
}
```




