## 1. 정렬 알고리즘이란?
- 알고리즘 데이터를 일정한 순서대로재배열 하는 알고리즘
	- 오름차순 or 내림차순으로 재배치
		- 오름차순 : 작은수 -> 큰수
		- 내림차순 : 큰수 -> 작은수

## 2. 선택정렬
- 가장 작은(또는 큰) 값을 선택해서 현재 위치와 교환하는 정렬 알고리즘
- 장점
	1. 구현이 간단하다.
	2. 메모리를 거의 사용하지 않는다.(오버헤드, 임베디드 등 메모리가 제약적인 환경에서 유리하다)
	3. 로직이 직관적이다.
- 특징
	- 교환 횟수가 적다.(회전당 한번)
	- 데이터 크기가 작을수록 유리하다.
- 예시 : 키,나이,점수 등 낮은 값 -> 높은값 나열

>[!question] 배열 : {9,7,8,2,5} 를 정렬 하세요
>

1. 1회전(i = 0) : 전체 배열 중 가장  작은 수 '2'를 찾아 현재 위치(0번째)의 수 '9'와 교환
   => {2,7,8,9,5}
2. 2회전(i = 1) : 남은 부분 중 가장 작은수 '5'를 찾아 '7'과 교환
   =>{2,5,8,9,7}
3. 3회전(i = 2) : 8,9,7 중에서 가장 작은 수 '7'을 찾아 '8'과 교환
   => {2,5,7,9,8}
4. 4회전(i = 3) : 9,8 중에서 가장 작은 수 '8'과 '9'를 찾아 교환
   => {2,5,7,8,9}
5. (i = 4): 마지막 요소는 자동 정렬

```java
for(int i = 0; i< n-1; i++){
	int minIndex = i;
	for(int j = i+1; j<n; j++){
		if(arr[j] < arr[minIndex]){
			minIndex = j;
		}
	}
	swap(arr, i, minIndex); // 여기서 교환
}
```

![[Pasted image 20250613112156.png]]


## 3. 삽입 정렬
- 리스트의 각 요소를 하나씩 꺼내어 이미 정렬된 부분에 적절한 위치에 끼워넣는 방식
- ex_)학생 리스트를 이름 또는 점수 순으로 정렬할때
- 특징
	- 같은 값을 가진 요소들이 정렬된 후에도 원래의 순서를 유지
	- 간단하고 직관적

>[!Question] 배열 : {5,3,4,1,2} 를 정렬하세요

1. 첫번째 원소 5는 이미 정렬된 것으로 간주
2. 두번째 원소 3을 이미 정렬된 부분(5)앞에 끼워 넣음
   => {3,5}
3. 세번째 원소 4를 {3,5} 사이에 끼워 넣는다.
   => {3,4,5}
4. 네번째 원소 1을 {3,4,5} 앞에 넣는다.
   => {1,3,4,5}
5. 다섯번째 원소 2는 {1,3} 사이에 끼워 넣는다.
   => {1,2,3,4,5}

```java
for( i = 1; i < n; i++){
	insertElement = A[i]; //삽입할 요소 A[i]를 저장
	j = i-1; //A[i]를 A[0...i-1]에 삽입할 위치 찾음
	while(j >= 0 && A[ j ] > insertElement){ 
		A[j+1] = A[j]; // A[ j ]를 오른쪽으로 한자리 이동
		j = j-1;
	}
	A[ j+1] = insertElement; // A[i]를 찾은 위치에 삽입
}
```

- `while(j >= 0 && A[j] > insertElement)`  : 삽입 정렬 알고리즘에서 매우 중요한 부분
	- 현재 삽입 하려는 값(insertElement)이 적절한 위치에 들어갈수 있도록 그보다 큰 값은 오른쪽으로 한칸씩 이동
	- (j >= 0)인덱스가 배열의 유효 범위 내에 있는지를 확인하는 조건
	- `(A[j] > insertElement)` : 현재 비교중인 `A[j]` 값이 삽입하려는 값 `insertElement` 보다 크다면 이 값을 오른쪽으로 밀어야 함.

![[Pasted image 20250613010839.png]]

