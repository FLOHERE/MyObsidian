## 1번
1. 라면 끓이는 방식을 알고리즘으로 바꾸세요
	1. 알고리즘이 "아닌" 예시
		1. 마트에서 라면을 산다.
		2. 냄비에 물을  두컵 붇고 끓인다
		3. 끓을때 면과 스프를 넣고 면이 익을때까지 기다린다.
	2. "수정한" 라면 요리법
		1. 마트에 간다.
		2. 마트에서 임의의 라면 하나를 선택한다.
		3. 계산대에서 라면을 계산하고 집으로 돌아온다.
		4. 부엌으로 들어가서 라면 봉지를 제거하고, 재료(스프, 건더기, 면 등)을 꺼낸다.
		5. 냄비를 꺼내 생수 500ML를 넣고, 가스버너 위에 올린다.
		6. 냄비 뚜껑을 닫는다.
		7. 물이 100도 이상 끓으면 면, 스프, 건더기를 모두 넣는다.
		8. 3분 뒤 불을 끄고 냄비에서 라면을 모두 그릇으로 옮긴다.
		9. 젓가락으로 맛있게 먹는다.
2. 집까지 버스를 타고 가는 과정을 알고리즘으로 표시하세요
	1. 여기서 집까지 몇번 버스를 타고 가는지 핸드폰으로 검색해본다.
	2. 지도에 안내된 최적의 경로를 선택한다.
	3. 지도의 안내를 따라 버스 정류장을 간다.
	4. 버스 정류장에서 버스를 기다린다.
	5. 경로에 안내된 버스를 타고 집에서 가장 가까운 정류소에서 내린다.
	6. 경로에 안내된 대로 걸어서 집에 간다.

## 2번
2. 순차탐색 알고리즘(+ 이진탐색)
	- 프로그램1-1 : 배열 내의 최대값을 찾는다.
	- 주어진 배열 : \[72,60,83,47,89,95,100]
- 수도코드
	1. 72와 60 비교
	2. 더 큰 수 최대값으로 임시 저장
	3. 72 <-- 임의의 최대값
	4. 다음 수와 비교
	   72 < 83
	5. 83 <-- 바뀐 임의의 최대값
	6. 4~5번 과정을 반복한다.(계속해서 다음 수와 비교하며 최대값을 저장)
		83 > 47
		83 < 89
		95 > 89
		95 < 100
	7. 답 : 100
- 코드

```java
package MiddleTest;

public class BigNumFind{
	
	public static void main(String[] args){
		int arry[] = {72,60,83,47,89,95,100};
		int Big = 0;
		
		for(int i = Big; i < arry.length; i++){
			if(Big < arry[i]){
				Big = arry[i];
			}else{
			
			}
		}
		System.out.println("가장 큰 수 : " + Big);
	}
}
```

## 3번
- 다음에 주어진 숫자들 중 가장 큰 수와 가장 작은 수를 동시에 찾으려면 최소 몇번의 숫자 비교가 필요한가?
	- \[45,60,90,20]
- 정답 : 4번이다.
- 풀이 : 숫자가 모두 네개이므로, 60 기준 중간을 잘라서 앞 뒤로 비교하면 된다.
	1. 45 < 60
	2. 90 > 20
	3. 45 > 20
	4. 90 > 60