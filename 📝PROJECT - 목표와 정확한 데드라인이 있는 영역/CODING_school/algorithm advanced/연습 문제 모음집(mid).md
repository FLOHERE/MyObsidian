## 1번
1. 라면 끓이는 방식을 알고리즘으로 바꾸세요
	1. 알고리즘이 "아닌" 예시
		1. 마트에서 라면을 산다.
		2. 냄비에 물을  두컵 붇고 끓인다
		3. 끓을때 면과 스프를 넣고 면이 익을때까지 기다린다.
	2. "수정한" 라면 요리법
		1. 마트에 간다.
		2. 마트에서 임의의 라면 하나를 선택한다.
		3. 계산대에서 라면을 계산하고 집으로 돌아온다.
		4. 부엌으로 들어가서 라면 봉지를 제거하고, 재료(스프, 건더기, 면 등)을 꺼낸다.
		5. 냄비를 꺼내 생수 500ML를 넣고, 가스버너 위에 올린다.
		6. 냄비 뚜껑을 닫는다.
		7. 물이 100도 이상 끓으면 면, 스프, 건더기를 모두 넣는다.
		8. 3분 뒤 불을 끄고 냄비에서 라면을 모두 그릇으로 옮긴다.
		9. 젓가락으로 맛있게 먹는다.
2. 집까지 버스를 타고 가는 과정을 알고리즘으로 표시하세요
	1. 여기서 집까지 몇번 버스를 타고 가는지 핸드폰으로 검색해본다.
	2. 지도에 안내된 최적의 경로를 선택한다.
	3. 지도의 안내를 따라 버스 정류장을 간다.
	4. 버스 정류장에서 버스를 기다린다.
	5. 경로에 안내된 버스를 타고 집에서 가장 가까운 정류소에서 내린다.
	6. 경로에 안내된 대로 걸어서 집에 간다.

## 2번
2. 순차탐색 알고리즘(+ 이진탐색)
	- 프로그램1-1 : 배열 내의 최대값을 찾는다.
	- 주어진 배열 : \[72,60,83,47,89,95,100]
- 수도코드
	1. 72와 60 비교
	2. 더 큰 수 최대값으로 임시 저장
	3. 72 <-- 임의의 최대값
	4. 다음 수와 비교
	   72 < 83
	5. 83 <-- 바뀐 임의의 최대값
	6. 4~5번 과정을 반복한다.(계속해서 다음 수와 비교하며 최대값을 저장)
		83 > 47
		83 < 89
		95 > 89
		95 < 100
	7. 답 : 100
- 코드

```java
package MiddleTest;

public class BigNumFind{
	
	public static void main(String[] args){
		int arry[] = {72,60,83,47,89,95,100};
		int Big = 0;
		
		for(int i = Big; i < arry.length; i++){
			if(Big < arry[i]){
				Big = arry[i];
			}else{
			
			}
		}
		System.out.println("가장 큰 수 : " + Big);
	}
}
```

## 3번
- 다음에 주어진 숫자들 중 가장 큰 수와 가장 작은 수를 동시에 찾으려면 최소 몇번의 숫자 비교가 필요한가?
	- \[45,60,90,20]
- 정답 : 4번이다.
- 공식 : n이 짝수일 때 -> `3n/2 - 2` 
	   n이 홀수 일때 -> `3(n - 1)/2`
- 풀이 : 숫자가 모두 네개이므로, 60 기준 중간을 잘라서 앞 뒤로 비교하면 된다.
	1. 45 < 60
	2. 90 > 20
	3. 45 > 20 -> 가장 작은 수 : 20
	4. 90 > 60 -> 가장 큰수 : 90

```java
public class MinMaxSimple {
    public static void main(String[] args) {
        int[] arr = {45, 60, 90, 20};

        int min = Math.min(arr[0], arr[1]);
        int max = Math.max(arr[0], arr[1]);

        min = Math.min(min, Math.min(arr[2], arr[3]));
        max = Math.max(max, Math.max(arr[2], arr[3]));

        System.out.println("최솟값: " + min);
        System.out.println("최댓값: " + max);
    }
}
```


## 4번 
- 다음 수열의 n번째 항을 구하는 재귀 알고리즘을 작성하시오
	- $a_n = 5a_n-1 + 3, a_1 = 0$

![[Pasted image 20250424125607.png]]

```java
package MiddleTest;

import java.util.Scanner;

public class num5 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        //문제 n번째 항 구하기 : an = 5a(n-1)+3 , a1 = 0

        System.out.print("구하고 싶은 항 입력(n의 값) : ");
        int n = sc.nextInt();
        System.out.print("결과 : " + function1(n));
    }

    public static int function1(int i) {
        if(i == 1){
            return 0;
        }else {
            int result = function1(i - 1) * 5 + 3;
            return result;
        }
    }
}
```

- 정렬된 정수 배열이 주어졌을 때, 주어진 정수 X가 배열에 존재하면 해당 인덱스를 출력하고, 존재 하지 않으면 -1을 출력하는 프로그램을 작성하세요.

```java
package MiddleTest;

//정렬된 정수 배열이 주어졌을 때, 주어진 정수 X가 배열에 존재하면 해당 인덱스를 출력하고, 존재 하지 않으면 -1을 출력하는 프로그램을 작성하세요.
public class num6 {
    public static void main(String[] args) {
        int array[] = {1,3,5,7,9,11};
        int x = 7;

        for(int i = 0; i<array.length; i++){
            if(x == array[i]){
                System.out.println(array[i]);
            } else{
                System.out.println("-1");
            }
        }
    }
}
```

## 5번 (Chapter04 파일 참조)
- 그리디 알고리즘 (동전 거스름돈)
## 6번
1. 다음 괄호안에 알맞은 단어를 채워 넣어라
	1. 주어진 순서에 따라 차레로 탐색하는 알고리즘을 (_순차탐색_) 이라고 한다.
	2. 이진탐색은 (_정렬된_) 항목들에 대해서 (_중간_)에 있는 항목들을 비교하여 그 결과에 따라 (_같으면_) 탐색을 마치고, 다르면 작은 항목들이 있는 부분 또는 큰 항목들이 있는 부분을 같은 방식으로 탐색한다.
	3. 동전 거스름돈 문제에서는 (_액면가가 큰_) 동전을 항상 선택한다. 이는 (_그리디_) 알고리즘의 일종이다.
	4. 한붓 그리기 문제를 해결하는 알고리즘의 핵심은 현재 점에서 다음으로 이동 가능한 점을 선택할때는 반드시 현재 점으로 돌아오는 (_사이클_)이 존재하여야 한다는 것이다.
	5. 가짜 동전 찾기에서 동전 더미를 (_반_) 으로 분할하여 저울에 달고, 가짜 동전이 있는 더미를 계속해서 (_반_)으로 나누어 저울에 단다. 이는 (_분할탐색_) 알고리즘의 일종이다.

## 7번
1. 다음 괄호 안에 알맞은 단어를 채워 넣어라
	1. 알고리즘이란 (_문제_)를 해결하는 (_단계적_) 절차 또는 방법이다.
	2. 알고리즘의 일반적인 특성에는 (_효율성_), (_수행성_), (_정확성_),(_유한성_) 이 있다.
	3. 알고리즘은 일반적으로도 (_수도_) 코드 형태로 표현된다.
	4. 알고리즘의 효율성은 주로 (_시간 복잡도_)가 사용된다.
	5. 알고리즘이 수행하는 (_연산_) 횟수를 (_입력_) 크기에 대한 함수로 표현한것을 시간 복잡도 라고 한다.
	6. 알고리즘의 복잡도 표현 방법에는 (_최선_)경우 분석, (_최악_) 경우 분석, (_평균_)경우 분석이 있다.
	7. 입력 크기가 무한대로 커질때의 복잡도를 간단히 표현하기 위해 사용하는 표기법을 (_점근적_) 표기라고 한다.
	8. O - 표기는 점근적 (_상한_)을 나타낸다.
	9. Ω - 표기는 점근적 (_하한_)을 나타낸다.
	10. Θ - 표기는 동일한 (_증가율_)을 나타낸다.

