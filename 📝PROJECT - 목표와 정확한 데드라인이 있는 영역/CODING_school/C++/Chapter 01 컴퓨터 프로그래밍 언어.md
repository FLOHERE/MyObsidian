- 개요
	1. 컴퓨터 시스템의 구성
	2. 프로그래밍 언어의 변천사
	3. 프로그래밍 언어의 패러다임
	4. 프로그램 설계
	5. 프로그램 개발
	6. 프로그램 테스트

## 01. 컴퓨터 시스템의 구성
### 1. 하드웨어
- 컴퓨터 - 두가지 구성 요소
	- 하드웨어 : 물리적 장치
	- 소프트웨어 : 하드웨어가 움직이도록 만드는 프로그램(명령어)의 집합
- 하드웨어의 구성요소(버스로 다 이어져 있음)
	- 중앙 처리 장치
		- 메인 메모리
		- 보조 저장 장치
		- 입력 장치
		- 출력 장치
		- 통신 장치

>[!note] 버스란?
>물리적인 케이블 또는 회로가 그 요소들을 연결하고 있다는 뜻(다양한 형태의 물리적 연결 방식).
>컴퓨터 내부에서 데이터, 주소, 제어신호등을 전달하는 역할을 함.

- 중앙처리 장치(CPU) : 제어장치, ALU, 레지스터로 구성
	- CPU (Central Processing Unit)
	1. 제어장치 : 시스템 작동 조정
	2. ALU : 산술 논리 장치
	3. 레지스터(+,-, OR, NOT) : 전류제어 장치

- 메인 메모리 : 처리중인 프로그램과 데이터가 일시적으로 저장되는 공간
	- RAM(Random Access Memory)
	- 프로그램 : 컴퓨터에 명령을 내리는 코드의 집합
	- 데이터 : 정보를 나타내는 값이나 기호의 집합, 
	  컴퓨터 시스템에서 처리되거나 분석되는 기본 단위
	- 메모리의 구조 : 주소 + 내용물

- 보조 저장 장치 : 프로그램과 데이터가 영구적으로 저장
	- SDD, HDD, CD,USB
- 입력 장치 : 프로그램과 데이터를 입력할때 사용
	- 키보드, 마우스
- 출력 장치 : 결과가 표시되는 장치
	- 모니터, 프린터
- 통신 장치 : 여러 컴퓨터를 연결해 컴퓨터 네트워크를 구성하는데 사용

### 2. 소프트웨어
- 시스템 소프트웨어와 응용 소프트웨어로 구분
#### 1. 시스템 소프트웨어
- 컴퓨터의 하드웨어 리소스 관리, 필요한 정보 처리하는 프로그램으로 구성
1. 운영체제 : 컴퓨터 자원 관리, 다른 소프트웨어가 하드웨어를 효율적으로 사용하도록 지원
2. 시스템 지원 프로그램 : 운영체제 보조, 시스템관리(+보안)
3. 시스템 개발 프로그램 : 개발도구 라이브러리(컴파일러, 디버거...)

#### 2. 응용 소프트웨어
1. 범용 소프트웨어 : 웹 브라우저, MS Office 등 다양한 프로그램
2. 특수 소프트웨어 : 특정 분야, 작업을 위함(ex_: CAD) 

## 02. 프로그래밍 언어의 변천사
### 1. 기계어
- 프로그램을 만들기 위해 컴퓨터 언어 사용
- 기계어(0101010...) -> 기호어(어셈블리어, MOV a,b) -> 고급언어(java, C++...)

### 2. 기호어(어셈블리어)
- 인간이 만든 프로그램 -> 기계어로 변환

### 3. 고급언어
- 각기 다른 기계에 서로 다른 기계 언어로 프로그램을 만들기 쉽지 않음
	 -> 프로그래머의 효율 개선을 위해 고급 언어 제작
- 고급언어 -> 여러 컴퓨터에 이식 가능 -> 본질적인 애플리케이션 문제에 집중 가능(컴퓨터 신경 X)
- 프로그래머가 어셈블리어의 세부적인 내용을 기억하지 않아도 된다는 강점
- FORTRAN : 처음으로 가장 널리 사용된 고급언어(IBM이 만듦)
	- 곧 COBOL 등장

## 03. 프로그래밍 언어의 패러다임
### 1. 패러다임이란?
- 프로그램이 데이터를 처리하는 방법을 설명하는 모델
- = 프레임 워크

- 프로그래밍 언어의 패러다임
	1. 절차형 : ex_) FORTRAN, C, C++
	2. 객체 지향형 : ex_) Smalltalk, C++, C#, JAVA
	3. 함수형 : ex_) LISP, Scheme
	4. 논리형 : ex_) Prolog

### 2. 절차형 패러다임
- 명령어의 순차적 집합으로 구성
![[Pasted image 20250317215510.png]]

### 3. 객체 지향형 패러다임
- 특정 형태의 데이터에 적용할수 있는 프로시저를 하나로 묶음
- 객체 : 특정 형태의 데이터 + 데이터에 적용할수 있는 모든 작업(변수 + 메서드)

>[!note] 프로시저
>특정 작업을 수행하기 위해 미리 정의된 코드 블록.
>중복 코드 방지, 코드 관리와 재사용성 높임

- 프로시저
	- DB에 대한 일련의 작업을 정리한 절차 -> 관계형 데이터 베이스 관리 시스템에 저장
	- 쿼리문을 하나의 메서드 형식으로 만듦 -> 어떤 동작을 일괄적으로 처리
	- 작업을 정리한 절차
- 함수란?
	- 하나의 특별한 목적의 작업을 수행하귀 위해 독립적으로 설계된 코드의 집합
	- 여러 작업을 위한 기능
	- 로직을 도와주는 역할, 간단한 계산, 수치를 나타냄

>[!note] 쿼리란?
>DB에 원하는 정보를 요청하는 코드

| 프로시저                | 함수                 |
| ------------------- | ------------------ |
| 특정한 작업을 수행한다        | 특정한 계산을 수행한다       |
| 리턴값을 가질수도, 안가질수도 있다 | 리턴값은 반드시 가져와야 한다.  |
| 리턴값을 여러개 가질수도 있다    | 오직 하나의 리턴값을 가질수 있다 |
| 서버에서 기술             | 클라이언트에서 기술         |
| 수식 내에서 사용 불가        | 수식 내에서만 사용 가능      |
| 단도긍로 문장 구성 가능       | 단독으로 문장 구성 불가능     |

### 4. 함수형 패러다임
- 입력을 넣으면 대응되는 출력이 나오는 형태
- 명령어 사용 X
- 메모리 상태 추적 X
- 단순하게 기본 함수만 수행
- 기본적인 함수 조합 -> 프로그램 or 새로운 함수 생성

```scala
sum(first(6,8)), first(rest(6,8))

//list(6,8) -> first() : 6 -> sum()으로 이동
//list(6,8) -> rest() : 8 -> first() : 8 -> sum()에서 모임 = 14
```

### 5. 논리형 패러다임
- 일련의 사실과 규칙 기반 -> 쿼리에 응답
- T/F

### 6. C++ 언어의 패러다임
- C 언어에서 발전 -> 절차형 패러다임에 기초
- 클래스 + 객체 제공 -> 객체 지향형 패러다임 활용

## 04. 프로그램 설계
1. 프로그램 설계 전 준비 
	- 프로그램 요구 사항
	- 프로그램 인터페이스 설계 미리 준비
2. 문제 이해 
	- 문제를 명확하게 하지 않으면 잘못된 답이 나올수 있다.
3. 해결 방법 개발
	- 통합 모델링 언어 : 컴퓨터 시스템 설계, 명세서 작성, 문서화를 위한 표준 도구
		- 크고 복잡한 시스템, 프로그램, 프로그램 내부의 객체 설계시 사용
	- C++과 같은 객체 지향형 프로그래밍 언어의 경우, 객체들의 관계 나타냄
	- ex_)슈도 코드

## 05. 프로그램 개발
- 프로그램 개발 과정
![[Pasted image 20250325203001.png]]

1. 프로그램 코드 작성
	- 텍스트 에디터 : 프로그램 코드 작성시 사용하는 소프트웨어
		- 문자 데이터 입력, 수정, 저장, 등등 
2. 프로그램 컴파일
	- 컴파일 : 디스크에 저장된 소스파일의 정보 -> 컴퓨터가 이해할수 있는 기계어로 변환하는 과정
		- 변환 프로그램
3. 프로그램 링크
	- 프로그램 -> 여러 함수로 구성
		- 함수 => 프로그래머가 직접 소스코드 내부 작성 or 입출력 처리 + 수학 라이브러리 함수 등 다른곳에 위치 할수도 있음
	- 다른곳에 위치한 함수 -> 읽어들여함
	- 링크 : 시스템 함수 + 직접 만든 함수 = 실행 파일로 결합하는 과정
	- 링커 : 실행 파일 결합에 사용되는 프로그램
4. 프로그램 실행
	- 링크가 완료되면 실행할 준비 끝
	- 'run 명령어' 사용 -> 프로그램을 메인 메모리로 읽어들임 -> 실행
	- 일반적인 프로그램 이 실행시
		1. 프로그램은 사용자 또는 파일로부터 처리할 데이터 읽어들임
		2. 내부적으로 처리
		3.  사용자의 모니터 or 파일에 출력
	-  프로그램의 작업 완료시
		1.  운영체제에게 알림
		2. 운영체제는 메모리에서 프로그램 제거
		3. 프로그램 작성 후 테스트 

## 06 프로그램 테스트
1. 테스트 데이터 설계
	- 설계 검증(테스트 케이스)
	- 테스트 케이스 : 오류 유무 확인 
		- 프로그램 만든 후 테스트 데이터가 됨
		- 프로그램 설계하는 과정부터 개발하는 동안 계속해서 만들어짐
2. 프로그램 오류
	- 설계 오류 : 문제 정의나 문제 이해가 잘못된 경우 발생
	- 코드 오류 : 컴파일 오류 메세지 확인 -> 쉽게 해결, 일부 코드 오류는 경고 메세지 출력
	- 논리 오류 : 코드는 맞는데 내가 의도한대로 동작하지 않을때
		- 가장 해결하기 어려운 논리 오류

## 07 C++ 프로그래밍
- C++ 언어의 표준
	- ANSI(미국 표준원, 1998)
		- C++ 언어에 대한 표준 설정
	- ISO / IEC 14882 문서에 작성됨. 유료 문서
	- 표준의 진화
		- 1998 - C++98, 2003 - C++03, 2007 - C++TR1, 2011 - C++11
	- 표준의 중요성
		- 표준에 의해 작성된 C++
			- 모든 플랫폼, 무든 표준 C++ 컴파일러에 의해 컴파일
			- 동일한 실행 결과 보장
			- 운영체제와 컴파일러의 조율에 관계없는 높은 호환성
	- 비 표준 C++ 프로그램
		- Visual C++, Borland C++ 등 컴파일러 회사 고유의 비 표준 문구
		- 특정 C++ 컴파일러에서 컴파일
		- 호환성 결여
![[Pasted image 20250325223219.png]]

- C 언어와의 호환성
	- C언어의 문법 체계 계승
		- 소스 레벨 호환성 : 기존에 작성된 C 프로그램 그대로 가져다 사용
		- 링크 레벨 호환성 : C 목적 파일과 라이브러리를 C++ 프로그램에서 링크
1. 객체 지향 개념 도입
	- [[캡슐화(Encapsulation)]], [[상속(Inheritance)]], [[다형성(Polymorphism)]]
	- 소프트웨어의 재사용을 통해 생산성 향상
	- 복잡하고 큰 규모의 소프트웨어의 작성, 관리, 유지보수 용이
2. 엄격한 타입 체크
	- 실행 시간 오류의 가능성 줄임
	- 디버깅 편리
3. 실행 시간의 효울성 저하 최소화
	- 실행 시간을 저하시키는 요소와 해결
		- 작은 크기의 멤버 함수 잦은 호출 가능성 -> 인라인 함수로 실행 시간 저하 해소

- 함수 중복(function overloading)
	- 매개변수의 개수나 타입이 다른 동일한 이름의 함수들 선언
- 디폴트 매개변수(default parameter)
	- 매개변수에 디폴트 값이 전달 되도록 함수 선언
- 참조와 참조변수(reference)
	- 하나의 변수에 별명을 사용하는 참조 변수 도입
- 참조에 의한 호출(call - by - reference)
	- 함수 호출 시 참조 전달
		- 참조를 전달한다 = 객체의 메모리 주소(참조값)을 전달한다는 의미. -> 위치 주소를 넘긴다는 뜻.
- new/delete 연산자
	- 동적 메모리 할당/ 해제를 위해 new 와 delete 연산자 도입
- 연산자 재정의
	- 기존 C++ 연산자에 새로운 연산 정의
- 제네릭 함수와 클래스
	- 데이터 타입에 의존X
	- 일반화 시킨 함수나 클래스 작성 가능

- [[객체]], [[클래스]]

- C++에서 상속이란?
	- 객체가 자식 클래스의 멤버와 부모 클래스에 선언된 모양 그대로 멤버들을 가지고 탄생

![[Pasted image 20250326160902.png]]

- 소프트웨어 생산성 향상
	- 소프트웨어의 생명 주기 단축 문제 해결 필요
	- 개발 시간이 많음 -> 줄여야 함
	- 작성된 코드의 재사용 필요
	- C++ 클래스 상속 및 객체 재사용으로 해결
- 실세계에 대한 쉬운 모델링
	- 과거의 소프트웨어 : 수학 계산이나 통계 처리에 편리한 절차 지향 언어 적합
	- 현대 소프트웨어
		- 물체 혹은 객체의 상호작용에 대한 묘사 필요
		- 실세계는 객체로 구현된 세계
		- 객체를 중심으로 하는 객체 지향 언어 적합

### 제네릭 함수와 제네릭 클래스
- 제네릭 함수(generic function) : 동일한 프로그램 코드에 다양한 데이터 타입 적용 -> 일반화
	- 어떤 데이터 타입의 데이터가 들어와도 처리 가능 -> 마허라 같은놈
- 제네릭 클래스(generic class) : 동일한 프로그램 코드에 다양한 데이터 타입 적용 -> 일반화
	- 객체 생성시 타입 지정.
	- 코드 재사용성 높음, 타입 미리 지정해서 안전, 형변환 필요 X
- 예시)
```java
// T라는 타입 매개변수를 받는 제네릭 클래스
class Box<T> {
    private T value;

    public void setValue(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}

public class Main {
    public static void main(String[] args) {
        // Integer 타입을 저장하는 Box
        Box<Integer> intBox = new Box<>();
        intBox.setValue(10);
        System.out.println(intBox.getValue()); // 10

        // String 타입을 저장하는 Box
        Box<String> strBox = new Box<>();
        strBox.setValue("Hello");
        System.out.println(strBox.getValue()); // Hello
    }
}
```

- template 키워드로 선언
	- 템플릿 함수 or 템플릿 클래스라고도 부름
- java, C# 등 다른 언어에도 동일한 기능 O.

### 제네릭 프로그래밍(generic programming)
- 제네릭 함수 + 제네릭 클래스 = 프로그램 작성 -> 새로운 프로그래밍 패러다임
- 중요!

- C++언어는 C언어와 호환성 추구
	- 장점 : 기존에 개발된 C 프로그램 코드 활용
	- 단점 : 캡슐화 원칙 붕괴
		- C++에서 전역 변수와 전역 함수 사용
		- 부작용 발생 염려

![[Pasted image 20250326162602.png]]

- 편집
	- C++ 소스 프로그램은 텍스트 파일
		- 아무 텍스트 편집기로 편집 가능
	- 표준 확장자 : .cpp
	- Visual studio 써라
- 컴파일
	- 소스 프로그램 -> 목적 파일(기계어)로 변환
		- .cpp 파일 -> obj 파일로 변환(중간 객체 파일)
		- 왜 굳이 바꿈? : 파일 관리 편함 + 생성된 객체 파일간 혼동 피함
		- 자바에서는 .java -> .class 로 변환됨

### 링킹
- 목적 파일끼리 합침 => 실행파일 만드는 과정
	- 목적 파일은 바로 실행 X
- 목적 파일과 C++ 표준 라이브러리 함수 연결, 실행 파일을 만드는 과정
- ex_) hello.obj + cout 객체 + << 연산자 함수 = hello.exe 생성

- 프로그램 실행과 디버깅
	- 실행 파일은 
